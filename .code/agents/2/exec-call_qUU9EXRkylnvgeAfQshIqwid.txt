docker-compose.override.yml:18:      - mt5
fix_services.sh:110:    mt5_response = requests.get("http://localhost:5001/symbol_info_tick/EURUSD", timeout=5)
fix_services.sh:111:    if mt5_response.status_code == 200:
fix_services.sh:112:        tick_data = mt5_response.json()
fix_services.sh:129:        print(f"✗ MT5 returned status {mt5_response.status_code}")
fix_services.sh:176:echo "5. Monitor logs: docker-compose logs -f django celery mt5"
core/journal_sync.py:4:    import MetaTrader5 as mt5  # type: ignore
core/journal_sync.py:6:    mt5 = None  # type: ignore
core/journal_sync.py:25:    if mt5 is None or not mt5.initialize():
core/journal_sync.py:31:    deals = mt5.history_deals_get(from_date, to_date)
core/journal_sync.py:40:            "type": "BUY" if deal.type == mt5.DEAL_TYPE_BUY else "SELL",
django_tick_endpoint.py:9:from utils.mt5_kafka_producer import MT5KafkaProducer
PULSE_WYCKOFF_LIVE_README.md:73:docker-compose up -d mt5 redis django streamlit
PULSE_WYCKOFF_LIVE_README.md:132:- Review API logs: `docker-compose logs mt5`
config/risk_config.yaml:59:    close_all_positions: true
Makefile:12:	docker compose logs -f django mt5 redis
mt5_gateway/supervisord.conf:7:[program:mt5_api]
mt5_gateway/supervisord.conf:8:command=/usr/local/bin/uvicorn mt5_gateway.app:app --host 0.0.0.0 --port 5001
mt5_gateway/supervisord.conf:13:stdout_logfile=/var/log/mt5_api.out.log
mt5_gateway/supervisord.conf:14:stderr_logfile=/var/log/mt5_api.err.log
pytest.ini:4:    mt5: tests requiring a real MT5 environment
config/alert_config.yaml:44:  market_close_summary: true
config/alert_config.yaml:48:  market_close_time: "21:00"
test_tick_flow.py:19:def test_mt5_connection():
test_tick_flow.py:137:    if not test_mt5_connection():
test_tick_flow.py:138:        print("\n⚠️  MT5 API is not accessible. Make sure the mt5 service is running.")
test_tick_flow.py:139:        print("Run: docker-compose up -d mt5")
test_tick_flow.py:176:    print("  docker-compose logs -f mt5 django redis celery")
_schema/GPT_Instructions_1.1.md:23:- Use the last bar’s `close` as the latest confirmed price for short summaries; otherwise show the time.
_schema/GPT_Instructions_1.1.md:27:- Flatten arrays: pair `timestamp[i]` with `open/high/low/close/volume[i]` from `indicators.quote[0]`.
_schema/GPT_Instructions_1.1.md:43:- Include instrument and timeframe of confirmation: "Last confirmed XAUUSD (M15 close): 2418.3 at 13:45Z".
_schema/GPT_Instructions_1.1.md:91:- Partial close {X}%
_schema/GPT_Instructions_1.1.md:95:User: "Just closed, lost $200"
_schema/GPT_Instructions_1.1.md:203:- Never fabricate market prices — always confirm from a feed or disclose uncertainty.
openapi.yaml:72:      summary: Profit Horizon data (last N closed trades)
openapi.yaml:99:                      prev_close: { type: number, nullable: true }
openapi.yaml:273:  /api/v1/orders/close:
openapi.yaml:309:  /api/v1/positions/close:
openapi.yaml:311:      summary: Close full or partial position (alias → orders/close)
openapi.yaml:580:                  equity_close: { type: number }
openapi.yaml:671:          schema: { type: string, enum: [db, mt5], nullable: true }
openapi.yaml:672:          description: Use `source=mt5` to return live MT5 deals (bypass DB)
mt5_gateway/app.py:7:    import MetaTrader5 as mt5
mt5_gateway/app.py:10:    mt5 = None
mt5_gateway/app.py:11:    _mt5_import_error = e
mt5_gateway/app.py:13:    _mt5_import_error = None
mt5_gateway/app.py:20:    if _mt5_import_error is not None:
mt5_gateway/app.py:21:        raise RuntimeError(f"Failed to import MetaTrader5: {_mt5_import_error}")
mt5_gateway/app.py:22:    if not mt5.initialize():
mt5_gateway/app.py:23:        raise RuntimeError(f"mt5.initialize() failed: {mt5.last_error()}")
mt5_gateway/app.py:31:            mt5.login(login=int(login), password=password, server=server)
mt5_gateway/app.py:40:        mt5.shutdown()
mt5_gateway/app.py:47:    return {"ok": True, "name": "mt5-gateway", "version": "1.0.0"}
mt5_gateway/app.py:58:    info = mt5.account_info()
mt5_gateway/app.py:60:        raise HTTPException(status_code=502, detail="mt5_account_info_none")
mt5_gateway/app.py:70:    pos = mt5.positions_get()
mt5_gateway/app.py:95:    pos = mt5.positions_get()
mt5_gateway/app.py:112:    si = mt5.symbol_info(symbol)
mt5_gateway/app.py:126:    # ORDER_TYPE_BUY / ORDER_TYPE_SELL
mt5_gateway/app.py:127:    return mt5.ORDER_TYPE_BUY if position_type == mt5.POSITION_TYPE_SELL else mt5.ORDER_TYPE_SELL
mt5_gateway/app.py:131:    tick = mt5.symbol_info_tick(symbol)
mt5_gateway/app.py:134:    price = tick.ask if side == mt5.ORDER_TYPE_BUY else tick.bid
mt5_gateway/app.py:136:        "action": mt5.TRADE_ACTION_DEAL,
mt5_gateway/app.py:142:        "type_time": mt5.ORDER_TIME_GTC,
mt5_gateway/app.py:143:        "type_filling": mt5.ORDER_FILLING_IOC,
mt5_gateway/app.py:148:    res = mt5.order_send(req)
mt5_gateway/app.py:163:@app.post("/partial_close_v2")
mt5_gateway/app.py:164:def partial_close_v2(body: PartialCloseV2):
mt5_gateway/app.py:182:                   comment=body.comment or f"partial_close_v2 ticket {body.ticket}",
mt5_gateway/app.py:196:@app.post("/partial_close")
mt5_gateway/app.py:197:def partial_close(body: PartialCloseLegacy):
mt5_gateway/app.py:211:                   comment=body.comment or f"partial_close ticket {body.ticket}",
mt5_gateway/app.py:222:@app.post("/close_position")
mt5_gateway/app.py:223:def close_position(body: ClosePayload):
mt5_gateway/app.py:231:                   comment=body.comment or f"close_position ticket {body.ticket}",
mt5_gateway/app.py:247:    side = mt5.ORDER_TYPE_BUY if body.type.upper() == "BUY" else mt5.ORDER_TYPE_SELL
core/pulse_kernel.py:2:    import MetaTrader5 as mt5  # type: ignore
core/pulse_kernel.py:4:    mt5 = None  # type: ignore
core/pulse_kernel.py:17:        self.mt5_connected = False
core/pulse_kernel.py:26:    def connect_mt5(self) -> bool:
core/pulse_kernel.py:28:        if mt5 is None:  # pragma: no cover - handled in tests
core/pulse_kernel.py:31:        if not mt5.initialize():
core/pulse_kernel.py:36:                if mt5.initialize():
core/pulse_kernel.py:40:        self.mt5_connected = True
core/pulse_kernel.py:45:        if mt5 is None:
core/pulse_kernel.py:48:        if not self.mt5_connected:
core/pulse_kernel.py:49:            self.connect_mt5()
core/pulse_kernel.py:51:        tick = mt5.symbol_info_tick(symbol)
core/pulse_kernel.py:55:        rates = mt5.copy_rates_from_pos(symbol, mt5.TIMEFRAME_M5, 0, 200)
core/pulse_kernel.py:111:        momentum = (df["close"] - df["open"]).mean()
core/pulse_kernel.py:119:        rsi_series = self._rsi(df["close"])
mt5_bridge_production.py:6:import MetaTrader5 as mt5
mt5_bridge_production.py:39:            if not mt5.initialize():
mt5_bridge_production.py:45:                if not mt5.login(self.account, password=self.password, server=self.server):
mt5_bridge_production.py:47:                    mt5.shutdown()
mt5_bridge_production.py:62:            mt5.shutdown()
mt5_bridge_production.py:78:        deals = mt5.history_deals_get(from_date, datetime.now())
mt5_bridge_production.py:91:        TRADE_TYPES = {mt5.DEAL_TYPE_BUY, mt5.DEAL_TYPE_SELL}
mt5_bridge_production.py:361:            if entry.get('type') == 'mt5_trade' and 'ticket' in entry.get('data', {})
mt5_bridge_production.py:376:                "type": "mt5_trade",
mt5_gateway/README.md:9:  - POST /partial_close_v2, POST /partial_close, POST /close_position
mt5_gateway/README.md:17:- docker-compose mounts this directory into the MT5 container at /opt/mt5_gateway (read-only).
mt5_gateway/README.md:22:1) Set environment variables for the mt5 service (e.g. in .env or the service environment block):
mt5_gateway/README.md:26:2) Recreate or restart the mt5 container:
mt5_gateway/README.md:27:   - docker compose up -d mt5
mt5_gateway/README.md:30:- backend/mt5/scripts/07-start-wine-flask.sh will:
mt5_gateway/README.md:32:  - if ENABLE_MT5_GATEWAY=1 and /opt/mt5_gateway/app.py exists, it will:
mt5_gateway/README.md:33:    - install /opt/mt5_gateway/requirements.txt into Wine Python (non-fatal if already satisfied)
mt5_gateway/README.md:34:    - start uvicorn for mt5_gateway on 0.0.0.0:${MT5_GATEWAY_PORT:-5002}
mt5_gateway/README.md:38:- Django and other services can target the gateway by setting MT5_URL or MT5_API_URL accordingly, e.g. http://mt5:5002 if you enable this module.
api/pulse.py:24:    close: float
pulse_ui_enhanced.py:10:from mt5_bridge import MT5Bridge
openapi.yf.yaml:65:                                      close:  { type: array, items: { type: number, nullable: true } }
README.md:17:- `backend/mt5`: Flask bridge to MetaTrader5 (send orders, partial close, hedge, scale)
README.md:62:    cp backend/mt5/.env.example backend/mt5/.env
README.md:65:2. **Edit your `.env` and `backend/mt5/.env` files** with all required API keys, passwords, and connection strings.
README.md:83:    docker-compose logs mt5
README.md:104:- `MT5_API_URL`: Base URL where the MT5 service is available (e.g., `http://mt5:5001`).
README.md:121:See [backend/mt5/app/routes/history.py](backend/mt5/app/routes/history.py) for details.
README.md:150:  - `POST /partial_close_v2` (fraction or absolute volume)
README.md:154:  - `POST /api/v1/orders/market | modify | close`
README.md:155:  - Friendly aliases: `POST /api/v1/positions/close | modify | hedge`
README.md:165:- Put verbs in body: `{ "type": "position_close", "payload": { ... } }`
README.md:175:- Diagnostics: `24_Trades_Diagnostics.py` shows closed trades (DB), MT5 history, and open positions.
README.md:259:MT5_API_URL=http://mt5-api:8050
docker-compose.yml:72:  mt5:
docker-compose.yml:74:      context: ./backend/mt5
docker-compose.yml:76:    container_name: mt5
docker-compose.yml:79:      - ./mt5_gateway:/opt/mt5_gateway:ro
docker-compose.yml:92:      # Router for vnc.mt5.${domain} (Port 3000)
docker-compose.yml:93:      traefik.http.routers.vnc-mt5-http.rule: Host(`${VNC_DOMAIN}`)
docker-compose.yml:94:      traefik.http.routers.vnc-mt5-http.entrypoints: http
docker-compose.yml:95:      traefik.http.routers.vnc-mt5-http.middlewares: https-redirect
docker-compose.yml:96:      traefik.http.routers.vnc-mt5-http.service: vnc-mt5-service
docker-compose.yml:98:      traefik.http.routers.vnc-mt5-https.rule: Host(`${VNC_DOMAIN}`)
docker-compose.yml:99:      traefik.http.routers.vnc-mt5-https.entrypoints: https
docker-compose.yml:100:      traefik.http.routers.vnc-mt5-https.tls: true
docker-compose.yml:101:      traefik.http.routers.vnc-mt5-https.tls.certresolver: le
docker-compose.yml:102:      traefik.http.routers.vnc-mt5-https.service: vnc-mt5-service
docker-compose.yml:104:      traefik.http.services.vnc-mt5-service.loadbalancer.server.port: 3000
docker-compose.yml:106:      # API routing moved to dedicated mt5-api service (to avoid conflicts)
docker-compose.yml:107:      x-traefik.disabled.api-mt5-http.rule: Host(`${API_DOMAIN}`)
docker-compose.yml:108:      x-traefik.disabled.api-mt5-http.entrypoints: http
docker-compose.yml:109:      x-traefik.disabled.api-mt5-http.middlewares: https-redirect
docker-compose.yml:110:      x-traefik.disabled.api-mt5-http.service: api-mt5-service
docker-compose.yml:112:      x-traefik.disabled.api-mt5-https.rule: Host(`${API_DOMAIN}`)
docker-compose.yml:113:      x-traefik.disabled.api-mt5-https.entrypoints: https
docker-compose.yml:114:      x-traefik.disabled.api-mt5-https.tls: true
docker-compose.yml:115:      x-traefik.disabled.api-mt5-https.tls.certresolver: le
docker-compose.yml:116:      x-traefik.disabled.api-mt5-https.service: api-mt5-service
docker-compose.yml:121:  mt5-api:
docker-compose.yml:123:    container_name: mt5-api
docker-compose.yml:126:      - ./backend/mt5_api:/app
docker-compose.yml:132:      - MT5_API_URL=http://mt5:5001
docker-compose.yml:133:      - MT5_URL=http://mt5:5001
docker-compose.yml:137:      - MT5_URL=http://mt5:5001
docker-compose.yml:146:      mt5:
docker-compose.yml:154:      traefik.http.routers.api-mt5-http.rule: Host(`${API_DOMAIN}`)
docker-compose.yml:155:      traefik.http.routers.api-mt5-http.entrypoints: http
docker-compose.yml:156:      traefik.http.routers.api-mt5-http.middlewares: https-redirect
docker-compose.yml:157:      traefik.http.routers.api-mt5-http.service: api-mt5-service
docker-compose.yml:159:      traefik.http.routers.api-mt5-https.rule: Host(`${API_DOMAIN}`)
docker-compose.yml:160:      traefik.http.routers.api-mt5-https.entrypoints: https
docker-compose.yml:161:      traefik.http.routers.api-mt5-https.tls: true
docker-compose.yml:162:      traefik.http.routers.api-mt5-https.tls.certresolver: le
docker-compose.yml:163:      traefik.http.routers.api-mt5-https.service: api-mt5-service
docker-compose.yml:165:      traefik.http.services.api-mt5-service.loadbalancer.server.port: 5001
docker-compose.yml:214:      - MT5_API_URL=http://mt5:5001
docker-compose.yml:268:      - MT5_API_URL=http://mt5:5001
docker-compose.yml:269:      - MT5_API_BASE=http://mt5:5001
docker-compose.yml:598:      - MT5_API_URL=http://mt5:5001
docker-compose.yml:599:      - MT5_URL=http://mt5:5001
docker-compose.yml:604:      mt5:
dashboard/pages/33_ 🎓 Wyckoff.py:231:        df['price_volatility'] = df['close'].rolling(20).std()
dashboard/pages/33_ 🎓 Wyckoff.py:233:        df['price_change'] = df['close'].pct_change()
dashboard/pages/33_ 🎓 Wyckoff.py:250:                    'price_level': window['close'].mean(),
dashboard/pages/33_ 🎓 Wyckoff.py:255:            elif (window['close'].iloc[-1] > window['close'].iloc[0] * 1.02 and
dashboard/pages/33_ 🎓 Wyckoff.py:262:                    'strength': (window['close'].iloc[-1] - window['close'].iloc[0]) / window['close'].iloc[0],
dashboard/pages/33_ 🎓 Wyckoff.py:263:                    'price_level': window['close'].mean(),
dashboard/pages/33_ 🎓 Wyckoff.py:277:                    'price_level': window['close'].mean(),
dashboard/pages/33_ 🎓 Wyckoff.py:289:        df['close_position'] = (df['close'] - df['low']) / df['price_range']
dashboard/pages/33_ 🎓 Wyckoff.py:294:                df.iloc[i]['close'] < df.iloc[i-1]['close'] and
dashboard/pages/33_ 🎓 Wyckoff.py:295:                df.iloc[i]['close_position'] < 0.3):
dashboard/pages/33_ 🎓 Wyckoff.py:300:                    'price': df.iloc[i]['close'],
dashboard/pages/33_ 🎓 Wyckoff.py:308:                  df.iloc[i]['close'] > df.iloc[i-1]['close'] and
dashboard/pages/33_ 🎓 Wyckoff.py:309:                  df.iloc[i]['close_position'] > 0.7):
dashboard/pages/33_ 🎓 Wyckoff.py:314:                    'price': df.iloc[i]['close'],
dashboard/pages/33_ 🎓 Wyckoff.py:322:                  df.iloc[i]['close'] > df.iloc[i-5:i]['close'].max() and
dashboard/pages/33_ 🎓 Wyckoff.py:328:                    'price': df.iloc[i]['close'],
dashboard/pages/33_ 🎓 Wyckoff.py:357:        # high volume, high close = strength
dashboard/pages/33_ 🎓 Wyckoff.py:358:        high_vol_high_close = (df['volume_norm'] > 1.0) & ((df['close'] - df['low']) / df['spread'] > 0.7)
dashboard/pages/33_ 🎓 Wyckoff.py:359:        conditions.append(('Strength', high_vol_high_close))
dashboard/pages/33_ 🎓 Wyckoff.py:378:        df['price_move'] = abs(df['close'] - df['open']) / df['open']
dashboard/pages/33_ 🎓 Wyckoff.py:491:        df['price_efficiency'] = abs(df['close'] - df['open']) / (df['high'] - df['low'])
dashboard/pages/33_ 🎓 Wyckoff.py:499:                abs(df.iloc[i]['close'] - df.iloc[i]['open']) / df.iloc[i]['open'] < 0.01):
dashboard/pages/33_ 🎓 Wyckoff.py:504:                df.iloc[i]['close'] < df.iloc[i]['high'] * 0.95 and
dashboard/pages/33_ 🎓 Wyckoff.py:523:        price_trend = recent_data['close'].iloc[-1] / recent_data['close'].iloc[0]
dashboard/pages/33_ 🎓 Wyckoff.py:568:            close=df['close'],
dashboard/pages/33_ 🎓 Wyckoff.py:654:    volume_colors = ['red' if close < open_price else 'green'
dashboard/pages/33_ 🎓 Wyckoff.py:655:                    for close, open_price in zip(df['close'], df['open'])]
dashboard/pages/33_ 🎓 Wyckoff.py:696:                signal_prices = [df['close'].iloc[i] for i in indices if i < len(df)]
dashboard/pages/33_ 🎓 Wyckoff.py:1041:                current_price = df['close'].iloc[-1]
dashboard/pages/33_ 🎓 Wyckoff.py:1042:                price_change = ((df['close'].iloc[-1] - df['close'].iloc[0]) / df['close'].iloc[0]) * 100
app/main.py:54:    type: str = Field(..., examples=["mt5_trade", "analysis", "note"])
tools/verify_ingestion.py:13:        from mt5_bridge_production import MT5Bridge
tools/verify_ingestion.py:40:def verify_mt5_and_history(days_back=7):
tools/verify_ingestion.py:76:        mt5_entries = [e for e in journal if e.get("type") == "mt5_trade"]
tools/verify_ingestion.py:77:        _assert(len(mt5_entries) > 0, "No mt5_trade entries found in journal")
tools/verify_ingestion.py:78:        flags = mt5_entries[-1]["data"]["behavioral_flags"]
tools/verify_ingestion.py:131:        ("MT5 & history", verify_mt5_and_history),
app.py:1:from backend.mt5.app.app import app
services/pyrest/app.py:79:    KERNEL.connect_mt5()
dashboard/Home.py:26:from api_integration.mt5_api_client import Mt5APIClient
dashboard/Home.py:177:    bars["ret"] = bars["close"].pct_change()
dashboard/Home.py:179:    ma = bars["close"].rolling(win).mean()
dashboard/Home.py:180:    sd = bars["close"].rolling(win).std()
dashboard/Home.py:187:    bars["bb_pctB"] = _nz((bars["close"] - lower) / (upper - lower + 1e-6))
dashboard/Home.py:308:        self.mt5_client = Mt5APIClient(base_url=self.api_url)
dashboard/Home.py:328:        df = self.mt5_client.get_bars(symbol, interval, limit)
dashboard/Home.py:333:        return self.mt5_client.get_ticks(symbol, limit)
dashboard/Home.py:446:        self.display_live_mt5()
dashboard/Home.py:644:                        close=df_recent["close"],
dashboard/Home.py:668:                    vwap_prices = (df_recent['high'] + df_recent['low'] + df_recent['close']) / 3
dashboard/Home.py:679:                    close = df_recent['close'].values
dashboard/Home.py:681:                    for i in range(len(close) - window):
dashboard/Home.py:682:                        win = close[i:i+window]
dashboard/Home.py:717:                                y_mid = df_recent['close'].iloc[-1]
dashboard/Home.py:778:                required_cols = {"timestamp", "open", "high", "low", "close", "volume"}
dashboard/Home.py:791:                        close=df_recent["close"],
dashboard/Home.py:813:                    vwap_prices = (df_recent['high'] + df_recent['low'] + df_recent['close']) / 3
dashboard/Home.py:822:                    close = df_recent['close'].values
dashboard/Home.py:823:                    for i in range(len(close) - window):
dashboard/Home.py:824:                        win = close[i:i+window]
dashboard/Home.py:853:                                y_mid = df_recent['close'].iloc[-1]
dashboard/Home.py:909:            required_cols = {"timestamp", "open", "high", "low", "close", "volume"}
dashboard/Home.py:923:                        close=df_recent["close"],
dashboard/Home.py:945:                    vwap_prices = (df_recent['high'] + df_recent['low'] + df_recent['close']) / 3
dashboard/Home.py:954:                    close = df_recent['close'].values
dashboard/Home.py:955:                    for i in range(len(close) - window):
dashboard/Home.py:956:                        win = close[i:i+window]
dashboard/Home.py:985:                                y_mid = df_recent['close'].iloc[-1]
dashboard/Home.py:1048:            if {"timestamp", "close"}.issubset(df_3d.columns):
dashboard/Home.py:1052:                y_vals = df_3d_recent["close"]
dashboard/Home.py:1053:                z_vals = np.abs(df_3d_recent["close"].diff().fillna(0))
dashboard/Home.py:1085:                st.info("XAUUSD 15min data missing 'timestamp' or 'close' column for 3D FVG/SMC chart.")
dashboard/Home.py:1089:    def display_live_mt5(self):
dashboard/Home.py:1115:            col1.metric("Close", enriched["close"].iloc[-1])
dashboard/Home.py:1127:                    close=enriched["close"],
dashboard/Home.py:1167:            if not {"timestamp", "close", "volume"}.issubset(df.columns):
dashboard/Home.py:1172:            df.dropna(subset=["timestamp", "close", "volume"], inplace=True)
dashboard/Home.py:1175:            df["price_bin"] = pd.cut(df["close"], bins=50, labels=False)
dashboard/Home.py:1446:            if {"timestamp", "close"}.issubset(df.columns):
dashboard/Home.py:1452:                    y=df_recent["close"],
dashboard/pages/17_risk_manager_mock.py:74:        self._mt5_bases = [
dashboard/pages/17_risk_manager_mock.py:77:            "http://mt5:5001",
dashboard/pages/17_risk_manager_mock.py:79:        self.mt5_url = next((u for u in self._mt5_bases if u), "http://mt5:5001")
dashboard/pages/17_risk_manager_mock.py:91:    def get_mt5_data(self, endpoint: str) -> Optional[Dict]:
dashboard/pages/17_risk_manager_mock.py:93:        for base in [u for u in self._mt5_bases if u]:
dashboard/pages/17_risk_manager_mock.py:110:        mt5_data = self.get_mt5_data("account_info")
dashboard/pages/17_risk_manager_mock.py:111:        if mt5_data:
dashboard/pages/17_risk_manager_mock.py:112:            return mt5_data
dashboard/pages/17_risk_manager_mock.py:130:        tick_data = self.get_mt5_data(f"symbol_info_tick/{symbol}")
dashboard/pages/17_risk_manager_mock.py:146:        positions_data = self.get_mt5_data("positions_get")
dashboard/pages/17_risk_manager_mock.py:190:            data = self.get_mt5_data(ep)
dashboard/pages/17_risk_manager_mock.py:194:                time_cols = [c for c in ["time", "time_msc", "time_done", "time_close"] if c in df.columns]
tree.md:29:mt5
tree.md:79:close
tree.md:82:./backend/django/app/quant/algorithms/close:
tree.md:83:close.py
tree.md:120:close.py
tree.md:125:./backend/mt5:
tree.md:132:./backend/mt5/app:
tree.md:141:./backend/mt5/app/routes:
tree.md:150:./backend/mt5/app/tests:
tree.md:153:./backend/mt5/root:
tree.md:156:./backend/mt5/root/defaults:
tree.md:160:./backend/mt5/scripts:
tree.md:164:04-install-mt5.sh
tree.md:227:dashboard_mt5.py
tree.md:334:Dockerfile.mt5
tree.md:340:mt5_redis_integration.py
tree.md:343:run_mt5_integration.py
app/wiring/pulse_runtime.py:5:from mt5_bridge_production import MT5Bridge              # ← from your file
app/wiring/pulse_runtime.py:14:        self.mt5 = MT5Bridge(
app/wiring/pulse_runtime.py:22:    def connect_mt5(self) -> bool:
app/wiring/pulse_runtime.py:25:        self.connected = self.mt5.connect()
app/wiring/pulse_runtime.py:30:        if not self.connect_mt5():
app/wiring/pulse_runtime.py:32:        return self.mt5.get_real_trade_history(days_back=days_back)
app/wiring/pulse_runtime.py:35:        if not self.connect_mt5():
app/wiring/pulse_runtime.py:37:        return self.mt5.get_behavioral_report()
app/wiring/pulse_runtime.py:40:        if not self.connect_mt5():
app/wiring/pulse_runtime.py:42:        return self.mt5.generate_weekly_review()
app/wiring/pulse_runtime.py:45:        if not self.connect_mt5():
app/wiring/pulse_runtime.py:47:        return self.mt5.get_confluence_validation(journal_path=JOURNAL_PATH)
app/wiring/pulse_runtime.py:76:        if not self.connect_mt5():
app/wiring/pulse_runtime.py:78:        return self.mt5.sync_to_pulse_journal(journal_path=JOURNAL_PATH)
docker-compose.override.yml.bak:19:      - mt5
docker-compose copy.yml_old:72:  mt5:
docker-compose copy.yml_old:74:      context: backend/mt5
docker-compose copy.yml_old:76:    container_name: mt5
docker-compose copy.yml_old:91:      # Router for vnc.mt5.${domain} (Port 3000)
docker-compose copy.yml_old:92:      traefik.http.routers.vnc-mt5-http.rule: Host(`${VNC_DOMAIN}`)
docker-compose copy.yml_old:93:      traefik.http.routers.vnc-mt5-http.entrypoints: http
docker-compose copy.yml_old:94:      traefik.http.routers.vnc-mt5-http.middlewares: https-redirect
docker-compose copy.yml_old:96:      traefik.http.routers.vnc-mt5-https.rule: Host(`${VNC_DOMAIN}`)
docker-compose copy.yml_old:97:      traefik.http.routers.vnc-mt5-https.entrypoints: https
docker-compose copy.yml_old:98:      traefik.http.routers.vnc-mt5-https.tls: true
docker-compose copy.yml_old:99:      traefik.http.routers.vnc-mt5-https.tls.certresolver: le
docker-compose copy.yml_old:100:      traefik.http.routers.vnc-mt5-https.service: vnc-mt5-service
docker-compose copy.yml_old:102:      traefik.http.services.vnc-mt5-service.loadbalancer.server.port: 3000
docker-compose copy.yml_old:104:      # Router for api.mt5.${domain} (Port 5001)
docker-compose copy.yml_old:105:      traefik.http.routers.api-mt5-http.rule: Host(`${API_DOMAIN}`)
docker-compose copy.yml_old:106:      traefik.http.routers.api-mt5-http.entrypoints: http
docker-compose copy.yml_old:107:      traefik.http.routers.api-mt5-http.middlewares: https-redirect
docker-compose copy.yml_old:109:      traefik.http.routers.api-mt5-https.rule: Host(`${API_DOMAIN}`)
docker-compose copy.yml_old:110:      traefik.http.routers.api-mt5-https.entrypoints: https
docker-compose copy.yml_old:111:      traefik.http.routers.api-mt5-https.tls: true
docker-compose copy.yml_old:112:      traefik.http.routers.api-mt5-https.tls.certresolver: le
docker-compose copy.yml_old:113:      traefik.http.routers.api-mt5-https.service: api-mt5-service
docker-compose copy.yml_old:115:      traefik.http.services.api-mt5-service.loadbalancer.server.port: 5001
docker-compose copy.yml_old:448:      - mt5
docker-compose copy.yml_old:451:      - mt5
services/docker-compose.yml:72:  mt5:
services/docker-compose.yml:74:      context: ./backend/mt5
services/docker-compose.yml:76:    container_name: mt5
services/docker-compose.yml:91:      # Router for vnc.mt5.${domain} (Port 3000)
services/docker-compose.yml:92:      traefik.http.routers.vnc-mt5-http.rule: Host(`${VNC_DOMAIN}`)
services/docker-compose.yml:93:      traefik.http.routers.vnc-mt5-http.entrypoints: http
services/docker-compose.yml:94:      traefik.http.routers.vnc-mt5-http.middlewares: https-redirect
services/docker-compose.yml:95:      traefik.http.routers.vnc-mt5-http.service: vnc-mt5-service
services/docker-compose.yml:97:      traefik.http.routers.vnc-mt5-https.rule: Host(`${VNC_DOMAIN}`)
services/docker-compose.yml:98:      traefik.http.routers.vnc-mt5-https.entrypoints: https
services/docker-compose.yml:99:      traefik.http.routers.vnc-mt5-https.tls: true
services/docker-compose.yml:100:      traefik.http.routers.vnc-mt5-https.tls.certresolver: le
services/docker-compose.yml:101:      traefik.http.routers.vnc-mt5-https.service: vnc-mt5-service
services/docker-compose.yml:103:      traefik.http.services.vnc-mt5-service.loadbalancer.server.port: 3000
services/docker-compose.yml:105:      # Router for api.mt5.${domain} (Port 5001)
services/docker-compose.yml:106:      x-traefik.disabled.api-mt5-http.rule: Host(`${API_DOMAIN}`)
services/docker-compose.yml:107:      x-traefik.disabled.api-mt5-http.entrypoints: http
services/docker-compose.yml:108:      x-traefik.disabled.api-mt5-http.middlewares: https-redirect
services/docker-compose.yml:109:      x-traefik.disabled.api-mt5-http.service: api-mt5-service
services/docker-compose.yml:111:      x-traefik.disabled.api-mt5-https.rule: Host(`${API_DOMAIN}`)
services/docker-compose.yml:112:      x-traefik.disabled.api-mt5-https.entrypoints: https
services/docker-compose.yml:113:      x-traefik.disabled.api-mt5-https.tls: true
services/docker-compose.yml:114:      x-traefik.disabled.api-mt5-https.tls.certresolver: le
services/docker-compose.yml:115:      x-traefik.disabled.api-mt5-https.service: api-mt5-service
services/docker-compose.yml:117:      # API routing moved to dedicated mt5-api service
services/docker-compose.yml:118:      x-traefik.disabled.api-mt5-service.loadbalancer.server.port: 8000
services/docker-compose.yml:123:  mt5-api:
services/docker-compose.yml:125:    container_name: mt5-api
services/docker-compose.yml:128:      - ./backend/mt5_api:/app
services/docker-compose.yml:142:      traefik.http.routers.api-mt5-http.rule: Host(`${API_DOMAIN}`)
services/docker-compose.yml:143:      traefik.http.routers.api-mt5-http.entrypoints: http
services/docker-compose.yml:144:      traefik.http.routers.api-mt5-http.middlewares: https-redirect
services/docker-compose.yml:145:      traefik.http.routers.api-mt5-http.service: api-mt5-service
services/docker-compose.yml:147:      traefik.http.routers.api-mt5-https.rule: Host(`${API_DOMAIN}`)
services/docker-compose.yml:148:      traefik.http.routers.api-mt5-https.entrypoints: https
services/docker-compose.yml:149:      traefik.http.routers.api-mt5-https.tls: true
services/docker-compose.yml:150:      traefik.http.routers.api-mt5-https.tls.certresolver: le
services/docker-compose.yml:151:      traefik.http.routers.api-mt5-https.service: api-mt5-service
services/docker-compose.yml:153:      traefik.http.services.api-mt5-service.loadbalancer.server.port: 5001
services/docker-compose.yml:202:      - MT5_API_URL=http://mt5:5001
services/docker-compose.yml:256:      - MT5_API_URL=http://mt5:5001
services/docker-compose.yml:257:      - MT5_API_BASE=http://mt5:5001
services/docker-compose.yml:560:      - MT5_API_URL=http://mt5:5001
services/docker-compose.yml:562:      mt5:
utils/sync_mt5_trades.py:4:- Fetches live MT5 closed trades via Actions Bus (read-only) and stores them to CSV for later ingestion.
utils/sync_mt5_trades.py:28:def fetch_mt5_trades(date_from: str) -> List[Dict[str, Any]]:
utils/sync_mt5_trades.py:29:    """Fetch closed trades from MT5 via Actions Bus."""
utils/sync_mt5_trades.py:33:        json={"type": "trades_history_mt5", "payload": {"date_from": date_from}},
utils/sync_mt5_trades.py:48:    path = os.path.join(OUT_DIR, f"mt5_trades_{ts}.csv")
utils/sync_mt5_trades.py:61:    items = fetch_mt5_trades(start)
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:133:        return pd.DataFrame(columns=["open","high","low","close","volume"])
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:141:            SELECT ts, open, high, low, close, COALESCE(volume,0) AS volume
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:154:        return pd.DataFrame(columns=["open","high","low","close","volume"])
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:230:        res.columns = ["open", "high", "low", "close"]
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:245:    Expected columns: open, high, low, close, volume with DateTimeIndex.
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:251:            return pd.DataFrame(columns=["open","high","low","close","volume"])
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:255:        return df[["open","high","low","close","volume"]].dropna()
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:257:        return pd.DataFrame(columns=["open","high","low","close","volume"])
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:788:            current_price = df['close'].iloc[-1]
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:799:            sma_20 = df['close'].rolling(20).mean().iloc[-1]
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:800:            sma_50 = df['close'].rolling(50).mean().iloc[-1] if len(df) >= 50 else sma_20
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:825:                current_bar['close'] > recent_low and
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:833:                    'rejection_strength': (current_bar['close'] - current_bar['low']) / (current_bar['high'] - current_bar['low']),
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:839:                  current_bar['close'] < recent_high and
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:847:                    'rejection_strength': (current_bar['high'] - current_bar['close']) / (current_bar['high'] - current_bar['low']),
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:865:                current_close = df['close'].iloc[i]
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:868:                if (current_close > swing_high and
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:869:                    df['close'].iloc[i-1] <= swing_high):
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:875:                        'displacement': current_close - swing_high,
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:876:                        'strength': 'high' if abs(current_close - swing_high) > df['close'].std() else 'medium'
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:880:                elif (current_close < swing_low and
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:881:                      df['close'].iloc[i-1] >= swing_low):
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:887:                        'displacement': swing_low - current_close,
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:888:                        'strength': 'high' if abs(swing_low - current_close) > df['close'].std() else 'medium'
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:902:                if gap_size > 0.001 * df['close'].iloc[i]:  # Minimum gap threshold
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:915:                if gap_size > 0.001 * df['close'].iloc[i]:
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:928:            if (df['close'].iloc[i] < df['open'].iloc[i] and  # Down candle
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:929:                df['close'].iloc[i+1] > df['open'].iloc[i+1] and  # Next candle up
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:930:                df['close'].iloc[i+1] > df['high'].iloc[i]):  # Strong move up
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:941:            elif (df['close'].iloc[i] > df['open'].iloc[i] and  # Up candle
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:942:                  df['close'].iloc[i+1] < df['open'].iloc[i+1] and  # Next candle down
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:943:                  df['close'].iloc[i+1] < df['low'].iloc[i]):  # Strong move down
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:988:            latest_price = df['close'].iloc[-1]
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:1060:        df['price_volatility'] = df['close'].rolling(20).std()
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:1068:            trend_strength = abs(window['close'].iloc[-1] - window['close'].iloc[0]) / price_range if price_range > 0 else 0
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:1080:                    'price_level': window['close'].mean(),
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:1086:                  window['close'].iloc[-1] > window['close'].iloc[0] * 1.02 and
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:1093:                    'price_level': window['close'].mean(),
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:1112:                df['close'].iloc[i] > df['low'].iloc[i]):
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:1125:                  abs(df['low'].iloc[i] - df['low'].iloc[i-5:i].min()) < df['close'].std() * 0.5 and
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:1171:            latest_price = df['close'].iloc[-1]
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:1242:            ranges['current_price'] = df['close'].iloc[-1]
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:1267:                current_bar['close'] < asian_high and
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:1276:                    'rejection_strength': (asian_high - current_bar['close']) / (current_bar['high'] - current_bar['low']),
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:1282:                  current_bar['close'] > asian_low and
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:1291:                    'rejection_strength': (current_bar['close'] - asian_low) / (current_bar['high'] - current_bar['low']),
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:1306:                current_close = df['close'].iloc[j]
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:1310:                    if current_close < sweep['level'] * 0.995:  # 0.5% below swept level
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:1315:                            'reversal_strength': (sweep['level'] - current_close) / sweep['level'],
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:1322:                    if current_close > sweep['level'] * 1.005:  # 0.5% above swept level
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:1327:                            'reversal_strength': (current_close - sweep['level']) / sweep['level'],
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:1363:            latest_price = df['close'].iloc[-1]
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:1436:            'current_price': df['close'].iloc[-1],
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:1437:            'volatility': df['close'].rolling(20).std().iloc[-1],
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:1445:            sma_20 = df['close'].rolling(20).mean().iloc[-1]
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:1446:            sma_50 = df['close'].rolling(50).mean().iloc[-1]
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:1522:            close=df['close'],
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:1534:        sma_20 = df['close'].rolling(20).mean()
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:1545:        sma_50 = df['close'].rolling(50).mean()
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:1585:        colors = ['#2c5530' if close >= open_price else '#8B0000'
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:1586:                 for close, open_price in zip(df['close'], df['open'])]
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:1990:    current_price = latest['close']
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:1993:        price_change = current_price - current_df.iloc[-2]['close']
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:1994:        price_change_pct = (price_change / current_df.iloc[-2]['close']) * 100
dashboard/pages/07_ ZANFLOW v12 Strategy Dashboard.py:2204:                                <div>Price: ${df_tf.iloc[-1]['close']:.2f}</div>
knowledge/zan_flow_3.txt:1:Ever looked at a trading chart and just felt lost? Yeah. Like you're trying to find some logic in all that noise. I think a lot of people feel that. Oh, absolutely. It can definitely look like chaos sometimes. Yeah. So today we're trying to cut through that. We're doing a deep dive into a really structured way to find hopefully high probability trading setups. Right. Think of it like we're designing an algorithm almost. We want to break down this specific trading strategy really methodically. almost like writing out pseudocode or drawing a UML diagram for it. Very logical, step by step. Exactly. Making it super clear, super logical. And we've pulled together some interesting material for this. We're looking at stuff from algorithmic trading flows, you know, how the machines think, and these detailed strategy playbooks, plus some core ideas from the classic Richard Wyckoff. Yeah, blending the old and the new. It's a good mix. It is. So the main focus is nailing these high probability entries. We'll use multi-time frame analysis for the big picture, understand liquidity, and then zoom right in on these M1 fair value gaps or FEGs for the precise entry. Sound good? Sounds perfect. Yeah. Let's get into it. The first piece, the foundation really, is that multi-time frame analysis, MTFA. Right. The big picture first. Exactly. This is about figuring out the why and the where. Why might price move? And where is it likely to go or react? So we don't just stare at the one minute chart. No, you go, Matt. You really would. We start higher up. Think, ah, four hour charts, maybe the one hour. H4, H1. Okay, so looking at the forest before the trees, what are we looking for there? We're basically trying to figure out the main trend, the bias. Are we seeing higher highs and higher lows? That's just, you know, a bullish trend. Right? Or are we seeing lower highs and lower lows? That points towards a bearish downward feeling in the market. That gives us our main direction to work with. So establish the overall flow first. Got it. Precisely. Then once we have that bias, say we're bullish on the H4, we look for specific zones on that same higher timeframe. We call them higher timeframe points of interest or HTF POIs. POIs. Okay. What qualifies as a POI? These are significant areas, often things like fair value gaps that haven't been filled yet on that higher timeframe maybe order blocks, basically places where price made a big move away from and hasn't really come back to test properly, key potential reaction zones. And these POIs, they have to match the trend we just identified. Yes, that's crucial. It's a key filter. If our higher timeframe bias is bullish, we're interested in POIs down in discount areas, relatively cheaper prices compared to the recent move up. Buying low in an uptrend, essentially. Kind of, yeah. And if the bias is bearish, we look for POIs up in premium zones, relatively expensive areas. It keeps us aligned with that larger flow. Okay, that makes sense. Don't fight the current. Exactly. And here's the rule, really. We don't even think about looking for our M1 FPG entry, that micro level signal, until price has actually reached and reacted to one of these valid HTF POIs that lines up with our bias. Right. So HTF context first, then price needs to arrive at that key HTF level. Only then do we start looking closer. Precisely. It's a top-down process, ensures we're playing in the high probability sandbox, so to speak. Okay, sandbox established. Price is now at our HTF POI. What's the next logical step in the framework? Now we zoom into the details a bit more and bring in liquidity concepts. This is about understanding the fuel for moves and spotting potential traps. Liquidity, always important. Crucial. So specifically, as price gets near or just enters that HTF POI we identified, We switch focus to the M1 chart, the one minute, and we look for something called a liquidity sweep. A sweep or a stop hunt, right? People call it that too. Exactly, a stop hunt. What it looks like is a quick, sharp spike in price past a recent M1 high or low. Poking through briefly. Yeah, just a quick jab. The idea is it's designed to trigger stop-loss orders that traders have placed just beyond those obvious M1 levels. It sort of scoops up that liquidity. Grabs the order sitting there. Why is that important for our strategy? Because fair value gaps, those M1 FEGs, were ultimately one of these liquidity sweeps. They tend to be much more reliable. The sweep has, in theory, cleared out the opposing orders. Ah, okay. So the path is clearer for price to move in the directions suggested by the HTFPOI because the sweep took out the immediate resistance or support in the form of stops. That's the logic, yes. It increases the probability that the FEG will hold and price will move from there. You mentioned inducement as well. How does that fit in? Is it related? It's definitely related. Inducement is price action that looks like it's starting a move, maybe a little pullback or break on the M1 before the real sweep happens. It tempts traders to jump in early. Only to get stopped out by the sweep that follows. Often, yes. It induces participation, creating more liquidity for the sweep to target. Spotting inducement can help you wait for the actual sweep and avoid getting caught. Okay, so wait for the potential sweep after price hits the HTF POI. What confirms the move after the sweep? Now we need confirmation on the M1 structure itself. So we've got the HTF POI interaction. We might have seen the M1 sweep. Now we need a clear signal that the M1 trend is actually shifting to align with our HTF bias. A final trigger, sort of. Exactly. And we look for two main things here, a change of character, or CHCH, and a break of structure, or BOAS. These are M1 signals. Great. CH-A-C-H and BO-S. Heard those terms a lot. Break them down for us. Okay. A change of character, the CH-O-C-H, is usually the first sign. It's an impulsive, strong move on the M1 that breaks the immediate M1 countertrend structure. So if price was pulling back down towards a bullish HTF POI, the CH-O-C-H would be a strong M1 move up that breaks the last M1 lower high. It suggests the M1 tide might be turning. The first real hint of a reversal on the small scale. Correct. Now, a break of structure, the BOCAS, is also an impulsive M1 move, but it happens when the M1 trend is already moving in the direction of our HTF bias. A BOCAS confirms continuation. So if we're bullish HTF and the M1 is already making higher highs and lows after the POI interaction, a BOCAS would be breaking the most recent M1 high. Reinforcing the current M1 move that's aligned with the HTF. Precisely. So CHCH suggests a change is starting. BOCAS confirms it's continuing. And both need to be strong moves, not just little wiggles. Absolutely critical. We need to see clear displacement, a strong momentum, a decisive move. That tells us there's real intent behind it on the M1 timeframe. Okay. HTFPOI, check. Liquidity sweep, ideally check. M1CHCH or BOCUS confirming the direction, check. Now, where does the M1 fair value gap actually come into play for the entry? Right. The specific M1 FEG we use for entry is the one that gets created by that impulsive M1 move, the CHOCH or the BOCUS that happened after the sweep and the HTF POI interaction. So the strong move leaves behind an FEG. Often, yes. That impulsive move creates an imbalance, a gap between candle wicks. That FEG is our target zone for entry because it was formed by the very move that confirmed our structural alignment across timeframes. It's a footprint of that confirmation. A footprint of the confirmation. I like that. How do we actually place the trade then? Enter right away. Usually not. We wait for price to retrace to pull back into that validated M1 FEG. We're looking for it to revisit that little zone of inefficiency. And where in the FEG do you enter? The edge, middle? That can vary. Some traders look for the edge. Some prefer the 50% level of the FEG. Sometimes other confluence might guide it. The key point is entering within that specific FEG created by the confirming M1 structure shift. Okay. Entry planned. Now, the really crucial part, WISC management, stop loss. How do we set that persuasively? Not just a random number of pips, right? Absolutely not. It's structurally defined. The stop loss goes just beyond the M1 swing point that created the FEG and the CHOS or BOTOS. Explain that a bit more. Okay. So if we're going long, bullish, the impulsive move up, the CH, CH or BORS, started from an M1 swing low. Our stop loss goes a few pips below that swing low. Below the low that launched the move. Exactly. If we're going short, bearish, the impulsive move down started from an M1 swing high. The stop loss goes a few pips above that swing high. That swing point is the structural invalidation level for this specific M1 setup. Ah, I see. If price goes back beyond that point, the whole reason for the entry, that specific M1 structural move, is broken. Precisely. The setup failed structurally. And it's usually smart to add a small buffer, you know, a few extra pips, especially on volatile pairs like gold, just to account for noise or spread. But don't put the stop inside the FEG or right at the swing point. Give it that structural breathing room. Protect the structure. Makes total sense. And take profit targets. We're aiming. Targets are usually set based on liquidity again. Look for the nearest M1 or maybe M5 swing highs or lows that haven't been taken out yet. Or look for other HTF objectives like the next opposing FEG or major swing point on a higher time frame. You want clear areas where price might be drawn. And think about risk-reward too, presumably. Definitely. You calculate the distance to your structurally placed stop, then look at potential targets. Are you getting at least, say, 1.2 risk-to-reward? Preferably more. If not, maybe the trade isn't worth taking, even if the setup looks okay. Some traders also take partial profits at the first logical target to lock something in. Right. Manage the trade as it develops. This whole process, it feels very logical, step by step, almost like coding, as you said earlier. That's exactly the goal, a clear, repeatable, logical sequence. And interestingly, even though we're using modern concepts like FEGs, the underlying logic connects back strongly to Richard Wyckoff's work from way back. Wyckoff, yeah, you mentioned him. How does this M1 FEG stuff connect to his ideas about accumulation, distribution, supply and demand? Well, Wyckoff was all about reading the market through price action and volume to see where supply and demand were out of balance. Our MTFA helps identify those larger potential accumulation or distribution zones he talked about. And those M1 liquidity sweeps we look for. You can think of them as potentially being modern versions of Whatcoff's springs or upthrusts. You know, those false moves below support or above resistance designed to shake traders out before the real move begins. Ah, the shakeouts. So they serve a purpose in his framework, too. A very clear purpose-testing supplier demand and trapping incorrectly positioned traders. Plus, Weckoff was adamant about trading with the dominant trend. Our whole emphasis on establishing the HTF bias first, that's pure Weckoff. He warned against just blindly buying dips or selling rips without understanding the larger context. Which is exactly what this framework tries to enforce. Context first, then the signal. Precisely. He also stressed studying individual assets, their character. While our framework is the blueprint, knowing the specific behavior of, say, UURSD versus gold might nuance how you apply it slightly, but the core logic holds. That's fascinating, seeing how these precise, almost algorithmic M1 techniques echo those century-old market principles. It shows that understanding market structure and liquidity is timeless, really. The tools evolve, but the underlying dynamics often remain similar. Okay, so let's recap the key steps for everyone listening. It's a sequence, a logical flow. Right. Step one, multi-time frame analysis. Use H4, H1 to find your directional bias, bullish or bearish, and identify key HTF points of interest in discount or premium. Step two, wait for price to reach that HTF POI. Then watch the M1 chart for a potential liquidity sweep that Stop Hunt passed a recent M1 high or low. Step three, look for M1 structure confirmation after the POI interaction and sweep. That means a clear impulsive change of character, CHTH, or break of structure, this is P. Digmas, showing the M1 is aligning with the HTF bias. Step 4. Identify the M1 fair value gap, FEG, created by that confirming CH or bias move. Step 5. Plan entry on a retracement back into that specific M1 FEG. And critically, Step 6. Place your stop loss structurally, just beyond the M1 swing high or low that initiated the confirming move, CHBHE, adding a small buffer. Targets are liquidity zones offering good risk reward. That's the framework. It's designed to filter out a lot of market noise and focus on points where multiple factors align, increasing the probability of the setup working out. It demands patience, waiting for that confluence. Waiting for all the pieces of the puzzle to fit. So a final thought for you, our listener. Think about your current analysis. How could you start layering these ideas? Maybe begin by just identifying the HTF bias and POIs, then perhaps start watching for those M1 sweeps and structural shifts around them. How might this structured thinking change the way you see the charts? Yeah, maybe even explore Wyckoff's original work, too. There's so much depth there that still applies today. It's all about building that robust, logical framework for yourself.
mt5_bridge.py:9:import MetaTrader5 as mt5
mt5_bridge.py:35:        if not mt5.initialize():
mt5_bridge.py:40:            authorized = mt5.login(self.account, password=self.password, server=self.server)
mt5_bridge.py:43:                mt5.shutdown()
mt5_bridge.py:55:        deals = mt5.history_deals_get(from_date, datetime.now())
mt5_bridge.py:67:        TRADE_TYPES = {mt5.DEAL_TYPE_BUY, mt5.DEAL_TYPE_SELL}
mt5_bridge.py:226:                "type": "mt5_trade",
mt5_bridge.py:344:            mt5.shutdown()
backtesting/backtest_engine.py:69:        self._close_all_positions(data.iloc[-1], data.index[-1])
backtesting/backtest_engine.py:78:        current_price = market_data['close']
backtesting/backtest_engine.py:84:            self._close_position(symbol, current_price, timestamp)
backtesting/backtest_engine.py:99:    def _close_position(self, symbol: str, price: float, timestamp: datetime):
backtesting/backtest_engine.py:117:    def _close_all_positions(self, market_data: pd.Series, timestamp: datetime):
backtesting/backtest_engine.py:119:            self._close_position(symbol, market_data['close'], timestamp)
backtesting/backtest_engine.py:124:            current_price = market_data['close']
backtesting/backtest_engine.py:214:    short_ma = data['close'].rolling(10).mean().iloc[-1]
backtesting/backtest_engine.py:215:    long_ma = data['close'].rolling(30).mean().iloc[-1]
actions/OPENAI_ACTIONS.yaml:14:            - trades_history_mt5
actions/OPENAI_ACTIONS.yaml:58:            - trades_history_mt5
actions/OPENAI_ACTIONS.yaml:101:            - position_close
actions/OPENAI_ACTIONS.yaml:107:            - trades_history_mt5
actions/OPENAI_ACTIONS.yaml:129:  - name: position_close
actions/OPENAI_ACTIONS.yaml:131:    endpoint: /api/v1/positions/close
actions/OPENAI_ACTIONS.yaml:138:          description: Trade ticket ID to close
actions/OPENAI_ACTIONS.yaml:143:          description: Optional fraction of position volume to close (default full close)
actions/OPENAI_ACTIONS.yaml:146:          description: Optional absolute lots to close (overrides fraction if provided)
pulse_kernel.py:320:            decision['reasons'].append('Medium confluence - monitor closely')
pulse_kernel.py:360:    def flush_and_close(self) -> None:
pulse_kernel.py:363:        self.kafka_producer.close()
docs/JOURNALING.md:5:- Persist structured records for entries, closes, partials, hedges, and SL/TP modifications.
docs/JOURNALING.md:32:  "tags": ["position_close", "risk_action", "partial"],
dashboard/pages/03_ 📰 MACRO & NEWS.py:130:            prev_close = risk.get('prev_close_equity')
dashboard/pages/03_ 📰 MACRO & NEWS.py:132:                prev_close = float(prev_close) if prev_close is not None else None
dashboard/pages/03_ 📰 MACRO & NEWS.py:134:                prev_close = None
dashboard/pages/03_ 📰 MACRO & NEWS.py:135:            st.metric("Prev Close Equity", f"${prev_close:,.0f}" if isinstance(prev_close, (int, float)) else "—")
dashboard/pages/03_ 📰 MACRO & NEWS.py:1578:                        close=hist['Close'],
tick_to_bar_service.py:107:                'close': price,
tick_to_bar_service.py:116:            bar['close'] = price
tick_to_bar_service.py:128:        logger.debug(f"Updated bar {bar_key}: O={bar['open']:.5f} H={bar['high']:.5f} L={bar['low']:.5f} C={bar['close']:.5f} V={bar['volume']}")
tick_to_bar_service.py:183:        topic = os.getenv("KAFKA_TICKS_TOPIC", "mt5.ticks")
tick_to_bar_service.py:201:            consumer.close()
diagnose_and_fix.sh:63:services=("traefik" "mt5" "postgres" "django" "redis" "celery" "celery-beat" "grafana" "prometheus")
diagnose_and_fix.sh:214:echo "   docker-compose logs -f mt5       # MT5 API logs"
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:173:        if ta and all(c in df.columns for c in ("high", "low", "close")):
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:175:                df["atr_14"] = ta.atr(df["high"], df["low"], df["close"], length=14)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:179:        if all(c in df.columns for c in ("close", "volume")):
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:181:                df["vwap_d"] = (df["close"] * df["volume"]).cumsum() / df["volume"].cumsum()
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:203:        close = df['close'].values
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:210:        indicators.update(self._price_indicators(high, low, close, open_prices))
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:213:        indicators.update(self._volume_indicators(high, low, close, volume))
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:216:        indicators.update(self._momentum_indicators(high, low, close))
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:219:        indicators.update(self._volatility_indicators(high, low, close))
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:222:        indicators.update(self._cycle_indicators(close))
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:225:        indicators.update(self._statistical_indicators(close))
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:228:        indicators.update(self._custom_indicators(high, low, close, open_prices, volume))
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:232:    def _price_indicators(self, high, low, close, open_prices):
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:239:                indicators[f'SMA_{period}'] = talib.SMA(close, timeperiod=period)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:240:                indicators[f'EMA_{period}'] = talib.EMA(close, timeperiod=period)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:241:                indicators[f'WMA_{period}'] = talib.WMA(close, timeperiod=period)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:242:                indicators[f'TEMA_{period}'] = talib.TEMA(close, timeperiod=period)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:243:                indicators[f'TRIMA_{period}'] = talib.TRIMA(close, timeperiod=period)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:244:                indicators[f'KAMA_{period}'] = talib.KAMA(close, timeperiod=period)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:245:                indicators[f'MAMA_{period}'], indicators[f'FAMA_{period}'] = talib.MAMA(close)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:252:                bb_upper, bb_middle, bb_lower = talib.BBANDS(close, timeperiod=period)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:257:                indicators[f'BB_POSITION_{period}'] = (close - bb_lower) / (bb_upper - bb_lower)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:272:            indicators['PIVOT'] = (high + low + close) / 3
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:284:    def _volume_indicators(self, high, low, close, volume):
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:290:            indicators['OBV'] = talib.OBV(close, volume)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:291:            indicators['AD'] = talib.AD(high, low, close, volume)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:292:            indicators['ADOSC'] = talib.ADOSC(high, low, close, volume)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:300:            indicators['VPT'] = np.cumsum(volume * (close - np.roll(close, 1)) / np.roll(close, 1))
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:303:            indicators['MFI_14'] = talib.MFI(high, low, close, volume, timeperiod=14)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:306:            indicators['VWAP'] = np.cumsum(volume * close) / np.cumsum(volume)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:313:    def _momentum_indicators(self, high, low, close):
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:320:                indicators[f'RSI_{period}'] = talib.RSI(close, timeperiod=period)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:323:            indicators['STOCH_K'], indicators['STOCH_D'] = talib.STOCH(high, low, close)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:324:            indicators['STOCHF_K'], indicators['STOCHF_D'] = talib.STOCHF(high, low, close)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:325:            indicators['STOCHRSI_K'], indicators['STOCHRSI_D'] = talib.STOCHRSI(close)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:329:                macd, signal_line, histogram = talib.MACD(close, fastperiod=fast, slowperiod=slow, signalperiod=signal)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:336:                indicators[f'WILLR_{period}'] = talib.WILLR(high, low, close, timeperiod=period)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:340:                indicators[f'CCI_{period}'] = talib.CCI(high, low, close, timeperiod=period)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:343:            indicators['ULTOSC'] = talib.ULTOSC(high, low, close)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:347:                indicators[f'ROC_{period}'] = talib.ROC(close, timeperiod=period)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:348:                indicators[f'ROCP_{period}'] = talib.ROCP(close, timeperiod=period)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:349:                indicators[f'ROCR_{period}'] = talib.ROCR(close, timeperiod=period)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:353:                indicators[f'MOM_{period}'] = talib.MOM(close, timeperiod=period)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:360:    def _volatility_indicators(self, high, low, close):
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:367:                indicators[f'ATR_{period}'] = talib.ATR(high, low, close, timeperiod=period)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:368:                indicators[f'NATR_{period}'] = talib.NATR(high, low, close, timeperiod=period)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:369:                indicators[f'TRANGE_{period}'] = talib.TRANGE(high, low, close)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:373:                indicators[f'STDDEV_{period}'] = talib.STDDEV(close, timeperiod=period)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:374:                indicators[f'VAR_{period}'] = talib.VAR(close, timeperiod=period)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:384:    def _cycle_indicators(self, close):
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:390:            indicators['HT_DCPERIOD'] = talib.HT_DCPERIOD(close)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:391:            indicators['HT_DCPHASE'] = talib.HT_DCPHASE(close)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:392:            indicators['HT_PHASOR_INPHASE'], indicators['HT_PHASOR_QUADRATURE'] = talib.HT_PHASOR(close)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:393:            indicators['HT_SINE_SINE'], indicators['HT_SINE_LEADSINE'] = talib.HT_SINE(close)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:394:            indicators['HT_TRENDMODE'] = talib.HT_TRENDMODE(close)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:401:    def _statistical_indicators(self, close):
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:408:                indicators[f'LINEARREG_{period}'] = talib.LINEARREG(close, timeperiod=period)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:409:                indicators[f'LINEARREG_ANGLE_{period}'] = talib.LINEARREG_ANGLE(close, timeperiod=period)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:410:                indicators[f'LINEARREG_INTERCEPT_{period}'] = talib.LINEARREG_INTERCEPT(close, timeperiod=period)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:411:                indicators[f'LINEARREG_SLOPE_{period}'] = talib.LINEARREG_SLOPE(close, timeperiod=period)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:415:                indicators[f'TSF_{period}'] = talib.TSF(close, timeperiod=period)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:418:            indicators['BETA'] = talib.BETA(close, close, timeperiod=5)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:419:            indicators['CORREL'] = talib.CORREL(close, close, timeperiod=30)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:426:    def _custom_indicators(self, high, low, close, open_prices, volume):
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:432:            ha_close = (open_prices + high + low + close) / 4
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:434:            ha_open[0] = (open_prices[0] + close[0]) / 2
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:436:                ha_open[i] = (ha_open[i-1] + ha_close[i-1]) / 2
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:437:            ha_high = np.maximum(high, np.maximum(ha_open, ha_close))
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:438:            ha_low = np.minimum(low, np.minimum(ha_open, ha_close))
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:443:            indicators['HA_CLOSE'] = ha_close
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:450:            chikou_span = pd.Series(close).shift(-26)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:465:                atr = talib.ATR(high, low, close, timeperiod=period)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:469:                supertrend = np.zeros_like(close)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:470:                direction = np.ones_like(close)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:472:                for i in range(1, len(close)):
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:473:                    if close[i] > upper_band[i-1]:
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:475:                    elif close[i] < lower_band[i-1]:
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:515:            close = df['close'].values
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:518:            pivots = self._find_pivots(high, low, close)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:530:    def _find_pivots(self, high, low, close, window=5):
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:647:        close = df['close'].values
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:713:            close = df['close'].values
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:717:                if close[i] > open_prices[i] and close[i+1] > high[i]:
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:723:                        'strength': (close[i] - open_prices[i]) / open_prices[i]
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:727:                if close[i] < open_prices[i] and close[i+1] < low[i]:
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:733:                        'strength': (open_prices[i] - close[i]) / open_prices[i]
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:782:            close = df['close'].values
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:786:                for i in range(ob['index'] + 1, len(close)):
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:787:                    if ob['type'] == 'bullish_ob' and close[i] < ob['bottom']:
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:792:                            'break_price': close[i]
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:795:                    elif ob['type'] == 'bearish_ob' and close[i] > ob['top']:
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:800:                            'break_price': close[i]
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:815:            close = df['close'].values
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:819:                for i in range(ob['index'] + 1, len(close)):
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:821:                        if ob['bottom'] <= close[i] <= ob['top']:
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:826:                                'mitigation_price': close[i]
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:830:                        if ob['bottom'] <= close[i] <= ob['top']:
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:835:                                'mitigation_price': close[i]
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:849:            close = df['close'].values
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:853:            price_changes = np.diff(close) / close[:-1]
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:880:            close = df['close'].values
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:884:                if low[i] < min(low[i-2:i]) and close[i] > low[i] and close[i+1] > close[i]:
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:889:                        'recovery': close[i+1] - low[i]
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:893:                if high[i] > max(high[i-2:i]) and close[i] < high[i] and close[i+1] < close[i]:
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:898:                        'decline': high[i] - close[i+1]
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:973:        if len(df) < 60 or 'close' not in df.columns:
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:976:        close   = df['close'].to_numpy()
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:980:        vol_20  = pd.Series(close).rolling(20).std().fillna(method='bfill').to_numpy()
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:994:                      and close[i] > 1.01 * close[i-5]
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:998:                                       strength=(close[i]-close[i-5])/close[i-5]))
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:1016:            close = df['close'].values
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:1021:                if (close[i] < close[i-5] and volume[i] > np.mean(volume[i-10:i]) and
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:1022:                    close[i+1] > close[i]):
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:1026:                        'price': close[i],
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:1034:                    close[i] < close[i-1] and
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:1035:                    close[i+1] > close[i]):
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:1039:                        'price': close[i],
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:1055:            close = df['close'].values
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:1061:            price_trend = np.polyfit(range(len(close)), close, 1)[0]
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:1081:            close = df['close'].values
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:1085:                price_change = abs(close[i] - close[i-1]) / close[i-1]
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:1118:            close = df['close'].values
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:1147:                'current_bias': self._determine_supply_demand_bias(close, volume)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:1155:    def _determine_supply_demand_bias(self, close, volume):
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:1158:            recent_close = close[-10:]
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:1162:            up_volume = sum(recent_volume[i] for i in range(1, len(recent_close)) if recent_close[i] > recent_close[i-1])
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:1163:            down_volume = sum(recent_volume[i] for i in range(1, len(recent_close)) if recent_close[i] < recent_close[i-1])
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:1615:        """Simple support/resistance finder for close prices."""
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:1616:        if 'close' not in df.columns:
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:1618:        close = df['close'].values
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:1619:        support = float(np.min(close))
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:1620:        resistance = float(np.max(close))
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:1674:            required_ohlc = ['open', 'high', 'low', 'close']
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:1755:                                'close':  'last',
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:1761:                                if col not in ('open', 'high', 'low', 'close', 'volume'):
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:1951:            if 'close' in df.columns:
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:1952:                close = df['close']
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:1954:                    'first_price': close.iloc[0],
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:1955:                    'last_price': close.iloc[-1],
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:1956:                    'high_price': close.max(),
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:1957:                    'low_price': close.min(),
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:1958:                    'price_change': close.iloc[-1] - close.iloc[0],
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:1959:                    'price_change_pct': ((close.iloc[-1] - close.iloc[0]) / close.iloc[0]) * 100,
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:1960:                    'volatility': close.pct_change().std() * np.sqrt(252),
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:1961:                    'skewness': close.pct_change().skew(),
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:1962:                    'kurtosis': close.pct_change().kurtosis()
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:1993:            if 'close' in df.columns:
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:1994:                close = df['close'].values
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:1998:                analytics['fractal_dimension'] = self._calculate_fractal_dimension(close)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:2003:                analytics['hurst_exponent'] = self._calculate_hurst_exponent(close)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:2007:                if len(close) > 2000:
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:2008:                    logger.info("SKIPPING: approximate entropy (series too large: %d rows)", len(close))
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:2012:                    analytics['approximate_entropy'] = self._calculate_approximate_entropy(close)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:2017:                analytics['dfa_alpha'] = self._calculate_dfa(close)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:2022:                analytics['efficiency_ratio'] = self._calculate_efficiency_ratio(close)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:2027:                analytics['trend_strength'] = self._calculate_trend_strength(close)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:2037:                analytics['fibonacci_levels'] = self._calculate_fibonacci_levels(close)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:2042:                if 'close' in df.columns:
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:2043:                    analytics['adf_fuller'] = add_fuller(df['close'].values)
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:2222:            if 'close' not in df.columns:
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:2224:            close = df['close'].values
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:2225:            returns = np.diff(close) / close[:-1]
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:2228:                'max_drawdown': float(np.min((close - np.maximum.accumulate(close)) / np.maximum.accumulate(close))),
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:2600:def _prepare_ml_features(df: pd.DataFrame, target_col: str = 'close'):
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:2615:def _build_feature_matrix(dfs: list, target_col: str = 'close'):
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:2793:def _prepare_ml_features(df: pd.DataFrame, target_col: str = 'close'):
utils/ncOS_ultimate_microstructure_analyzer_DEFAULTS.py:2808:def _build_feature_matrix(dfs: list, target_col: str = 'close'):
knowledge/v10.md:113:Monitor Price Reaction: As price approaches an HTF POI, observe on LTFs for initial clues like slowing momentum or subtle structural shifts suggesting the HTF level might hold. This interaction is an alert to pay closer attention; it is not an entry signal itself.
knowledge/v10.md:205:Partial Profits: Consider taking partial profits at closer, more probable targets (like the Initial TP). This secures gains, reduces risk on the remaining position (allowing a move of SL to break-even or better), and allows a portion of the trade to potentially run for larger targets.
utils/sync_mt5_scheduler.py:4:from utils.sync_mt5_trades import fetch_mt5_trades, persist_trades
utils/sync_mt5_scheduler.py:13:    trades = fetch_mt5_trades(DATE_FROM)
actions/sse_test.html:39:      if (es) { es.close(); es = null; }
actions/sse_test.html:53:      if (es) { es.close(); es = null; log('event', 'SSE closed'); }
dashboard/pages/8_ 💸 Quad Destroyer.py:403:            atr14 = talib.ATR(df['high'].values, df['low'].values, df['close'].values, timeperiod=atr_period)
dashboard/pages/8_ 💸 Quad Destroyer.py:453:                    displacement = abs(df_ny['close'].iloc[j] - df_ny['close'].iloc[j-1])
dashboard/pages/8_ 💸 Quad Destroyer.py:459:                        entry_price = df_ny['close'].iloc[j]
dashboard/pages/8_ 💸 Quad Destroyer.py:571:                    if df['close'].iloc[j] < asian_high:  # Price back below swept level
dashboard/pages/8_ 💸 Quad Destroyer.py:581:                    if df['close'].iloc[j] > asian_low:  # Price back above swept level
dashboard/pages/8_ 💸 Quad Destroyer.py:628:                if gap_size > 0.001 * df['close'].iloc[i]:  # Minimum gap threshold
dashboard/pages/8_ 💸 Quad Destroyer.py:641:                if gap_size > 0.001 * df['close'].iloc[i]:  # Minimum gap threshold
dashboard/pages/8_ 💸 Quad Destroyer.py:660:            if (df['close'].iloc[i] < df['open'].iloc[i] and  # Down candle
dashboard/pages/8_ 💸 Quad Destroyer.py:661:                df['close'].iloc[i+1] > df['open'].iloc[i+1] and  # Next candle up
dashboard/pages/8_ 💸 Quad Destroyer.py:662:                df['close'].iloc[i+1] > df['high'].iloc[i]):  # Strong move up
dashboard/pages/8_ 💸 Quad Destroyer.py:673:            elif (df['close'].iloc[i] > df['open'].iloc[i] and  # Up candle
dashboard/pages/8_ 💸 Quad Destroyer.py:674:                  df['close'].iloc[i+1] < df['open'].iloc[i+1] and  # Next candle down
dashboard/pages/8_ 💸 Quad Destroyer.py:675:                  df['close'].iloc[i+1] < df['low'].iloc[i]):  # Strong move down
dashboard/pages/8_ 💸 Quad Destroyer.py:697:            if df['close'].iloc[i] > recent_high:  # Bullish BOS
dashboard/pages/8_ 💸 Quad Destroyer.py:699:            elif df['close'].iloc[i] < recent_low:  # Bearish BOS
dashboard/pages/8_ 💸 Quad Destroyer.py:709:                if (df['close'].iloc[i] < older_low and
dashboard/pages/8_ 💸 Quad Destroyer.py:710:                    df['close'].iloc[i-1] > older_low):  # Bearish CHoCH
dashboard/pages/8_ 💸 Quad Destroyer.py:712:                elif (df['close'].iloc[i] > older_high and
dashboard/pages/8_ 💸 Quad Destroyer.py:713:                      df['close'].iloc[i-1] < older_high):  # Bullish CHoCH
dashboard/pages/8_ 💸 Quad Destroyer.py:733:                        'price': df['close'].iloc[i],
dashboard/pages/8_ 💸 Quad Destroyer.py:760:        df['price_volatility'] = df['close'].rolling(20).std()
dashboard/pages/8_ 💸 Quad Destroyer.py:761:        df['price_trend'] = df['close'].rolling(50).mean()
dashboard/pages/8_ 💸 Quad Destroyer.py:779:            trend_strength = abs(window['close'].iloc[-1] - window['close'].iloc[0]) / price_range
dashboard/pages/8_ 💸 Quad Destroyer.py:794:                  window['close'].iloc[-1] < window['high'].max() * 0.95):
dashboard/pages/8_ 💸 Quad Destroyer.py:801:                  window['close'].iloc[-1] > window['close'].iloc[0] * 1.02 and
dashboard/pages/8_ 💸 Quad Destroyer.py:809:                  window['close'].iloc[-1] < window['close'].iloc[0] * 0.98 and
dashboard/pages/8_ 💸 Quad Destroyer.py:825:                df['close'].iloc[i] < df['close'].iloc[i-1] and
dashboard/pages/8_ 💸 Quad Destroyer.py:826:                (df['close'].iloc[i] - df['low'].iloc[i]) / (df['high'].iloc[i] - df['low'].iloc[i]) < 0.3):
dashboard/pages/8_ 💸 Quad Destroyer.py:830:            # Buying Climax (BC): High volume, strong up move with weak close
dashboard/pages/8_ 💸 Quad Destroyer.py:832:                  df['close'].iloc[i] > df['close'].iloc[i-1] and
dashboard/pages/8_ 💸 Quad Destroyer.py:833:                  (df['close'].iloc[i] - df['low'].iloc[i]) / (df['high'].iloc[i] - df['low'].iloc[i]) > 0.7):
dashboard/pages/8_ 💸 Quad Destroyer.py:840:                  df['close'].iloc[i] > df['low'].iloc[i]):
dashboard/pages/8_ 💸 Quad Destroyer.py:876:            close=df['close'],
dashboard/pages/8_ 💸 Quad Destroyer.py:921:                        y=[df.loc[idx, 'close']],
dashboard/pages/8_ 💸 Quad Destroyer.py:963:                    y=fvg_bull['close'],
dashboard/pages/8_ 💸 Quad Destroyer.py:979:                    y=fvg_bear['close'],
dashboard/pages/8_ 💸 Quad Destroyer.py:997:            elif df.loc[idx, 'close'] >= df.loc[idx, 'open']:
dashboard/pages/8_ 💸 Quad Destroyer.py:1298:            required_cols = ['open', 'high', 'low', 'close']
dashboard/pages/8_ 💸 Quad Destroyer.py:1309:                    'last_price': df['close'].iloc[-1],
dashboard/pages/8_ 💸 Quad Destroyer.py:1310:                    'daily_change': ((df['close'].iloc[-1] - df['close'].iloc[0]) / df['close'].iloc[0]) * 100
dashboard/pages/8_ 💸 Quad Destroyer.py:1522:    current_price = latest['close']
dashboard/pages/8_ 💸 Quad Destroyer.py:1525:        price_change = current_price - current_df.iloc[-2]['close']
dashboard/pages/8_ 💸 Quad Destroyer.py:1526:        price_change_pct = (price_change / current_df.iloc[-2]['close']) * 100
dashboard/pages/8_ 💸 Quad Destroyer.py:1719:                            <div>Price: ${price_fmt(df_tf.iloc[-1]['close'], selected_symbol)}</div>
dashboard/pages/15_ WyckoffAdvanced.py:18:MT5_API_URL = os.getenv("MT5_API_URL", "http://mt5:5001")
dashboard/pages/15_ WyckoffAdvanced.py:71:    ret = df['close'].pct_change()
dashboard/pages/15_ WyckoffAdvanced.py:73:    bb_mid = df['close'].rolling(win).mean()
dashboard/pages/15_ WyckoffAdvanced.py:74:    bb_sd = df['close'].rolling(win).std()
dashboard/pages/15_ WyckoffAdvanced.py:77:    bb_pct = (df['close'] - bb_lower) / (bb_upper - bb_lower + 1e-6)
dashboard/pages/15_ WyckoffAdvanced.py:80:    net_change = abs(df['close'].diff(win))
dashboard/pages/15_ WyckoffAdvanced.py:81:    total_change = df['close'].diff().abs().rolling(win).sum()
dashboard/pages/15_ WyckoffAdvanced.py:102:    df['spring'] = (df['low'] < rolling_low.shift(1)) & (df['close'] > df['open']) & (vol_z > 0.5)
dashboard/pages/15_ WyckoffAdvanced.py:103:    df['upthrust'] = (df['high'] > rolling_high.shift(1)) & (df['close'] < df['open']) & (vol_z > 0.5)
dashboard/pages/15_ WyckoffAdvanced.py:146:                                         low=analyzed['low'], close=analyzed['close']), row=1, col=1)
dashboard/pages/15_ WyckoffAdvanced.py:153:                    fig.add_trace(go.Scatter(x=phase_df.index, y=phase_df['close'], mode='lines',
utils/mt5_kafka_producer.py:15:        topic: str = "mt5.ticks",
actions/cockpit.html:151:            es.addEventListener('error', () => { if (es) { es.close(); es = null; } startPoll(); });
actions/cockpit.html:168:        return () => { stop = true; if (es) es.close(); if (poll) clearInterval(poll); };
docs/journal_envelopes.md:41:- Failing to publish must never impact trade flow (engine is fail‑closed)
dashboard/pages/20_advanced_risk_manager copy.py:37:    import MetaTrader5 as mt5
dashboard/pages/20_advanced_risk_manager copy.py:41:    mt5 = None
dashboard/pages/20_advanced_risk_manager copy.py:384:    mt5_base = getattr(pulse_manager, "mt5_url", None)
dashboard/pages/20_advanced_risk_manager copy.py:385:    mt5_ok = False
dashboard/pages/20_advanced_risk_manager copy.py:386:    mt5_detail = ""
dashboard/pages/20_advanced_risk_manager copy.py:387:    if mt5_base:
dashboard/pages/20_advanced_risk_manager copy.py:389:            url = f"{str(mt5_base).rstrip('/')}/account_info"
dashboard/pages/20_advanced_risk_manager copy.py:396:                mt5_ok = isinstance(data, dict) and bool(data)
dashboard/pages/20_advanced_risk_manager copy.py:399:                mt5_detail = f"{login} {server}" if login != "—" else "OK"
dashboard/pages/20_advanced_risk_manager copy.py:401:                mt5_detail = f"HTTP {r.status_code}"
dashboard/pages/20_advanced_risk_manager copy.py:403:            mt5_detail = f"error: {e}"
dashboard/pages/20_advanced_risk_manager copy.py:405:        mt5_detail = "no URL"
dashboard/pages/20_advanced_risk_manager copy.py:419:            "UP" if mt5_ok else "DOWN",
dashboard/pages/20_advanced_risk_manager copy.py:420:            mt5_detail,
dashboard/pages/20_advanced_risk_manager copy.py:433:        self.mt5_login = os.getenv('MT5_LOGIN')
dashboard/pages/20_advanced_risk_manager copy.py:434:        self.mt5_password = os.getenv('MT5_PASSWORD')
dashboard/pages/20_advanced_risk_manager copy.py:435:        self.mt5_server = os.getenv('MT5_SERVER')
dashboard/pages/20_advanced_risk_manager copy.py:439:        self.mt5_available = MT5_AVAILABLE
dashboard/pages/20_advanced_risk_manager copy.py:444:        self._mt5_candidates = [
dashboard/pages/20_advanced_risk_manager copy.py:449:            "http://mt5:5001",
dashboard/pages/20_advanced_risk_manager copy.py:453:        self.mt5_url = next((u for u in self._mt5_candidates if u), None)
dashboard/pages/20_advanced_risk_manager copy.py:473:        if not self.mt5_available:
dashboard/pages/20_advanced_risk_manager copy.py:475:        if not all([self.mt5_login, self.mt5_password, self.mt5_server]):
dashboard/pages/20_advanced_risk_manager copy.py:479:            if not mt5.initialize():
dashboard/pages/20_advanced_risk_manager copy.py:482:            authorized = mt5.login(
dashboard/pages/20_advanced_risk_manager copy.py:483:                login=int(self.mt5_login),
dashboard/pages/20_advanced_risk_manager copy.py:484:                password=self.mt5_password,
dashboard/pages/20_advanced_risk_manager copy.py:485:                server=self.mt5_server
dashboard/pages/20_advanced_risk_manager copy.py:555:        for base in [u for u in self._mt5_candidates if u]:
dashboard/pages/20_advanced_risk_manager copy.py:569:                        self.mt5_url = base  # lock onto the working base
dashboard/pages/20_advanced_risk_manager copy.py:579:        if self.mt5_available and all([self.mt5_login, self.mt5_password, self.mt5_server]):
dashboard/pages/20_advanced_risk_manager copy.py:582:                    if mt5.initialize() and mt5.login(login=int(self.mt5_login), password=self.mt5_password, server=self.mt5_server):
dashboard/pages/20_advanced_risk_manager copy.py:585:                    ai = mt5.account_info()
dashboard/pages/20_advanced_risk_manager copy.py:619:            if self.mt5_url:
dashboard/pages/20_advanced_risk_manager copy.py:620:                r = requests.get(f"{str(self.mt5_url).rstrip('/')}/positions_get", timeout=0.9)
dashboard/pages/20_advanced_risk_manager copy.py:656:            if self.mt5_available:
dashboard/pages/20_advanced_risk_manager copy.py:657:                if not self.connected and self.mt5_login and self.mt5_password and self.mt5_server:
dashboard/pages/20_advanced_risk_manager copy.py:658:                    if mt5.initialize() and mt5.login(login=int(self.mt5_login), password=self.mt5_password, server=self.mt5_server):
dashboard/pages/20_advanced_risk_manager copy.py:661:                    positions = mt5.positions_get()
dashboard/pages/20_advanced_risk_manager copy.py:756:                r = requests.get(f"{self.mt5_url}/{ep}", timeout=0.9)
dashboard/pages/20_advanced_risk_manager copy.py:764:                tcols = [c for c in ["time", "time_msc", "time_done", "time_close"] if c in df.columns]
dashboard/pages/20_advanced_risk_manager copy.py:1446:            st.info("No trades today — trajectory will appear once trades close.")
dashboard/pages/20_advanced_risk_manager copy.py:1727:            consumer.close()
dashboard/pages/20_advanced_risk_manager copy.py:1745:                for col in ["time", "time_msc", "time_done", "time_close", "timestamp"]:
dashboard/pages/20_advanced_risk_manager copy.py:1748:                            if col in ("time", "time_done", "time_close", "timestamp"):
dashboard/pages/20_advanced_risk_manager copy.py:1848:        st.info("No trades today — trajectory will appear once trades close.")
dashboard/pages/20_advanced_risk_manager copy.py:2108:        open=df['Open'], high=df['High'], low=df['Low'], close=df['Close'],
dashboard/pages/20_advanced_risk_manager copy.py:2171:        mt5b = getattr(pulse_manager, 'mt5_url', None)
dashboard/pages/20_advanced_risk_manager copy.py:2173:            ok_bridge = requests.get(f"{str(mt5b).rstrip('/')}/account_info", timeout=1.0).ok if mt5b else False
dashboard/pages/20_advanced_risk_manager copy.py:2212:                            pulse_manager._mt5_candidates = [url_input.strip()] + [u for u in pulse_manager._mt5_candidates if u and u != url_input.strip()]
dashboard/pages/20_advanced_risk_manager copy.py:2213:                            pulse_manager.mt5_url = url_input.strip()
dashboard/pages/20_advanced_risk_manager copy.py:2219:                    test_url = (url_input or pulse_manager.mt5_url or "").rstrip('/')
dashboard/pages/20_advanced_risk_manager copy.py:2354:            st.caption(f"MT5 bridge URL: {getattr(pulse_manager, 'mt5_url', '—')}")
dashboard/pages/20_advanced_risk_manager copy.py:2556:        bridge_url_display = getattr(pulse_manager, 'mt5_url', '') or os.getenv('MT5_URL') or os.getenv('MT5_API_URL') or '—'
dashboard/pages/20_advanced_risk_manager copy.py:2558:            if getattr(pulse_manager, 'mt5_url', None):
dashboard/pages/20_advanced_risk_manager copy.py:2559:                r = requests.get(f"{pulse_manager.mt5_url.rstrip('/')}/health", timeout=1.0)
dashboard/pages/20_advanced_risk_manager copy.py:2567:        st.caption("SL → BE, trailing lock (25/50/75%), and partial closes will be enabled here.")
dashboard/pages/20_advanced_risk_manager copy.py:2629:        traw = last_trade.get("time") or last_trade.get("time_close") or last_trade.get("time_done") or last_trade.get("timestamp")
dashboard/pages/20_advanced_risk_manager copy.py:2744:        trades_today = safe_api_call('GET', 'api/v1/trades/history?window=today&closed_only=true') or []
utils/ComprehensiveJSONVisualizer.py:68:            if 'close' in df.columns and 'mid' not in df.columns:
utils/ComprehensiveJSONVisualizer.py:69:                df['mid'] = df['close']
utils/ComprehensiveJSONVisualizer.py:128:            if all(col in df.columns for col in ['open', 'high', 'low', 'close']):
utils/ComprehensiveJSONVisualizer.py:134:                    close=df['close'],
utils/ComprehensiveJSONVisualizer.py:141:                    y=df['close'] if 'close' in df.columns else df['mid'],
utils/ComprehensiveJSONVisualizer.py:162:                        y=ob_bulls['low'] if 'low' in ob_bulls.columns else ob_bulls['close'],
utils/ComprehensiveJSONVisualizer.py:173:                        y=ob_bears['high'] if 'high' in ob_bears.columns else ob_bears['close'],
utils/ComprehensiveJSONVisualizer.py:184:                     for c, o in zip(df['close'], df['open'])] if 'open' in df.columns else 'blue'
utils/ComprehensiveJSONVisualizer.py:477:                        if 'close' in df.columns:
utils/ComprehensiveJSONVisualizer.py:478:                            latest_price = df['close'].iloc[-1]
utils/ComprehensiveJSONVisualizer.py:479:                            price_change = df['close'].pct_change().iloc[-1] * 100
utils/ComprehensiveJSONVisualizer.py:510:                        "Price Data": ['open', 'high', 'low', 'close', 'mid'],
knowledge/kb_001.txt:910:            decision['reasons'].append('Medium confluence - monitor closely')
knowledge/kb_001.txt:1346:        # Warning if close to limit
docs/yf_mapping_guide.md:11:- `...high[i]`, `...low[i]`, `...close[i]`, `...volume[i]`
docs/yf_mapping_guide.md:16:open = open[i], high = high[i], low = low[i], close = close[i], volume = volume[i]
dashboard/pages/zanalytics_dashboard.py:143:                close=data['Close'],
dashboard/pages/zanalytics_dashboard.py:150:        colors = ['red' if close < open else 'green' 
dashboard/pages/zanalytics_dashboard.py:151:                 for close, open in zip(data['Close'], data['Open'])]
dashboard/pages/zanalytics_dashboard.py:286:        prev_close = data['Close'].iloc[-2] if len(data) > 1 else latest_price
dashboard/pages/zanalytics_dashboard.py:287:        price_change = latest_price - prev_close
dashboard/pages/zanalytics_dashboard.py:288:        price_change_pct = (price_change / prev_close) * 100
utils/session_scheduler.py:7:# Orchestrator endpoint that understands the flow 'session_close_debrief'.
utils/session_scheduler.py:15:    """Load session close times from YAML config.
utils/session_scheduler.py:34:def run_session_close_debrief(session_name: str):
utils/session_scheduler.py:35:    """Trigger orchestrator flow 'session_close_debrief' for a named session.
utils/session_scheduler.py:39:    print(f"[Scheduler] Running {session_name} session close debrief...")
utils/session_scheduler.py:45:        payload = {"type": "session_close_debrief", "payload": {"session": session_name}}
utils/session_scheduler.py:62:            run_session_close_debrief,
utils/session_scheduler.py:68:        print(f"[Scheduler] Scheduled {session_name} close at {hour:02d}:{minute:02d} UTC")
utils/session_scheduler.py:71:    print("[Scheduler] Session close debrief jobs scheduled.")
dashboard/pages/Home2.py:25:from api_integration.mt5_api_client import Mt5APIClient
dashboard/pages/Home2.py:204:                required_cols = {"timestamp", "open", "high", "low", "close", "volume"}
dashboard/pages/Home2.py:217:                    close=df_recent["close"],
dashboard/pages/Home2.py:239:                vwap_prices = (df_recent['high'] + df_recent['low'] + df_recent['close']) / 3
dashboard/pages/Home2.py:250:                close = df_recent['close'].values
dashboard/pages/Home2.py:251:                for i in range(len(close) - window):
dashboard/pages/Home2.py:252:                    win = close[i:i+window]
dashboard/pages/Home2.py:278:                        y_mid = (win['high'].max() + win['low'].min()) / 2 if not win.empty else df_recent['close'].iloc[-1]
dashboard/pages/Home2.py:343:        self.mt5_client = Mt5APIClient(base_url=self.api_url)
dashboard/pages/Home2.py:367:            df = self.mt5_client.get_bars(symbol, interval, limit)
dashboard/pages/Home2.py:376:                        SELECT ts, open, high, low, close, volume
dashboard/pages/Home2.py:396:        return self.mt5_client.get_ticks(symbol, limit)
dashboard/pages/Home2.py:480:                "- When quoting, include instrument + timeframe + time (e.g., M15 close at 13:45Z)"
dashboard/pages/Home2.py:642:                        close=df_recent["close"],
dashboard/pages/Home2.py:666:                    vwap_prices = (df_recent['high'] + df_recent['low'] + df_recent['close']) / 3
dashboard/pages/Home2.py:677:                    close = df_recent['close'].values
dashboard/pages/Home2.py:679:                    for i in range(len(close) - window):
dashboard/pages/Home2.py:680:                        win = close[i:i+window]
dashboard/pages/Home2.py:715:                                y_mid = df_recent['close'].iloc[-1]
dashboard/pages/Home2.py:776:                required_cols = {"timestamp", "open", "high", "low", "close", "volume"}
dashboard/pages/Home2.py:789:                        close=df_recent["close"],
dashboard/pages/Home2.py:811:                    vwap_prices = (df_recent['high'] + df_recent['low'] + df_recent['close']) / 3
dashboard/pages/Home2.py:820:                    close = df_recent['close'].values
dashboard/pages/Home2.py:821:                    for i in range(len(close) - window):
dashboard/pages/Home2.py:822:                        win = close[i:i+window]
dashboard/pages/Home2.py:851:                                y_mid = df_recent['close'].iloc[-1]
dashboard/pages/Home2.py:907:            required_cols = {"timestamp", "open", "high", "low", "close", "volume"}
dashboard/pages/Home2.py:921:                        close=df_recent["close"],
dashboard/pages/Home2.py:943:                    vwap_prices = (df_recent['high'] + df_recent['low'] + df_recent['close']) / 3
dashboard/pages/Home2.py:952:                    close = df_recent['close'].values
dashboard/pages/Home2.py:953:                    for i in range(len(close) - window):
dashboard/pages/Home2.py:954:                        win = close[i:i+window]
dashboard/pages/Home2.py:983:                                y_mid = df_recent['close'].iloc[-1]
dashboard/pages/Home2.py:1049:            if {"timestamp", "close"}.issubset(df_3d.columns):
dashboard/pages/Home2.py:1053:                y_vals = df_3d_recent["close"]
dashboard/pages/Home2.py:1054:                z_vals = np.abs(df_3d_recent["close"].diff().fillna(0))
dashboard/pages/Home2.py:1086:                st.info("XAUUSD 15min data missing 'timestamp' or 'close' column for 3D FVG/SMC chart.")
dashboard/pages/Home2.py:1106:            if not {"timestamp", "close", "volume"}.issubset(df.columns):
dashboard/pages/Home2.py:1111:            df.dropna(subset=["timestamp", "close", "volume"], inplace=True)
dashboard/pages/Home2.py:1114:            df["price_bin"] = pd.cut(df["close"], bins=50, labels=False)
dashboard/pages/Home2.py:1366:            if {"timestamp", "close"}.issubset(df.columns):
dashboard/pages/Home2.py:1372:                    y=df_recent["close"],
docs/ACTIONS_BUS.md:44:  - `position_close` → full/partial close (payload: {ticket, fraction? | volume?})
docs/ACTIONS_BUS.md:56:    -d '{"type":"position_close","payload":{"ticket":302402468,"fraction":0.5}}'
docs/custom_gpt_instructions.md:23:- Use the last bar’s `close` as the latest confirmed price for short summaries; otherwise show the time.
docs/custom_gpt_instructions.md:27:- Flatten arrays: pair `timestamp[i]` with `open/high/low/close/volume[i]` from `indicators.quote[0]`.
docs/custom_gpt_instructions.md:43:- Include instrument and timeframe of confirmation: "Last confirmed XAUUSD (M15 close): 2418.3 at 13:45Z".
docs/custom_gpt_instructions.md:91:- Partial close {X}%
docs/custom_gpt_instructions.md:95:User: "Just closed, lost $200"
docs/custom_gpt_instructions.md:181:- Never fabricate market prices — always confirm from a feed or disclose uncertainty.
dashboard/pages/01_Pulse_Dashboard.py:12:MT5_URL     = os.getenv('MT5_URL', 'http://mt5:5001')
dashboard/pages/01_Pulse_Dashboard.py:260:                if c1.button('Close', key=f"close_{ticket}", use_container_width=True, disabled=not st.session_state.enable_actions):
dashboard/pages/01_Pulse_Dashboard.py:263:                            {'type': 'position_close', 'payload': {'ticket': ticket}},
dashboard/pages/01_Pulse_Dashboard.py:264:                            idempotency_key=f"close-{ticket}-{uuid.uuid4().hex[:8]}",
dashboard/pages/01_Pulse_Dashboard.py:270:                            {'type': 'position_close', 'payload': {'ticket': ticket, 'fraction': 0.5}},
knowledge/v5.md:143:Partial Profits: Consider taking partial profits at closer, more probable targets to secure gains and manage risk.
dashboard/pages/12_PULSE_Flow.py:74:        "- When quoting, include instrument + timeframe + time (e.g., M15 close at 13:45Z)"
dashboard/pages/12_PULSE_Flow.py:400:    for c in ["open","high","low","close","volume"]:
dashboard/pages/12_PULSE_Flow.py:412:            if not df.empty and "close" in df.columns:
dashboard/pages/12_PULSE_Flow.py:413:                series[s] = df.set_index("timestamp")["close"].astype(float)
dashboard/pages/12_PULSE_Flow.py:479:    for col in ("ts_open","ts_close"):
dashboard/pages/12_PULSE_Flow.py:876:    cols = [c for c in ['ts_open','ts_close','symbol','side','entry','exit','pnl','rr','strategy','session'] if c in df_view.columns]
utils/volume_profile.py:147:        current_price = df['close'].iloc[-1]
dashboard/pages/11_WyckoffAdvanced.py:20:def _mt5_health(timeout: float = 1.2) -> bool:
dashboard/pages/11_WyckoffAdvanced.py:21:    for url in ("http://mt5:8000/health", "http://localhost:5001/account_info"):
dashboard/pages/11_WyckoffAdvanced.py:30:mt5_ok = _mt5_health()
dashboard/pages/11_WyckoffAdvanced.py:31:st.caption(f"MT5 bridge: {'✅ OK' if mt5_ok else '⚠️ Unavailable'}")
dashboard/pages/11_WyckoffAdvanced.py:110:            "http://mt5:8000/ticks",  # internal Docker network
dashboard/pages/11_WyckoffAdvanced.py:145:        close=ohlc_df['close'],
redis_architecture/Dockerfile.mt5:5:COPY mt5_redis_integration.py .
redis_architecture/Dockerfile.mt5:6:COPY run_mt5_integration.py .
redis_architecture/Dockerfile.mt5:7:CMD ["python", "run_mt5_integration.py"]
utils/kafka_utils.py:38:        consumer.close()
docs/gpt_llm/LLM_Integration_Guide.md:31:- Today’s `sod_equity` is derived from previous session close; cached in Redis: `sod_equity:{YYYYMMDD}`.
utils/ncos_enhanced_analyzer.py:179:        if ta and all(c in df.columns for c in ("high", "low", "close")):
utils/ncos_enhanced_analyzer.py:181:                df["atr_14"] = ta.atr(df["high"], df["low"], df["close"], length=14)
utils/ncos_enhanced_analyzer.py:186:        if all(c in df.columns for c in ("close", "volume")):
utils/ncos_enhanced_analyzer.py:188:                df["vwap_d"] = (df["close"] * df["volume"]).cumsum() / df["volume"].cumsum()
utils/ncos_enhanced_analyzer.py:200:            # London Kill Zone starts with London session (EU) and closes at 13:00 UTC.
utils/ncos_enhanced_analyzer.py:213:        close = df['close'].values
utils/ncos_enhanced_analyzer.py:220:        indicators.update(self._price_indicators(high, low, close, open_prices))
utils/ncos_enhanced_analyzer.py:223:        indicators.update(self._volume_indicators(high, low, close, volume))
utils/ncos_enhanced_analyzer.py:226:        indicators.update(self._momentum_indicators(high, low, close))
utils/ncos_enhanced_analyzer.py:229:        indicators.update(self._volatility_indicators(high, low, close))
utils/ncos_enhanced_analyzer.py:232:        indicators.update(self._cycle_indicators(close))
utils/ncos_enhanced_analyzer.py:235:        indicators.update(self._statistical_indicators(close))
utils/ncos_enhanced_analyzer.py:238:        indicators.update(self._custom_indicators(high, low, close, open_prices, volume))
utils/ncos_enhanced_analyzer.py:244:    def _price_indicators(self, high, low, close, open_prices):
utils/ncos_enhanced_analyzer.py:251:                indicators[f'SMA_{period}'] = talib.SMA(close, timeperiod=period)
utils/ncos_enhanced_analyzer.py:252:                indicators[f'EMA_{period}'] = talib.EMA(close, timeperiod=period)
utils/ncos_enhanced_analyzer.py:253:                indicators[f'WMA_{period}'] = talib.WMA(close, timeperiod=period)
utils/ncos_enhanced_analyzer.py:254:                indicators[f'TEMA_{period}'] = talib.TEMA(close, timeperiod=period)
utils/ncos_enhanced_analyzer.py:255:                indicators[f'TRIMA_{period}'] = talib.TRIMA(close, timeperiod=period)
utils/ncos_enhanced_analyzer.py:256:                indicators[f'KAMA_{period}'] = talib.KAMA(close, timeperiod=period)
utils/ncos_enhanced_analyzer.py:257:                indicators[f'MAMA_{period}'], indicators[f'FAMA_{period}'] = talib.MAMA(close)
utils/ncos_enhanced_analyzer.py:264:                bb_upper, bb_middle, bb_lower = talib.BBANDS(close, timeperiod=period)
utils/ncos_enhanced_analyzer.py:269:                indicators[f'BB_POSITION_{period}'] = (close - bb_lower) / (bb_upper - bb_lower)
utils/ncos_enhanced_analyzer.py:284:            indicators['PIVOT'] = (high + low + close) / 3
utils/ncos_enhanced_analyzer.py:296:    def _volume_indicators(self, high, low, close, volume):
utils/ncos_enhanced_analyzer.py:302:            indicators['OBV'] = talib.OBV(close, volume)
utils/ncos_enhanced_analyzer.py:303:            indicators['AD'] = talib.AD(high, low, close, volume)
utils/ncos_enhanced_analyzer.py:304:            indicators['ADOSC'] = talib.ADOSC(high, low, close, volume)
utils/ncos_enhanced_analyzer.py:312:            indicators['VPT'] = np.cumsum(volume * (close - np.roll(close, 1)) / np.roll(close, 1))
utils/ncos_enhanced_analyzer.py:315:            indicators['MFI_14'] = talib.MFI(high, low, close, volume, timeperiod=14)
utils/ncos_enhanced_analyzer.py:318:            indicators['VWAP'] = np.cumsum(volume * close) / np.cumsum(volume)
utils/ncos_enhanced_analyzer.py:325:    def _momentum_indicators(self, high, low, close):
utils/ncos_enhanced_analyzer.py:332:                indicators[f'RSI_{period}'] = talib.RSI(close, timeperiod=period)
utils/ncos_enhanced_analyzer.py:335:            indicators['STOCH_K'], indicators['STOCH_D'] = talib.STOCH(high, low, close)
utils/ncos_enhanced_analyzer.py:336:            indicators['STOCHF_K'], indicators['STOCHF_D'] = talib.STOCHF(high, low, close)
utils/ncos_enhanced_analyzer.py:337:            indicators['STOCHRSI_K'], indicators['STOCHRSI_D'] = talib.STOCHRSI(close)
utils/ncos_enhanced_analyzer.py:341:                macd, signal_line, histogram = talib.MACD(close, fastperiod=fast, slowperiod=slow, signalperiod=signal)
utils/ncos_enhanced_analyzer.py:348:                indicators[f'WILLR_{period}'] = talib.WILLR(high, low, close, timeperiod=period)
utils/ncos_enhanced_analyzer.py:352:                indicators[f'CCI_{period}'] = talib.CCI(high, low, close, timeperiod=period)
utils/ncos_enhanced_analyzer.py:355:            indicators['ULTOSC'] = talib.ULTOSC(high, low, close)
utils/ncos_enhanced_analyzer.py:359:                indicators[f'ROC_{period}'] = talib.ROC(close, timeperiod=period)
utils/ncos_enhanced_analyzer.py:360:                indicators[f'ROCP_{period}'] = talib.ROCP(close, timeperiod=period)
utils/ncos_enhanced_analyzer.py:361:                indicators[f'ROCR_{period}'] = talib.ROCR(close, timeperiod=period)
utils/ncos_enhanced_analyzer.py:365:                indicators[f'MOM_{period}'] = talib.MOM(close, timeperiod=period)
utils/ncos_enhanced_analyzer.py:372:    def _volatility_indicators(self, high, low, close):
utils/ncos_enhanced_analyzer.py:379:                indicators[f'ATR_{period}'] = talib.ATR(high, low, close, timeperiod=period)
utils/ncos_enhanced_analyzer.py:380:                indicators[f'NATR_{period}'] = talib.NATR(high, low, close, timeperiod=period)
utils/ncos_enhanced_analyzer.py:381:                indicators[f'TRANGE_{period}'] = talib.TRANGE(high, low, close)
utils/ncos_enhanced_analyzer.py:385:                indicators[f'STDDEV_{period}'] = talib.STDDEV(close, timeperiod=period)
utils/ncos_enhanced_analyzer.py:386:                indicators[f'VAR_{period}'] = talib.VAR(close, timeperiod=period)
utils/ncos_enhanced_analyzer.py:396:    def _cycle_indicators(self, close):
utils/ncos_enhanced_analyzer.py:402:            indicators['HT_DCPERIOD'] = talib.HT_DCPERIOD(close)
utils/ncos_enhanced_analyzer.py:403:            indicators['HT_DCPHASE'] = talib.HT_DCPHASE(close)
utils/ncos_enhanced_analyzer.py:404:            indicators['HT_PHASOR_INPHASE'], indicators['HT_PHASOR_QUADRATURE'] = talib.HT_PHASOR(close)
utils/ncos_enhanced_analyzer.py:405:            indicators['HT_SINE_SINE'], indicators['HT_SINE_LEADSINE'] = talib.HT_SINE(close)
utils/ncos_enhanced_analyzer.py:406:            indicators['HT_TRENDMODE'] = talib.HT_TRENDMODE(close)
utils/ncos_enhanced_analyzer.py:413:    def _statistical_indicators(self, close):
utils/ncos_enhanced_analyzer.py:420:                indicators[f'LINEARREG_{period}'] = talib.LINEARREG(close, timeperiod=period)
utils/ncos_enhanced_analyzer.py:421:                indicators[f'LINEARREG_ANGLE_{period}'] = talib.LINEARREG_ANGLE(close, timeperiod=period)
utils/ncos_enhanced_analyzer.py:422:                indicators[f'LINEARREG_INTERCEPT_{period}'] = talib.LINEARREG_INTERCEPT(close, timeperiod=period)
utils/ncos_enhanced_analyzer.py:423:                indicators[f'LINEARREG_SLOPE_{period}'] = talib.LINEARREG_SLOPE(close, timeperiod=period)
utils/ncos_enhanced_analyzer.py:427:                indicators[f'TSF_{period}'] = talib.TSF(close, timeperiod=period)
utils/ncos_enhanced_analyzer.py:430:            indicators['BETA'] = talib.BETA(close, close, timeperiod=5)
utils/ncos_enhanced_analyzer.py:431:            indicators['CORREL'] = talib.CORREL(close, close, timeperiod=30)
utils/ncos_enhanced_analyzer.py:438:    def _custom_indicators(self, high, low, close, open_prices, volume):
utils/ncos_enhanced_analyzer.py:444:            ha_close = (open_prices + high + low + close) / 4
utils/ncos_enhanced_analyzer.py:446:            ha_open[0] = (open_prices[0] + close[0]) / 2
utils/ncos_enhanced_analyzer.py:448:                ha_open[i] = (ha_open[i-1] + ha_close[i-1]) / 2
utils/ncos_enhanced_analyzer.py:449:            ha_high = np.maximum(high, np.maximum(ha_open, ha_close))
utils/ncos_enhanced_analyzer.py:450:            ha_low = np.minimum(low, np.minimum(ha_open, ha_close))
utils/ncos_enhanced_analyzer.py:455:            indicators['HA_CLOSE'] = ha_close
utils/ncos_enhanced_analyzer.py:462:            chikou_span = pd.Series(close).shift(-26)
utils/ncos_enhanced_analyzer.py:477:                atr = talib.ATR(high, low, close, timeperiod=period)
utils/ncos_enhanced_analyzer.py:481:                supertrend = np.zeros_like(close)
utils/ncos_enhanced_analyzer.py:482:                direction = np.ones_like(close)
utils/ncos_enhanced_analyzer.py:484:                for i in range(1, len(close)):
utils/ncos_enhanced_analyzer.py:485:                    if close[i] > upper_band[i-1]:
utils/ncos_enhanced_analyzer.py:487:                    elif close[i] < lower_band[i-1]:
utils/ncos_enhanced_analyzer.py:529:            close = df['close'].values
utils/ncos_enhanced_analyzer.py:532:            pivots = self._find_pivots(high, low, close)
utils/ncos_enhanced_analyzer.py:544:    def _find_pivots(self, high, low, close, window=5):
utils/ncos_enhanced_analyzer.py:709:        close = df['close'].values
utils/ncos_enhanced_analyzer.py:774:            close = df['close'].values
utils/ncos_enhanced_analyzer.py:778:                if close[i] > open_prices[i] and close[i+1] > high[i]:
utils/ncos_enhanced_analyzer.py:784:                        'strength': (close[i] - open_prices[i]) / open_prices[i]
utils/ncos_enhanced_analyzer.py:788:                if close[i] < open_prices[i] and close[i+1] < low[i]:
utils/ncos_enhanced_analyzer.py:794:                        'strength': (open_prices[i] - close[i]) / open_prices[i]
utils/ncos_enhanced_analyzer.py:843:            close = df['close'].values
utils/ncos_enhanced_analyzer.py:847:                for i in range(ob['index'] + 1, len(close)):
utils/ncos_enhanced_analyzer.py:848:                    if ob['type'] == 'bullish_ob' and close[i] < ob['bottom']:
utils/ncos_enhanced_analyzer.py:853:                            'break_price': close[i]
utils/ncos_enhanced_analyzer.py:856:                    elif ob['type'] == 'bearish_ob' and close[i] > ob['top']:
utils/ncos_enhanced_analyzer.py:861:                            'break_price': close[i]
utils/ncos_enhanced_analyzer.py:876:            close = df['close'].values
utils/ncos_enhanced_analyzer.py:880:                for i in range(ob['index'] + 1, len(close)):
utils/ncos_enhanced_analyzer.py:882:                        if ob['bottom'] <= close[i] <= ob['top']:
utils/ncos_enhanced_analyzer.py:887:                                'mitigation_price': close[i]
utils/ncos_enhanced_analyzer.py:891:                        if ob['bottom'] <= close[i] <= ob['top']:
utils/ncos_enhanced_analyzer.py:896:                                'mitigation_price': close[i]
utils/ncos_enhanced_analyzer.py:910:            close = df['close'].values
utils/ncos_enhanced_analyzer.py:914:            price_changes = np.diff(close) / close[:-1]
utils/ncos_enhanced_analyzer.py:941:            close = df['close'].values
utils/ncos_enhanced_analyzer.py:945:                if low[i] < min(low[i-2:i]) and close[i] > low[i] and close[i+1] > close[i]:
utils/ncos_enhanced_analyzer.py:950:                        'recovery': close[i+1] - low[i]
utils/ncos_enhanced_analyzer.py:954:                if high[i] > max(high[i-2:i]) and close[i] < high[i] and close[i+1] < close[i]:
utils/ncos_enhanced_analyzer.py:959:                        'decline': high[i] - close[i+1]
utils/ncos_enhanced_analyzer.py:1034:        if len(df) < 60 or 'close' not in df.columns:
utils/ncos_enhanced_analyzer.py:1037:        close   = df['close'].to_numpy()
utils/ncos_enhanced_analyzer.py:1041:        vol_20  = pd.Series(close).rolling(20).std().fillna(method='bfill').to_numpy()
utils/ncos_enhanced_analyzer.py:1055:                      and close[i] > 1.01 * close[i-5]
utils/ncos_enhanced_analyzer.py:1059:                                       strength=(close[i]-close[i-5])/close[i-5]))
utils/ncos_enhanced_analyzer.py:1077:            close = df['close'].values
utils/ncos_enhanced_analyzer.py:1082:                if (close[i] < close[i-5] and volume[i] > np.mean(volume[i-10:i]) and
utils/ncos_enhanced_analyzer.py:1083:                    close[i+1] > close[i]):
utils/ncos_enhanced_analyzer.py:1087:                        'price': close[i],
utils/ncos_enhanced_analyzer.py:1095:                    close[i] < close[i-1] and
utils/ncos_enhanced_analyzer.py:1096:                    close[i+1] > close[i]):
utils/ncos_enhanced_analyzer.py:1100:                        'price': close[i],
utils/ncos_enhanced_analyzer.py:1116:            close = df['close'].values
utils/ncos_enhanced_analyzer.py:1122:            price_trend = np.polyfit(range(len(close)), close, 1)[0]
utils/ncos_enhanced_analyzer.py:1142:            close = df['close'].values
utils/ncos_enhanced_analyzer.py:1146:                price_change = abs(close[i] - close[i-1]) / close[i-1]
utils/ncos_enhanced_analyzer.py:1179:            close = df['close'].values
utils/ncos_enhanced_analyzer.py:1208:                'current_bias': self._determine_supply_demand_bias(close, volume)
utils/ncos_enhanced_analyzer.py:1216:    def _determine_supply_demand_bias(self, close, volume):
utils/ncos_enhanced_analyzer.py:1219:            recent_close = close[-10:]
utils/ncos_enhanced_analyzer.py:1223:            up_volume = sum(recent_volume[i] for i in range(1, len(recent_close)) if recent_close[i] > recent_close[i-1])
utils/ncos_enhanced_analyzer.py:1224:            down_volume = sum(recent_volume[i] for i in range(1, len(recent_close)) if recent_close[i] < recent_close[i-1])
utils/ncos_enhanced_analyzer.py:1354:                    "calculation_method": "For a bullish order block, it's typically the last down candle before a strong move up. For a bearish order block, it's the last up candle before a strong move down. Specific rules involve checking subsequent candle closes relative to the order block's high/low."
utils/ncos_enhanced_analyzer.py:1440:            required_ohlc = ['open', 'high', 'low', 'close']
utils/ncos_enhanced_analyzer.py:1517:                                'close': 'last', 'volume': 'sum'
utils/ncos_enhanced_analyzer.py:1521:                                if col not in ['open', 'high', 'low', 'close', 'volume']:
utils/ncos_enhanced_analyzer.py:1670:            if 'close' in df.columns:
utils/ncos_enhanced_analyzer.py:1671:                close = df['close']
utils/ncos_enhanced_analyzer.py:1673:                    'first_price': close.iloc[0],
utils/ncos_enhanced_analyzer.py:1674:                    'last_price': close.iloc[-1],
utils/ncos_enhanced_analyzer.py:1675:                    'high_price': close.max(),
utils/ncos_enhanced_analyzer.py:1676:                    'low_price': close.min(),
utils/ncos_enhanced_analyzer.py:1677:                    'price_change': close.iloc[-1] - close.iloc[0],
utils/ncos_enhanced_analyzer.py:1678:                    'price_change_pct': ((close.iloc[-1] - close.iloc[0]) / close.iloc[0]) * 100,
utils/ncos_enhanced_analyzer.py:1679:                    'volatility': close.pct_change().std() * np.sqrt(252),
utils/ncos_enhanced_analyzer.py:1680:                    'skewness': close.pct_change().skew(),
utils/ncos_enhanced_analyzer.py:1681:                    'kurtosis': close.pct_change().kurtosis()
utils/ncos_enhanced_analyzer.py:1712:            if 'close' in df.columns:
utils/ncos_enhanced_analyzer.py:1713:                close = df['close'].values
utils/ncos_enhanced_analyzer.py:1717:                analytics['fractal_dimension'] = self._calculate_fractal_dimension(close)
utils/ncos_enhanced_analyzer.py:1722:                analytics['hurst_exponent'] = self._calculate_hurst_exponent(close)
utils/ncos_enhanced_analyzer.py:1726:                if len(close) > 2000:
utils/ncos_enhanced_analyzer.py:1727:                    self.logger.info("SKIPPING: approximate entropy (series too large: %d rows)", len(close))
utils/ncos_enhanced_analyzer.py:1731:                    analytics['approximate_entropy'] = self._calculate_approximate_entropy(close)
utils/ncos_enhanced_analyzer.py:1736:                analytics['dfa_alpha'] = self._calculate_dfa(close)
utils/ncos_enhanced_analyzer.py:1741:                analytics['efficiency_ratio'] = self._calculate_efficiency_ratio(close)
utils/ncos_enhanced_analyzer.py:1746:                analytics['trend_strength'] = self._calculate_trend_strength(close)
utils/ncos_enhanced_analyzer.py:1756:                analytics['fibonacci_levels'] = self._calculate_fibonacci_levels(close)
utils/ncos_enhanced_analyzer.py:1761:                if 'close' in df.columns:
utils/ncos_enhanced_analyzer.py:1762:                    analytics['adf_fuller'] = add_fuller(df['close'].values)
utils/ncos_enhanced_analyzer.py:1772:        """Simple support/resistance finder for close prices."""
utils/ncos_enhanced_analyzer.py:1773:        if 'close' not in df.columns:
utils/ncos_enhanced_analyzer.py:1775:        close = df['close'].values
utils/ncos_enhanced_analyzer.py:1776:        support = float(np.min(close))
utils/ncos_enhanced_analyzer.py:1777:        resistance = float(np.max(close))
utils/ncos_enhanced_analyzer.py:1780:    def _calculate_fibonacci_levels(self, close: np.ndarray) -> Dict:
utils/ncos_enhanced_analyzer.py:1783:            high = np.max(close)
utils/ncos_enhanced_analyzer.py:1784:            low = np.min(close)
utils/ncos_enhanced_analyzer.py:1808:            if 'close' not in df.columns:
utils/ncos_enhanced_analyzer.py:1810:            close = df['close'].values
utils/ncos_enhanced_analyzer.py:1811:            returns = np.diff(close) / close[:-1]
utils/ncos_enhanced_analyzer.py:1814:                'max_drawdown': float(np.min((close - np.maximum.accumulate(close)) / np.maximum.accumulate(close))),
api_integration/streamlit_api_dashboard.py:114:                if 'close' in df.columns:
api_integration/streamlit_api_dashboard.py:115:                    latest_price = df['close'].iloc[-1]
api_integration/streamlit_api_dashboard.py:116:                    previous_price = df['close'].iloc[-2]
api_integration/streamlit_api_dashboard.py:121:            if all(col in df.columns for col in ['time', 'open', 'high', 'low', 'close']):
api_integration/streamlit_api_dashboard.py:125:                df['SMA20'] = df['close'].rolling(window=20).mean()
api_integration/streamlit_api_dashboard.py:126:                df['SMA50'] = df['close'].rolling(window=50).mean()
api_integration/streamlit_api_dashboard.py:140:                        close=df['close'],
api_integration/streamlit_api_dashboard.py:194:                    df['returns'] = df['close'].pct_change() * 100
dashboard/pages/_Home.py:25:from api_integration.mt5_api_client import Mt5APIClient
dashboard/pages/_Home.py:202:    bars["ret"] = bars["close"].pct_change()
dashboard/pages/_Home.py:204:    ma = bars["close"].rolling(win).mean()
dashboard/pages/_Home.py:205:    sd = bars["close"].rolling(win).std()
dashboard/pages/_Home.py:212:    bars["bb_pctB"] = _nz((bars["close"] - lower) / (upper - lower + 1e-6))
dashboard/pages/_Home.py:296:        self.mt5_client = Mt5APIClient(base_url=self.api_url)
dashboard/pages/_Home.py:316:        df = self.mt5_client.get_bars(symbol, interval, limit)
dashboard/pages/_Home.py:321:        return self.mt5_client.get_ticks(symbol, limit)
dashboard/pages/_Home.py:434:        self.display_live_mt5()
dashboard/pages/_Home.py:562:                        close=df_recent["close"],
dashboard/pages/_Home.py:586:                    vwap_prices = (df_recent['high'] + df_recent['low'] + df_recent['close']) / 3
dashboard/pages/_Home.py:597:                    close = df_recent['close'].values
dashboard/pages/_Home.py:599:                    for i in range(len(close) - window):
dashboard/pages/_Home.py:600:                        win = close[i:i+window]
dashboard/pages/_Home.py:635:                                y_mid = df_recent['close'].iloc[-1]
dashboard/pages/_Home.py:696:                required_cols = {"timestamp", "open", "high", "low", "close", "volume"}
dashboard/pages/_Home.py:709:                        close=df_recent["close"],
dashboard/pages/_Home.py:731:                    vwap_prices = (df_recent['high'] + df_recent['low'] + df_recent['close']) / 3
dashboard/pages/_Home.py:740:                    close = df_recent['close'].values
dashboard/pages/_Home.py:741:                    for i in range(len(close) - window):
dashboard/pages/_Home.py:742:                        win = close[i:i+window]
dashboard/pages/_Home.py:771:                                y_mid = df_recent['close'].iloc[-1]
dashboard/pages/_Home.py:827:            required_cols = {"timestamp", "open", "high", "low", "close", "volume"}
dashboard/pages/_Home.py:841:                        close=df_recent["close"],
dashboard/pages/_Home.py:863:                    vwap_prices = (df_recent['high'] + df_recent['low'] + df_recent['close']) / 3
dashboard/pages/_Home.py:872:                    close = df_recent['close'].values
dashboard/pages/_Home.py:873:                    for i in range(len(close) - window):
dashboard/pages/_Home.py:874:                        win = close[i:i+window]
dashboard/pages/_Home.py:903:                                y_mid = df_recent['close'].iloc[-1]
dashboard/pages/_Home.py:966:            if {"timestamp", "close"}.issubset(df_3d.columns):
dashboard/pages/_Home.py:970:                y_vals = df_3d_recent["close"]
dashboard/pages/_Home.py:971:                z_vals = np.abs(df_3d_recent["close"].diff().fillna(0))
dashboard/pages/_Home.py:1003:                st.info("XAUUSD 15min data missing 'timestamp' or 'close' column for 3D FVG/SMC chart.")
dashboard/pages/_Home.py:1007:    def display_live_mt5(self):
dashboard/pages/_Home.py:1033:            col1.metric("Close", enriched["close"].iloc[-1])
dashboard/pages/_Home.py:1045:                    close=enriched["close"],
dashboard/pages/_Home.py:1085:            if not {"timestamp", "close", "volume"}.issubset(df.columns):
dashboard/pages/_Home.py:1090:            df.dropna(subset=["timestamp", "close", "volume"], inplace=True)
dashboard/pages/_Home.py:1093:            df["price_bin"] = pd.cut(df["close"], bins=50, labels=False)
dashboard/pages/_Home.py:1364:            if {"timestamp", "close"}.issubset(df.columns):
dashboard/pages/_Home.py:1370:                    y=df_recent["close"],
services/tick_to_bar.py:39:                        "close": price,
services/tick_to_bar.py:47:                    state["close"] = price
utils/data_processor.py:44:            required_cols = ['datetime', 'open', 'high', 'low', 'close']
utils/data_processor.py:64:            numeric_cols = ['open', 'high', 'low', 'close', 'volume']
utils/data_processor.py:147:        closest_tf = min(timeframe_map.keys(), key=lambda x: abs(x - minutes))
utils/data_processor.py:148:        return timeframe_map[closest_tf]
docs/gpt_llm/session_times.yaml:1:# Session close schedule (UTC)
utils/smc_analyser.py:83:            if df['close'].iloc[i] < df['open'].iloc[i]:  # Down candle
utils/smc_analyser.py:86:                if (future_high - df['close'].iloc[i]) / df['close'].iloc[i] > min_move:
utils/smc_analyser.py:93:                        'strength': (future_high - df['close'].iloc[i]) / df['close'].iloc[i]
utils/smc_analyser.py:97:            elif df['close'].iloc[i] > df['open'].iloc[i]:  # Up candle
utils/smc_analyser.py:100:                if (df['close'].iloc[i] - future_low) / df['close'].iloc[i] > min_move:
utils/smc_analyser.py:107:                        'strength': (df['close'].iloc[i] - future_low) / df['close'].iloc[i]
utils/smc_analyser.py:119:            if gap_size > 0 and gap_size / df['close'].iloc[i] > min_gap_size:
utils/smc_analyser.py:132:            if gap_size > 0 and gap_size / df['close'].iloc[i] > min_gap_size:
utils/smc_analyser.py:223:                            reversal = after_max['close'].iloc[-1] < zone['level']
utils/smc_analyser.py:243:                            reversal = after_min['close'].iloc[-1] > zone['level']
utils/smc_analyser.py:269:                if df['close'].iloc[i] > df['open'].iloc[i]:
utils/smc_analyser.py:281:                    'close': df['close'].iloc[i]
dashboard/pages/24_Trades_Diagnostics.py:5:- MT5 History: /api/v1/trades/history?source=mt5
dashboard/pages/24_Trades_Diagnostics.py:77:url_mt5 = api_url("api/v1/trades/history")
dashboard/pages/24_Trades_Diagnostics.py:78:mt5_params = {
dashboard/pages/24_Trades_Diagnostics.py:79:    "source": "mt5",
dashboard/pages/24_Trades_Diagnostics.py:84:mt5_trades = _get_json(url_mt5, params=mt5_params)
dashboard/pages/24_Trades_Diagnostics.py:86:# Fallback: some backends expect 'provider=mt5' instead of 'source=mt5'
dashboard/pages/24_Trades_Diagnostics.py:87:if isinstance(mt5_trades, dict) and not _as_df(mt5_trades).shape[0]:
dashboard/pages/24_Trades_Diagnostics.py:88:    mt5_trades = _get_json(
dashboard/pages/24_Trades_Diagnostics.py:89:        url_mt5,
dashboard/pages/24_Trades_Diagnostics.py:91:            "provider": "mt5",
dashboard/pages/24_Trades_Diagnostics.py:98:df_mt5 = _as_df(mt5_trades)
dashboard/pages/24_Trades_Diagnostics.py:100:if not df_mt5.empty and 'symbol' in df_mt5.columns:
dashboard/pages/24_Trades_Diagnostics.py:101:    df_mt5 = df_mt5[df_mt5['symbol'] == symbol]
dashboard/pages/24_Trades_Diagnostics.py:104:if isinstance(mt5_trades, dict) and "error" in mt5_trades:
dashboard/pages/24_Trades_Diagnostics.py:105:    st.warning(f"MT5 History error: {mt5_trades.get('error')} — {mt5_trades.get('url','')}")
dashboard/pages/24_Trades_Diagnostics.py:122:    st.json(mt5_trades)
dashboard/pages/24_Trades_Diagnostics.py:125:cols_mt5 = ["id", "symbol", "direction", "entry", "exit", "pnl", "ts", "status"]
dashboard/pages/24_Trades_Diagnostics.py:126:df_mt5_norm = _normalize_cols(df_mt5, cols_mt5)
dashboard/pages/24_Trades_Diagnostics.py:129:if not df_mt5_norm.empty:
dashboard/pages/24_Trades_Diagnostics.py:135:    for idx, row in df_mt5_norm.iterrows():
LLM/Whisper Ack-Act UI Additions.py.download/Whisper Ack-Act UI Additions.py:72:    st.info("Fallback to local breadcrumb - no closed trades yet.")
LLM/Whisper Ack-Act UI Additions.py.download/Whisper Ack-Act UI Additions.py:94:    st.info("Awaiting feed - produce/close a trade to populate.")
dashboard/pages/34_ 📈 Live_Wyckoff_Terminal.py:16:def _mt5_health(timeout: float = 1.2) -> bool:
dashboard/pages/34_ 📈 Live_Wyckoff_Terminal.py:17:    for url in ("http://mt5:8000/health", "http://localhost:5001/account_info"):
dashboard/pages/34_ 📈 Live_Wyckoff_Terminal.py:26:mt5_ok = _mt5_health()
dashboard/pages/34_ 📈 Live_Wyckoff_Terminal.py:27:st.caption(f"MT5 bridge: {'✅ OK' if mt5_ok else '⚠️ Unavailable'}")
dashboard/pages/34_ 📈 Live_Wyckoff_Terminal.py:31:MT5_API_URL   = st.secrets.get("MT5_API_URL",   "http://mt5:8000")          # e.g., docker service name
dashboard/pages/34_ 📈 Live_Wyckoff_Terminal.py:97:        "close": agg["px"].resample(tf).last(),
dashboard/pages/34_ 📈 Live_Wyckoff_Terminal.py:105:      POST /api/pulse/wyckoff/score  { "bars": [ {ts,open,high,low,close,volume}, ... ] }
dashboard/pages/34_ 📈 Live_Wyckoff_Terminal.py:112:         "low": float(r.low), "close": float(r.close), "volume": float(r.volume)}
dashboard/pages/34_ 📈 Live_Wyckoff_Terminal.py:124:        b = bars_1m if tf == "1Min" else resample_ticks(pd.DataFrame({"mid": bars_1m["close"]}).rename(columns={"mid":"last"}).assign(volume=1.0).set_index(bars_1m.index), tf=tf)
dashboard/pages/34_ 📈 Live_Wyckoff_Terminal.py:163:        low=bars_pm["low"], close=bars_pm["close"], name="OHLC"
redis_architecture/docker-compose.yml:99:  mt5-integration:
redis_architecture/docker-compose.yml:102:      dockerfile: redis_architecture/Dockerfile.mt5
redis_architecture/docker-compose.yml:103:    container_name: zanalytics-mt5
redis_architecture/docker-compose.yml:110:      - ./redis_architecture/mt5_redis_integration.py:/app/mt5_redis_integration.py
redis_architecture/docker-compose.yml:111:      - ./redis_architecture/run_mt5_integration.py:/app/run_mt5_integration.py
redis_architecture/docker-compose.yml:115:    command: python run_mt5_integration.py
knowledge/playbooks/playbook_01_market_open.md:1:# Load latest snapshot from Kafka (mt5.ticks topic)
docs/gpt_llm/ZANZIBAR_AGENT_INSTRUCTIONS.md:179:  - Price context (last close, high, low)
api_integration/api_dashboard_example.py:69:    if 'open' in df.columns and 'close' in df.columns:
api_integration/api_dashboard_example.py:73:    if 'close' in df.columns:
api_integration/api_dashboard_example.py:75:        df['SMA20'] = df['close'].rolling(window=20).mean()
api_integration/api_dashboard_example.py:76:        df['SMA50'] = df['close'].rolling(window=50).mean()
api_integration/api_dashboard_example.py:79:        df['returns'] = df['close'].pct_change() * 100
services/pulse_api/main.py:39:    kind: str = Field(..., example="mt5_trade|analysis|note")
dashboard/pages/pulse_ui_enhanced.py:10:from mt5_bridge import MT5Bridge
dashboard/pages/02_ enhanced_wyckoff_analyzer.py:626:            current_price = df_analysis['close'].iloc[-1]
dashboard/pages/02_ enhanced_wyckoff_analyzer.py:627:            price_change = (df_analysis['close'].iloc[-1] - df_analysis['close'].iloc[0]) / df_analysis['close'].iloc[0] * 100
utils/mt5_ingest.py:6:from utils.mt5_kafka_producer import MT5KafkaProducer
utils/mt5_ingest.py:15:def get_tick_from_mt5() -> dict:
utils/mt5_ingest.py:23:        tick = get_tick_from_mt5()  # <-- your existing MT5 call
dashboard/pages/25_ Position Manager.py:19:    import MetaTrader5 as mt5
dashboard/pages/25_ Position Manager.py:23:    mt5 = None
dashboard/pages/25_ Position Manager.py:155:    if not mt5.terminal_state().connected:
dashboard/pages/25_ Position Manager.py:160:            if not mt5.initialize(login=int(login), password=password, server=server):
dashboard/pages/25_ Position Manager.py:165:    if mt5.terminal_state().connected:
dashboard/pages/25_ Position Manager.py:166:        positions = mt5.positions_get()
dashboard/pages/home.py_old:103:    bars["ret"] = bars["close"].pct_change()
dashboard/pages/home.py_old:105:    ma = bars["close"].rolling(win).mean()
dashboard/pages/home.py_old:106:    sd = bars["close"].rolling(win).std()
dashboard/pages/home.py_old:113:    bars["bb_pctB"] = _nz((bars["close"] - lower) / (upper - lower + 1e-6))
dashboard/pages/home.py_old:150:    col1.metric("Close", enriched["close"].iloc[-1])
dashboard/pages/home.py_old:163:            close=enriched["close"],
redis_architecture/MIGRATION_GUIDE.md:7:3. **Run the MT5 integration** with `python run_mt5_integration.py`.
docs/gpt_llm/actions_bus.md:21:    - TradeItem: `{ id, ts_open?, ts_close?, symbol, side?, entry?, exit?, pnl?, rr?, strategy?, session? }`
utils/entich.py:146:                  (ohlcv_data['close'] < ohlcv_data['open'])
utils/entich.py:163:                         (ohlcv_data['close'] > ohlcv_data['open'])
utils/entich.py:227:            if (curr['close'] < curr['open'] and  # Bearish candle
utils/entich.py:228:                next1['close'] > next1['open'] and  # Bullish candle
utils/entich.py:229:                next2['close'] > next1['close'] and  # Continuation
utils/entich.py:230:                (next2['close'] - curr['open']) / curr['open'] > 0.002):  # 0.2% move
utils/entich.py:233:                body = abs(curr['close'] - curr['open'])
utils/entich.py:247:            elif (curr['close'] > curr['open'] and  # Bullish candle
utils/entich.py:248:                  next1['close'] < next1['open'] and  # Bearish candle
utils/entich.py:249:                  next2['close'] < next1['close'] and  # Continuation
utils/entich.py:250:                  (curr['open'] - next2['close']) / curr['open'] > 0.002):  # 0.2% move
utils/entich.py:252:                body = abs(curr['close'] - curr['open'])
utils/entich.py:657:        "date", "time", "open", "high", "low", "close", "volume"
utils/entich.py:660:    return df[["timestamp", "open", "high", "low", "close", "volume"]].tail(200)
utils/entich.py:788:            current_price = data.iloc[i]['close']
utils/entich.py:792:            positions_to_close = []
utils/entich.py:800:                    positions_to_close.append(pos)
utils/entich.py:806:                    positions_to_close.append(pos)
utils/entich.py:823:                                    positions_to_close.append(pos)
utils/entich.py:832:                                    positions_to_close.append(pos)
utils/entich.py:835:            for pos in positions_to_close:
utils/entich.py:836:                self._close_position(pos)
utils/entich.py:889:            pos['exit_price'] = data.iloc[-1]['close']
utils/entich.py:892:            self._close_position(pos)
utils/entich.py:899:    def _close_position(self, position: Dict):
utils/entich.py:1084:        plt.close()
utils/entich.py:1312:                await self.close_position(position, 'stop_loss', current_price)
utils/entich.py:1318:                    await self.partial_close(position, i+1, tp)
utils/entich.py:1322:                await self.close_position(position, 'stop_loss', current_price)
utils/entich.py:1328:                    await self.partial_close(position, i+1, tp)
utils/entich.py:1330:    async def close_position(self, position: Dict, reason: str, price: float):
utils/entich.py:1333:            # Send close order to broker
utils/entich.py:1334:            await self.send_close_order(position['order_id'], price)
utils/entich.py:1337:            position['status'] = 'closed'
utils/entich.py:1340:            position['closed_at'] = datetime.now()
utils/entich.py:1348:            self.logger.info(f"Position closed: {position['order_id']} - {reason} - P&L: ${position['pnl']:.2f}")
utils/entich.py:1357:            self.logger.error(f"Position close error: {e}")
utils/entich.py:1359:    async def partial_close(self, position: Dict, tp_level: int, price: float):
utils/entich.py:1360:        """Partially close a position at TP level"""
utils/entich.py:1361:        # Partial close percentages
utils/entich.py:1365:            close_quantity = position['quantity'] * partial_percentages[tp_level]
utils/entich.py:1367:            # Send partial close order
utils/entich.py:1368:            await self.send_partial_close_order(
utils/entich.py:1370:                close_quantity, 
utils/entich.py:1376:            position['quantity'] -= close_quantity
utils/entich.py:1378:            self.logger.info(f"Partial close at TP{tp_level}: {close_quantity} units at {price}")
utils/entich.py:1406:        ohlcv['close'] = ticks['bid'].resample(timeframe).last()
utils/entich.py:1418:    async def send_close_order(self, order_id: str, price: float):
utils/entich.py:1419:        """Send close order to broker"""
utils/entich.py:1422:    async def send_partial_close_order(self, order_id: str, quantity: float, price: float):
utils/entich.py:1423:        """Send partial close order to broker"""
utils/entich.py:1424:        self.logger.info(f"Partial close sent: {order_id} - {quantity} units at {price}")
utils/entich.py:1441:                await self.close_position(position, 'shutdown', current_price)
bridge/mt5.py:9:MT5_API_URL = os.environ.get("MT5_API_URL", "http://mt5:5001").rstrip("/")
docs/gpt_llm/GPT_Instructions_1.1.md:12:- Primary: `GET /api/v1/feed/bars-enriched?symbol={SYM}&timeframe=M15&limit=1` (use last bar’s close/time).
docs/gpt_llm/GPT_Instructions_1.1.md:47:- SoD equity = prior session close; override via `POST /api/v1/account/sod` or Redis.
knowledge/playbooks/playbook_03_close_risk.md:1:# Compute day-to-date P&L 15 min before close
dashboard/pages/20_advanced_risk_manager.py:37:    import MetaTrader5 as mt5
dashboard/pages/20_advanced_risk_manager.py:41:    mt5 = None
dashboard/pages/20_advanced_risk_manager.py:384:    mt5_base = getattr(pulse_manager, "mt5_url", None)
dashboard/pages/20_advanced_risk_manager.py:385:    mt5_ok = False
dashboard/pages/20_advanced_risk_manager.py:386:    mt5_detail = ""
dashboard/pages/20_advanced_risk_manager.py:387:    if mt5_base:
dashboard/pages/20_advanced_risk_manager.py:389:            url = f"{str(mt5_base).rstrip('/')}/account_info"
dashboard/pages/20_advanced_risk_manager.py:396:                mt5_ok = isinstance(data, dict) and bool(data)
dashboard/pages/20_advanced_risk_manager.py:399:                mt5_detail = f"{login} {server}" if login != "—" else "OK"
dashboard/pages/20_advanced_risk_manager.py:401:                mt5_detail = f"HTTP {r.status_code}"
dashboard/pages/20_advanced_risk_manager.py:403:            mt5_detail = f"error: {e}"
dashboard/pages/20_advanced_risk_manager.py:405:        mt5_detail = "no URL"
dashboard/pages/20_advanced_risk_manager.py:419:            "UP" if mt5_ok else "DOWN",
dashboard/pages/20_advanced_risk_manager.py:420:            mt5_detail,
dashboard/pages/20_advanced_risk_manager.py:433:        self.mt5_login = os.getenv('MT5_LOGIN')
dashboard/pages/20_advanced_risk_manager.py:434:        self.mt5_password = os.getenv('MT5_PASSWORD')
dashboard/pages/20_advanced_risk_manager.py:435:        self.mt5_server = os.getenv('MT5_SERVER')
dashboard/pages/20_advanced_risk_manager.py:439:        self.mt5_available = MT5_AVAILABLE
dashboard/pages/20_advanced_risk_manager.py:444:        self._mt5_candidates = [
dashboard/pages/20_advanced_risk_manager.py:449:            "http://mt5:5001",
dashboard/pages/20_advanced_risk_manager.py:453:        self.mt5_url = next((u for u in self._mt5_candidates if u), None)
dashboard/pages/20_advanced_risk_manager.py:473:        if not self.mt5_available:
dashboard/pages/20_advanced_risk_manager.py:475:        if not all([self.mt5_login, self.mt5_password, self.mt5_server]):
dashboard/pages/20_advanced_risk_manager.py:479:            if not mt5.initialize():
dashboard/pages/20_advanced_risk_manager.py:482:            authorized = mt5.login(
dashboard/pages/20_advanced_risk_manager.py:483:                login=int(self.mt5_login),
dashboard/pages/20_advanced_risk_manager.py:484:                password=self.mt5_password,
dashboard/pages/20_advanced_risk_manager.py:485:                server=self.mt5_server
dashboard/pages/20_advanced_risk_manager.py:555:        for base in [u for u in self._mt5_candidates if u]:
dashboard/pages/20_advanced_risk_manager.py:569:                        self.mt5_url = base  # lock onto the working base
dashboard/pages/20_advanced_risk_manager.py:579:        if self.mt5_available and all([self.mt5_login, self.mt5_password, self.mt5_server]):
dashboard/pages/20_advanced_risk_manager.py:582:                    if mt5.initialize() and mt5.login(login=int(self.mt5_login), password=self.mt5_password, server=self.mt5_server):
dashboard/pages/20_advanced_risk_manager.py:585:                    ai = mt5.account_info()
dashboard/pages/20_advanced_risk_manager.py:619:            if self.mt5_url:
dashboard/pages/20_advanced_risk_manager.py:620:                r = requests.get(f"{str(self.mt5_url).rstrip('/')}/positions_get", timeout=0.9)
dashboard/pages/20_advanced_risk_manager.py:656:            if self.mt5_available:
dashboard/pages/20_advanced_risk_manager.py:657:                if not self.connected and self.mt5_login and self.mt5_password and self.mt5_server:
dashboard/pages/20_advanced_risk_manager.py:658:                    if mt5.initialize() and mt5.login(login=int(self.mt5_login), password=self.mt5_password, server=self.mt5_server):
dashboard/pages/20_advanced_risk_manager.py:661:                    positions = mt5.positions_get()
dashboard/pages/20_advanced_risk_manager.py:756:                r = requests.get(f"{self.mt5_url}/{ep}", timeout=0.9)
dashboard/pages/20_advanced_risk_manager.py:764:                tcols = [c for c in ["time", "time_msc", "time_done", "time_close"] if c in df.columns]
dashboard/pages/20_advanced_risk_manager.py:1446:            st.info("No trades today — trajectory will appear once trades close.")
dashboard/pages/20_advanced_risk_manager.py:1727:            consumer.close()
dashboard/pages/20_advanced_risk_manager.py:1745:                for col in ["time", "time_msc", "time_done", "time_close", "timestamp"]:
dashboard/pages/20_advanced_risk_manager.py:1748:                            if col in ("time", "time_done", "time_close", "timestamp"):
dashboard/pages/20_advanced_risk_manager.py:1848:        st.info("No trades today — trajectory will appear once trades close.")
dashboard/pages/20_advanced_risk_manager.py:2108:        open=df['Open'], high=df['High'], low=df['Low'], close=df['Close'],
dashboard/pages/20_advanced_risk_manager.py:2171:        mt5b = getattr(pulse_manager, 'mt5_url', None)
dashboard/pages/20_advanced_risk_manager.py:2173:            ok_bridge = requests.get(f"{str(mt5b).rstrip('/')}/account_info", timeout=1.0).ok if mt5b else False
dashboard/pages/20_advanced_risk_manager.py:2212:                            pulse_manager._mt5_candidates = [url_input.strip()] + [u for u in pulse_manager._mt5_candidates if u and u != url_input.strip()]
dashboard/pages/20_advanced_risk_manager.py:2213:                            pulse_manager.mt5_url = url_input.strip()
dashboard/pages/20_advanced_risk_manager.py:2219:                    test_url = (url_input or pulse_manager.mt5_url or "").rstrip('/')
dashboard/pages/20_advanced_risk_manager.py:2354:            st.caption(f"MT5 bridge URL: {getattr(pulse_manager, 'mt5_url', '—')}")
dashboard/pages/20_advanced_risk_manager.py:2556:        bridge_url_display = getattr(pulse_manager, 'mt5_url', '') or os.getenv('MT5_URL') or os.getenv('MT5_API_URL') or '—'
dashboard/pages/20_advanced_risk_manager.py:2558:            if getattr(pulse_manager, 'mt5_url', None):
dashboard/pages/20_advanced_risk_manager.py:2559:                r = requests.get(f"{pulse_manager.mt5_url.rstrip('/')}/health", timeout=1.0)
dashboard/pages/20_advanced_risk_manager.py:2567:        st.caption("SL → BE, trailing lock (25/50/75%), and partial closes will be enabled here.")
dashboard/pages/20_advanced_risk_manager.py:2629:        traw = last_trade.get("time") or last_trade.get("time_close") or last_trade.get("time_done") or last_trade.get("timestamp")
dashboard/pages/20_advanced_risk_manager.py:2744:        trades_today = safe_api_call('GET', 'api/v1/trades/history?window=today&closed_only=true') or []
api_integration/zanflow_api_data_loader.py:113:            for col in ['entry_time', 'close_time']:
redis_architecture/mt5_redis_integration.py:1:import MetaTrader5 as mt5
redis_architecture/mt5_redis_integration.py:22:    def connect_mt5(self) -> bool:
redis_architecture/mt5_redis_integration.py:23:        if not mt5.initialize():
redis_architecture/mt5_redis_integration.py:24:            logger.error(f"MT5 initialization failed: {mt5.last_error()}")
redis_architecture/mt5_redis_integration.py:30:    def disconnect_mt5(self):
redis_architecture/mt5_redis_integration.py:31:        mt5.shutdown()
redis_architecture/mt5_redis_integration.py:38:            mt5.symbol_select(symbol, True)
redis_architecture/mt5_redis_integration.py:44:                    tick = mt5.symbol_info_tick(symbol)
redis_architecture/mt5_redis_integration.py:64:        rates = mt5.copy_rates_from_pos(symbol, timeframe, 0, count)
redis_architecture/mt5_redis_integration.py:99:                df[f'SMA_{period}'] = df['close'].rolling(window=period).mean()
redis_architecture/mt5_redis_integration.py:103:                delta = df['close'].diff()
redis_architecture/mt5_redis_integration.py:113:        info = mt5.account_info()
redis_architecture/mt5_redis_integration.py:130:        positions = mt5.positions_get()
redis_architecture/mt5_redis_integration.py:188:    mt5_redis = MT5RedisIntegration()
redis_architecture/mt5_redis_integration.py:189:    if mt5_redis.connect_mt5():
redis_architecture/mt5_redis_integration.py:190:        import MetaTrader5 as mt5
redis_architecture/mt5_redis_integration.py:192:        timeframes = [mt5.TIMEFRAME_M1, mt5.TIMEFRAME_M5, mt5.TIMEFRAME_H1]
redis_architecture/mt5_redis_integration.py:198:            asyncio.run(mt5_redis.run_data_pipeline(symbols, timeframes, indicators))
redis_architecture/mt5_redis_integration.py:202:            mt5_redis.disconnect_mt5()
dashboard/pages/04_ zanalytics_pulse_streamlit.py:350:            st.info("No trades today — trajectory will appear once trades close.")
dashboard/pages/04_ zanalytics_pulse_streamlit.py:609:        prev_close = risk_env.get('prev_close_equity')
dashboard/pages/04_ zanalytics_pulse_streamlit.py:640:                pv = float(prev_close) if isinstance(prev_close, (int, float, str)) and str(prev_close).strip() != '' else None
knowledge/ zan_flow_1.md:62:- **Invalidation:** M1 candle close above swing high + buffer **or** bullish CHoCH from that swing  
dashboard/pages/09_🔥_Pulse_Wyckoff_Live.py:184:            'close': float(row['close']),
dashboard/pages/09_🔥_Pulse_Wyckoff_Live.py:208:    df['sma'] = df['close'].rolling(win).mean()
dashboard/pages/09_🔥_Pulse_Wyckoff_Live.py:242:    """Convert close prices into a simple equity curve"""
dashboard/pages/09_🔥_Pulse_Wyckoff_Live.py:243:    if df.empty or 'close' not in df:
dashboard/pages/09_🔥_Pulse_Wyckoff_Live.py:245:    returns = df['close'].pct_change().fillna(0)
dashboard/pages/09_🔥_Pulse_Wyckoff_Live.py:401:            low=analyzed_df['low'], close=analyzed_df['close'],
dashboard/pages/09_🔥_Pulse_Wyckoff_Live.py:498:            display_cols = ['open', 'high', 'low', 'close', 'volume', 'phase']
dashboard/pages/09_🔥_Pulse_Wyckoff_Live.py:507:                event_display = events_df[['close', 'volume', 'phase', 'spring', 'upthrust']]
dashboard/pages/09_🔥_Pulse_Wyckoff_Live.py:516:                st.dataframe(vsa_df[['open', 'high', 'low', 'close', 'volume', 'volume_z', 'vsa']], use_container_width=True)
utils/analysis_engines.py:88:            if df['close'].iloc[i] < df['open'].iloc[i]:  # Down candle
utils/analysis_engines.py:91:                if (future_high - df['close'].iloc[i]) / df['close'].iloc[i] > min_move:
utils/analysis_engines.py:98:                        'strength': (future_high - df['close'].iloc[i]) / df['close'].iloc[i]
utils/analysis_engines.py:102:            elif df['close'].iloc[i] > df['open'].iloc[i]:  # Up candle
utils/analysis_engines.py:105:                if (df['close'].iloc[i] - future_low) / df['close'].iloc[i] > min_move:
utils/analysis_engines.py:112:                        'strength': (df['close'].iloc[i] - future_low) / df['close'].iloc[i]
utils/analysis_engines.py:124:            if gap_size > 0 and gap_size / df['close'].iloc[i] > min_gap_size:
utils/analysis_engines.py:137:            if gap_size > 0 and gap_size / df['close'].iloc[i] > min_gap_size:
utils/analysis_engines.py:228:                            reversal = after_max['close'].iloc[-1] < zone['level']
utils/analysis_engines.py:248:                            reversal = after_min['close'].iloc[-1] > zone['level']
utils/analysis_engines.py:274:                if df['close'].iloc[i] > df['open'].iloc[i]:
utils/analysis_engines.py:286:                    'close': df['close'].iloc[i]
utils/analysis_engines.py:363:        avg_price = recent_data['close'].mean()
utils/analysis_engines.py:364:        price_position = (recent_data['close'].iloc[-1] - recent_data['low'].min()) / price_range
utils/analysis_engines.py:372:        sma_20 = recent_data['close'].rolling(20).mean()
utils/analysis_engines.py:373:        sma_50 = recent_data['close'].rolling(50).mean() if len(recent_data) >= 50 else sma_20
utils/analysis_engines.py:383:            if sma_20.iloc[-1] > sma_50.iloc[-1] and recent_data['close'].iloc[-1] > sma_20.iloc[-1]:
utils/analysis_engines.py:385:            elif sma_20.iloc[-1] < sma_50.iloc[-1] and recent_data['close'].iloc[-1] < sma_20.iloc[-1]:
utils/analysis_engines.py:445:        prev_trend = df['close'].iloc[i-50:i].mean() > df['close'].iloc[i-25:i].mean()
utils/analysis_engines.py:457:        price_drop = (df['close'].iloc[i] - df['close'].iloc[i-5]) / df['close'].iloc[i-5] < -0.02
utils/analysis_engines.py:461:            reversal = df['close'].iloc[i+5] > df['close'].iloc[i]
utils/analysis_engines.py:524:                    if df['close'].iloc[i+5] > range_low:
utils/analysis_engines.py:539:                    if df['close'].iloc[i+5] < range_high:
utils/analysis_engines.py:557:            if df['close'].iloc[i] > df['close'].iloc[i-1]:
utils/analysis_engines.py:558:                price_change = (df['close'].iloc[i] - df['close'].iloc[i-5]) / df['close'].iloc[i-5]
utils/analysis_engines.py:566:                        'price': df['close'].iloc[i],
utils/analysis_engines.py:571:            elif df['close'].iloc[i] < df['close'].iloc[i-1]:
utils/analysis_engines.py:572:                price_change = (df['close'].iloc[i] - df['close'].iloc[i-5]) / df['close'].iloc[i-5]
utils/analysis_engines.py:580:                        'price': df['close'].iloc[i],
utils/analysis_engines.py:596:            avg_price = window['close'].mean()
utils/analysis_engines.py:640:            price_change = abs(df['close'].iloc[i] - df['open'].iloc[i]) / df['open'].iloc[i]
utils/analysis_engines.py:667:                    'price_direction': 'up' if df['close'].iloc[i] > df['open'].iloc[i] else 'down'
utils/analysis_engines.py:686:                if df['close'].iloc[breakout_idx + 10] > range_info['high'] * 1.02:
redis_architecture/run_mt5_integration.py:2:from mt5_redis_integration import MT5RedisIntegration
redis_architecture/run_mt5_integration.py:3:import MetaTrader5 as mt5
redis_architecture/run_mt5_integration.py:6:    mt5_redis = MT5RedisIntegration()
redis_architecture/run_mt5_integration.py:7:    if mt5_redis.connect_mt5():
redis_architecture/run_mt5_integration.py:9:        timeframes = [mt5.TIMEFRAME_M1, mt5.TIMEFRAME_M5, mt5.TIMEFRAME_H1]
redis_architecture/run_mt5_integration.py:15:            asyncio.run(mt5_redis.run_data_pipeline(symbols, timeframes, indicators))
redis_architecture/run_mt5_integration.py:19:            mt5_redis.disconnect_mt5()
utils/ncos_realtime_engine.py:207:                await self.close_position(position, 'stop_loss', current_price)
utils/ncos_realtime_engine.py:213:                    await self.partial_close(position, i+1, tp)
utils/ncos_realtime_engine.py:217:                await self.close_position(position, 'stop_loss', current_price)
utils/ncos_realtime_engine.py:223:                    await self.partial_close(position, i+1, tp)
utils/ncos_realtime_engine.py:225:    async def close_position(self, position: Dict, reason: str, price: float):
utils/ncos_realtime_engine.py:228:            # Send close order to broker
utils/ncos_realtime_engine.py:229:            await self.send_close_order(position['order_id'], price)
utils/ncos_realtime_engine.py:232:            position['status'] = 'closed'
utils/ncos_realtime_engine.py:235:            position['closed_at'] = datetime.now()
utils/ncos_realtime_engine.py:243:            self.logger.info(f"Position closed: {position['order_id']} - {reason} - P&L: ${position['pnl']:.2f}")
utils/ncos_realtime_engine.py:252:            self.logger.error(f"Position close error: {e}")
utils/ncos_realtime_engine.py:254:    async def partial_close(self, position: Dict, tp_level: int, price: float):
utils/ncos_realtime_engine.py:255:        """Partially close a position at TP level"""
utils/ncos_realtime_engine.py:256:        # Partial close percentages
utils/ncos_realtime_engine.py:260:            close_quantity = position['quantity'] * partial_percentages[tp_level]
utils/ncos_realtime_engine.py:262:            # Send partial close order
utils/ncos_realtime_engine.py:263:            await self.send_partial_close_order(
utils/ncos_realtime_engine.py:265:                close_quantity, 
utils/ncos_realtime_engine.py:271:            position['quantity'] -= close_quantity
utils/ncos_realtime_engine.py:273:            self.logger.info(f"Partial close at TP{tp_level}: {close_quantity} units at {price}")
utils/ncos_realtime_engine.py:301:        ohlcv['close'] = ticks['bid'].resample(timeframe).last()
utils/ncos_realtime_engine.py:313:    async def send_close_order(self, order_id: str, price: float):
utils/ncos_realtime_engine.py:314:        """Send close order to broker"""
utils/ncos_realtime_engine.py:317:    async def send_partial_close_order(self, order_id: str, quantity: float, price: float):
utils/ncos_realtime_engine.py:318:        """Send partial close order to broker"""
utils/ncos_realtime_engine.py:319:        self.logger.info(f"Partial close sent: {order_id} - {quantity} units at {price}")
utils/ncos_realtime_engine.py:336:                await self.close_position(position, 'shutdown', current_price)
utils/timeframe_converter.py:54:            'close': 'last',
utils/timeframe_converter.py:110:                    'close': df['close'].iloc[last_idx],
utils/ncos_theory_backtester.py:44:            current_price = data.iloc[i]['close']
utils/ncos_theory_backtester.py:48:            positions_to_close = []
utils/ncos_theory_backtester.py:56:                    positions_to_close.append(pos)
utils/ncos_theory_backtester.py:62:                    positions_to_close.append(pos)
utils/ncos_theory_backtester.py:79:                                    positions_to_close.append(pos)
utils/ncos_theory_backtester.py:88:                                    positions_to_close.append(pos)
utils/ncos_theory_backtester.py:91:            for pos in positions_to_close:
utils/ncos_theory_backtester.py:92:                self._close_position(pos)
utils/ncos_theory_backtester.py:145:            pos['exit_price'] = data.iloc[-1]['close']
utils/ncos_theory_backtester.py:148:            self._close_position(pos)
utils/ncos_theory_backtester.py:155:    def _close_position(self, position: Dict):
utils/ncos_theory_backtester.py:340:        plt.close()
knowledge/fvg8am.md:27:- Start processing from the **candle that closes at 08:00 AM London time**.
utils/chart_builder.py:48:                    close=df['close'],
utils/chart_builder.py:63:                    close=ha_df['ha_close'],
utils/chart_builder.py:74:                    y=df['close'],
utils/chart_builder.py:88:            colors = [self.color_scheme['bullish'] if close >= open else self.color_scheme['bearish'] 
utils/chart_builder.py:89:                     for close, open in zip(df['close'], df['open'])]
utils/chart_builder.py:150:        ha_df['ha_close'] = (df['open'] + df['high'] + df['low'] + df['close']) / 4
utils/chart_builder.py:152:        ha_df['ha_open'] = (df['open'].shift(1) + df['close'].shift(1)) / 2
utils/chart_builder.py:153:        ha_df['ha_open'].iloc[0] = (df['open'].iloc[0] + df['close'].iloc[0]) / 2
utils/chart_builder.py:155:        ha_df['ha_high'] = ha_df[['high', 'ha_open', 'ha_close']].max(axis=1)
utils/chart_builder.py:156:        ha_df['ha_low'] = ha_df[['low', 'ha_open', 'ha_close']].min(axis=1)
utils/chart_builder.py:310:                        close=df['close'],
utils/chart_builder.py:322:                    sma = df['close'].rolling(window=sma_period).mean()
utils/chart_builder.py:366:                close=df['close'],
utils/chart_builder.py:747:        close = prices[i]
utils/chart_builder.py:750:        high = close * (1 + abs(np.random.normal(0, 0.0001)))
utils/chart_builder.py:751:        low = close * (1 - abs(np.random.normal(0, 0.0001)))
utils/chart_builder.py:753:        # Open is previous close with small gap
utils/chart_builder.py:755:            open_price = close * (1 + np.random.normal(0, 0.00005))
utils/chart_builder.py:757:            open_price = data[i-1]['close'] * (1 + np.random.normal(0, 0.00005))
utils/chart_builder.py:760:        high = max(high, open_price, close)
utils/chart_builder.py:761:        low = min(low, open_price, close)
utils/chart_builder.py:776:            'close': close,
redis_architecture/tasks.py:81:                'close': df['bid'].iloc[0],
utils/enrichment.py:33:        Resampled bar data with ``open``, ``high``, ``low`` and ``close``
utils/enrichment.py:54:    resampled.columns = ["open", "high", "low", "close"] + (
utils/enrichment.py:80:    elif "close" in df.columns:
utils/enrichment.py:81:        df["mid_price"] = df["close"]
dashboard/pages/06_ 🧭 The Whisperer.py:46:        "- When quoting, include instrument + timeframe + time (e.g., M15 close at 13:45Z)"
dashboard/pages/06_ 🧭 The Whisperer.py:186:    # Fallbacks: account 'balance_initial' or risk 'prev_close_equity'
dashboard/pages/06_ 🧭 The Whisperer.py:194:        inception = risk.get('prev_close_equity') if isinstance(risk, dict) else None
dashboard/pages/06_ 🧭 The Whisperer.py:309:    st.info("No trades today — trajectory will appear once trades close.")
docs/gpt_llm/whisperer_zanflow_pack/strategy/zanflow_structural_flow.json:129:      "checkpoint": "position_closed"
utils/ComprehensiveJSONProcessor.py:224:        if 'close' in main_df.columns:
utils/ComprehensiveJSONProcessor.py:225:            price_col = 'close'
utils/ComprehensiveJSONProcessor.py:226:        elif any(col.endswith('close') for col in main_df.columns):
utils/ComprehensiveJSONProcessor.py:227:            price_col = [col for col in main_df.columns if col.endswith('close')][0]
services/data_accumulator.py:51:    bars.columns = ['bid_open', 'bid_close', 'bid_low', 'bid_high', 'ask_open', 'ask_close', 'ask_low', 'ask_high']
ml_models/xgb_signal_classifier.py:34:        features['returns_1'] = features['close'].pct_change(1)
ml_models/xgb_signal_classifier.py:35:        features['returns_5'] = features['close'].pct_change(5)
ml_models/xgb_signal_classifier.py:36:        features['returns_20'] = features['close'].pct_change(20)
ml_models/xgb_signal_classifier.py:39:        features['rsi_14'] = self._calculate_rsi(features['close'], 14)
ml_models/xgb_signal_classifier.py:40:        features['sma_20'] = features['close'].rolling(20).mean()
ml_models/xgb_signal_classifier.py:41:        features['sma_50'] = features['close'].rolling(50).mean()
ml_models/xgb_signal_classifier.py:42:        features['sma_ratio'] = features['close'] / features['sma_20']
ml_models/xgb_signal_classifier.py:55:        forward_returns = data['close'].pct_change(forward_periods).shift(-forward_periods)
ml_models/xgb_signal_classifier.py:72:        self.feature_columns = [c for c in numeric_columns if c not in ['close', 'open', 'high', 'low']]
dashboard/pages/16_risk_manager.py:25:    import MetaTrader5 as mt5
dashboard/pages/16_risk_manager.py:29:    mt5 = None
dashboard/pages/16_risk_manager.py:341:    Returns (yesterday_open, yesterday_close).
dashboard/pages/16_risk_manager.py:342:    - yesterday_close ≈ today's SOD.
dashboard/pages/16_risk_manager.py:348:    y_close = today_sod  # by definition, today's SOD equals yesterday close
dashboard/pages/16_risk_manager.py:349:    return y_open, y_close
dashboard/pages/16_risk_manager.py:503:    # Intraday equity series (spark) + yesterday opens/close (sparks)
dashboard/pages/16_risk_manager.py:505:    y_open, y_close = get_yesterday_equities(pulse_manager, acct)
dashboard/pages/16_risk_manager.py:523:        st.metric("Previous Session Close Equity", fmt_ccy(y_close or sod_equity, ccy))
dashboard/pages/16_risk_manager.py:553:        # yesterday open/close spark (if available)
dashboard/pages/16_risk_manager.py:557:        if y_close is not None:
dashboard/pages/16_risk_manager.py:558:            y_series.append((datetime.now(), float(y_close)))
dashboard/pages/16_risk_manager.py:610:    Columns kept (when available): time, symbol, type, volume, price_open, price_close, profit, comment.
dashboard/pages/16_risk_manager.py:615:    keep = [c for c in ["time", "symbol", "type", "volume", "price_open", "price_close", "profit", "comment"] if c in df.columns]
dashboard/pages/16_risk_manager.py:662:        self.mt5_login = os.getenv('MT5_LOGIN')
dashboard/pages/16_risk_manager.py:663:        self.mt5_password = os.getenv('MT5_PASSWORD')
dashboard/pages/16_risk_manager.py:664:        self.mt5_server = os.getenv('MT5_SERVER')
dashboard/pages/16_risk_manager.py:668:        self.mt5_available = MT5_AVAILABLE
dashboard/pages/16_risk_manager.py:671:        self.mt5_url = os.getenv("MT5_URL", "http://mt5:5001")
dashboard/pages/16_risk_manager.py:673:        self.using_http_bridge = True if self.mt5_url else False
dashboard/pages/16_risk_manager.py:725:        if not self.mt5_available:
dashboard/pages/16_risk_manager.py:729:        if not all([self.mt5_login, self.mt5_password, self.mt5_server]):
dashboard/pages/16_risk_manager.py:734:            if not mt5.initialize():
dashboard/pages/16_risk_manager.py:737:            authorized = mt5.login(
dashboard/pages/16_risk_manager.py:738:                login=int(self.mt5_login),
dashboard/pages/16_risk_manager.py:739:                password=self.mt5_password,
dashboard/pages/16_risk_manager.py:740:                server=self.mt5_server
dashboard/pages/16_risk_manager.py:758:        if self.mt5_url:
dashboard/pages/16_risk_manager.py:761:                    r = requests.get(f"{self.mt5_url}/account_info", timeout=2.5)
dashboard/pages/16_risk_manager.py:782:        if self.mt5_available and all([self.mt5_login, self.mt5_password, self.mt5_server]):
dashboard/pages/16_risk_manager.py:785:                    if mt5.initialize() and mt5.login(login=int(self.mt5_login), password=self.mt5_password, server=self.mt5_server):
dashboard/pages/16_risk_manager.py:788:                    ai = mt5.account_info()
dashboard/pages/16_risk_manager.py:825:            if self.mt5_url:
dashboard/pages/16_risk_manager.py:826:                r = requests.get(f"{self.mt5_url}/positions_get", timeout=2.0)
dashboard/pages/16_risk_manager.py:865:            if self.mt5_available:
dashboard/pages/16_risk_manager.py:866:                if not self.connected and self.mt5_login and self.mt5_password and self.mt5_server:
dashboard/pages/16_risk_manager.py:867:                    if mt5.initialize() and mt5.login(login=int(self.mt5_login), password=self.mt5_password, server=self.mt5_server):
dashboard/pages/16_risk_manager.py:870:                    positions = mt5.positions_get()
dashboard/pages/16_risk_manager.py:966:    def get_mt5_data(self, endpoint: str) -> Optional[Dict]:
dashboard/pages/16_risk_manager.py:969:            r = requests.get(f"{self.mt5_url}/{endpoint.lstrip('/')}", timeout=2.0)
dashboard/pages/16_risk_manager.py:997:            data = self.get_mt5_data(ep)
dashboard/pages/16_risk_manager.py:1001:                time_cols = [c for c in ["time", "time_msc", "time_done", "time_close"] if c in df.columns]
dashboard/pages/16_risk_manager.py:1294:        mt5_base = getattr(pulse_manager, 'mt5_url', None)
dashboard/pages/16_risk_manager.py:1297:            if mt5_base:
dashboard/pages/16_risk_manager.py:1298:                r4 = requests.get(f"{str(mt5_base).rstrip('/')}/account_info", timeout=1.0)
dashboard/pages/16_risk_manager.py:1352:        y_open, y_close = get_yesterday_equities(pulse_manager, acct)
dashboard/pages/16_risk_manager.py:1362:            prev_close = y_close or sod_equity
dashboard/pages/16_risk_manager.py:1364:                st.metric("Previous Session Close Equity", fmt_ccy(prev_close, ccy))
dashboard/pages/16_risk_manager.py:1405:                    [(datetime.now()-timedelta(days=1), y_open), (datetime.now(), y_close or sod_equity)],
dashboard/pages/16_risk_manager.py:1506:    y_open, y_close = get_yesterday_equities(pulse_manager, account_info)
dashboard/pages/16_risk_manager.py:1512:    if y_open is not None and y_close is not None:
dashboard/pages/16_risk_manager.py:1513:        # two-point sparkline: yesterday open -> yesterday close (today's SOD)
dashboard/pages/16_risk_manager.py:1516:            (datetime.now().replace(hour=0, minute=0, second=0, microsecond=0), float(y_close)),
dashboard/pages/16_risk_manager.py:1518:    elif y_close is not None:
dashboard/pages/16_risk_manager.py:1520:            (datetime.now() - timedelta(days=1), float(y_close)),
dashboard/pages/16_risk_manager.py:1521:            (datetime.now().replace(hour=0, minute=0, second=0, microsecond=0), float(y_close)),
dashboard/pages/16_risk_manager.py:1532:        if y_open is not None and y_close is not None:
dashboard/pages/16_risk_manager.py:1533:            delta = y_close - y_open
dashboard/pages/16_risk_manager.py:1534:            st.caption(f"Δ {fmt_ccy(delta, acct_ccy)}  |  Open {fmt_ccy(y_open, acct_ccy)} → Close {fmt_ccy(y_close, acct_ccy)}")
dashboard/pages/16_risk_manager.py:1567:    prev_close_disp = y_close or sod_equity
dashboard/pages/16_risk_manager.py:1569:        st.metric("Previous Session Close Equity", fmt_ccy(prev_close_disp, acct_ccy))
dashboard/pages/16_risk_manager.py:1793:    mt5_url = None
dashboard/pages/16_risk_manager.py:1795:        if pulse_manager is not None and hasattr(pulse_manager, 'mt5_url') and pulse_manager.mt5_url:
dashboard/pages/16_risk_manager.py:1796:            mt5_url = pulse_manager.mt5_url
dashboard/pages/16_risk_manager.py:1798:        mt5_url = None
dashboard/pages/16_risk_manager.py:1799:    if not mt5_url:
dashboard/pages/16_risk_manager.py:1800:        mt5_url = os.getenv("MT5_URL", "http://mt5:5001")
dashboard/pages/16_risk_manager.py:1809:            r = requests.get(f"{mt5_url}/{ep}", timeout=2.0)
dashboard/pages/16_risk_manager.py:1817:            time_cols = [c for c in ["time", "time_msc", "time_done", "time_close"] if c in df.columns]
docs/gpt_llm/whisperer_zanflow_pack/strategy/zanflow_v17_menu_system.json:222:          "description": "Halt all agents and close positions"
utils/smc_analyzer.py:80:            if df['close'].iloc[i] < df['open'].iloc[i]:  # Down candle
utils/smc_analyzer.py:83:                if (future_high - df['close'].iloc[i]) / df['close'].iloc[i] > min_move:
utils/smc_analyzer.py:90:                        'strength': (future_high - df['close'].iloc[i]) / df['close'].iloc[i]
utils/smc_analyzer.py:94:            elif df['close'].iloc[i] > df['open'].iloc[i]:  # Up candle
utils/smc_analyzer.py:97:                if (df['close'].iloc[i] - future_low) / df['close'].iloc[i] > min_move:
utils/smc_analyzer.py:104:                        'strength': (df['close'].iloc[i] - future_low) / df['close'].iloc[i]
utils/smc_analyzer.py:116:            if gap_size > 0 and gap_size / df['close'].iloc[i] > min_gap_size:
utils/smc_analyzer.py:129:            if gap_size > 0 and gap_size / df['close'].iloc[i] > min_gap_size:
utils/smc_analyzer.py:220:                            reversal = after_max['close'].iloc[-1] < zone['level']
utils/smc_analyzer.py:240:                            reversal = after_min['close'].iloc[-1] > zone['level']
utils/smc_analyzer.py:266:                if df['close'].iloc[i] > df['open'].iloc[i]:
utils/smc_analyzer.py:278:                    'close': df['close'].iloc[i]
INSTALL.md:15:  - POST /api/v1/actions/query with verbs: session_boot, trades_recent, trades_history_mt5, whisper_suggest
INSTALL.md:23:- Hybrid flow tries DB first (trades_recent), then falls back to live MT5 (trades_history_mt5) if DB is empty.
INSTALL.md:29:- Session close scheduler: utils/session_scheduler.py with times in docs/gpt_llm/session_times.yaml
INSTALL.md:33:- Call POST /api/v1/actions/query → { "type": "trades_history_mt5", "payload": { "symbol": "XAUUSD", "date_from": "YYYY-MM-DD" } }
openapi.actions.yaml:29:              trades_history_mt5,
openapi.actions.yaml:89:                    description: trades_history_mt5 result
openapi.actions.yaml:107:              trades_history_mt5,
openapi.actions.yaml:167:                    description: trades_history_mt5 result
openapi.actions.yaml:182:              position_close_half:
openapi.actions.yaml:185:                  type: position_close
openapi.actions.yaml:227:                summary: Journal a partial close
openapi.actions.yaml:248:                    description: trades_history_mt5 result
openapi.actions.yaml:255:  /api/v1/positions/close:
openapi.actions.yaml:258:      operationId: postPositionClose
openapi.actions.yaml:264:              $ref: '#/components/schemas/PositionClosePayload'
openapi.actions.yaml:266:              close_half:
openapi.actions.yaml:271:              close_full:
openapi.actions.yaml:398:        - $ref: '#/components/schemas/PositionCloseRequest'
openapi.actions.yaml:424:          position_close: '#/components/schemas/PositionCloseRequest'
openapi.actions.yaml:430:          trades_history_mt5: '#/components/schemas/TradesHistoryMt5Request'
openapi.actions.yaml:460:              trades_history_mt5,
openapi.actions.yaml:477:              position_close,
openapi.actions.yaml:484:              - $ref: '#/components/schemas/PositionClosePayload'
openapi.actions.yaml:510:    PositionCloseRequest:
openapi.actions.yaml:514:        type: { type: string, const: position_close }
openapi.actions.yaml:515:        payload: { $ref: '#/components/schemas/PositionClosePayload' }
openapi.actions.yaml:556:        type: { type: string, const: trades_history_mt5 }
openapi.actions.yaml:676:    PositionClosePayload:
openapi.actions.yaml:793:        ts_close: { type: string, nullable: true }
openapi.actions.yaml:845:      description: Generic response envelope for position actions (open/close/modify/hedge)
openapi.actions.yaml:858:          description: Bridge result payload for close/modify/hedge
dashboard/pages/21_pulse_pro.py:241:            # SoD and previous close equity readouts
dashboard/pages/21_pulse_pro.py:242:            prev_close = (risk or {}).get("prev_close_equity")
dashboard/pages/21_pulse_pro.py:244:                prev_close_f = float(prev_close) if isinstance(prev_close, (int, float, str)) and str(prev_close).strip() != '' else None
dashboard/pages/21_pulse_pro.py:246:                prev_close_f = None
dashboard/pages/21_pulse_pro.py:251:                st.caption(f"Prev Close: ${prev_close_f:,.0f}" if prev_close_f is not None else "Prev Close: —")
dashboard/pages/21_pulse_pro.py:633:                cols = ["id","symbol","side","entry","exit","pnl","ts_open","ts_close"]
dashboard/pages/21_pulse_pro.py:643:            mt5 = _fetch_trade_history_filtered() if _fetch_trade_history_filtered else []
dashboard/pages/21_pulse_pro.py:645:            _df2 = _pd.DataFrame(mt5 if isinstance(mt5, list) else [])
utils/test_trades_flow.py:36:def test_trades_mt5(date_from: str = "2025-09-01", limit: int = 5):
utils/test_trades_flow.py:41:        json={"type": "trades_history_mt5", "payload": {"date_from": date_from}},
utils/test_trades_flow.py:46:    # trades_history_mt5 returns an array of history items
utils/test_trades_flow.py:60:            _ = test_trades_mt5()
docs/gpt_llm/whisperer_zanflow_pack/whisperer_zanflow_master.yaml:146:  session_close_debrief:
docs/gpt_llm/whisperer_zanflow_pack/whisperer_zanflow_master.yaml:157:  show_closed_trades:
docs/gpt_llm/whisperer_zanflow_pack/whisperer_zanflow_master.yaml:158:    input: "Show my last {limit} closed trades"
docs/gpt_llm/whisperer_zanflow_pack/whisperer_zanflow_master.yaml:165:          body: { type: trades_history_mt5, payload: { date_from: "2025-09-01" } }
docs/gpt_llm/whisperer_zanflow_pack/whisperer_zanflow_master.yaml:170:      No closed trades available yet.
docs/gpt_llm/whisperer_zanflow_pack/whisperer_zanflow_master.yaml:205:  - Produce session close debrief and ZBAR journal entry
utils/technical_analysis.py:18:        if df.empty or df['close'].nunique() <= 1:
utils/technical_analysis.py:25:        results['sma_20'] = ta.trend.sma_indicator(df['close'], window=20)
utils/technical_analysis.py:26:        results['sma_50'] = ta.trend.sma_indicator(df['close'], window=50)
utils/technical_analysis.py:27:        results['sma_200'] = ta.trend.sma_indicator(df['close'], window=200)
utils/technical_analysis.py:28:        results['ema_20'] = ta.trend.ema_indicator(df['close'], window=20)
utils/technical_analysis.py:29:        results['ema_50'] = ta.trend.ema_indicator(df['close'], window=50)
utils/technical_analysis.py:32:        macd = ta.trend.MACD(df['close'])
utils/technical_analysis.py:38:        results['rsi'] = ta.momentum.RSIIndicator(df['close']).rsi()
utils/technical_analysis.py:41:        bb = ta.volatility.BollingerBands(df['close'])
utils/technical_analysis.py:48:        results['atr'] = ta.volatility.AverageTrueRange(df['high'], df['low'], df['close']).average_true_range()
utils/technical_analysis.py:52:        results['mfi'] = ta.volume.MFIIndicator(df['high'], df['low'], df['close'], df['volume']).money_flow_index()
utils/technical_analysis.py:84:            'resistance': [l for l in levels if l > df['close'].iloc[-1]],
utils/technical_analysis.py:85:            'support': [l for l in levels if l < df['close'].iloc[-1]]
utils/technical_analysis.py:112:        close = df['close'].iloc[-1]
utils/technical_analysis.py:115:        pp = (high + low + close) / 3
utils/technical_analysis.py:140:        close_prices = df['close'].values
utils/technical_analysis.py:143:        body_size = abs(close_prices - open_prices)
utils/technical_analysis.py:149:        lower_shadow = np.minimum(open_prices, close_prices) - low_prices
utils/technical_analysis.py:150:        upper_shadow = high_prices - np.maximum(open_prices, close_prices)
utils/technical_analysis.py:155:                (close_prices[1:] > open_prices[1:]) &
utils/technical_analysis.py:156:                (close_prices[:-1] < open_prices[:-1]) &
utils/technical_analysis.py:157:                (open_prices[1:] < close_prices[:-1]) &
utils/technical_analysis.py:158:                (close_prices[1:] > open_prices[:-1])
utils/technical_analysis.py:188:            sma_20 = ta.trend.sma_indicator(df['close'], window=20)
utils/technical_analysis.py:189:            sma_50 = ta.trend.sma_indicator(df['close'], window=50)
utils/technical_analysis.py:192:                current_price = df['close'].iloc[-1]
utils/technical_analysis.py:206:            rsi = ta.momentum.RSIIndicator(df['close']).rsi()
dashboard/_mix/dashboard_mt5.py:40:def get_mt5_data(r, symbol="XAUUSD"):
dashboard/_mix/dashboard_mt5.py:46:        key = f"mt5:{symbol}:latest"
dashboard/_mix/dashboard_mt5.py:55:def get_mt5_history(r, symbol="EURUSD", limit=50):
dashboard/_mix/dashboard_mt5.py:60:        key = f"mt5:{symbol}:history"
dashboard/_mix/dashboard_mt5.py:93:        latest_data = get_mt5_data(r, symbol)
dashboard/_mix/dashboard_mt5.py:216:                            close=df_c['close'],
dashboard/_mix/dashboard_mt5.py:232:            history = get_mt5_history(r, symbol)
agents/analyzers.py:45:    bos = smc.bos_choch(work, swing, close_break=True)
tests/test_news_mtf_edges.py:20:            "close": p,
utils/wyckoff_analyzer.py:34:        avg_price = recent_data['close'].mean()
utils/wyckoff_analyzer.py:35:        price_position = (recent_data['close'].iloc[-1] - recent_data['low'].min()) / price_range
utils/wyckoff_analyzer.py:43:        sma_20 = recent_data['close'].rolling(20).mean()
utils/wyckoff_analyzer.py:44:        sma_50 = recent_data['close'].rolling(50).mean() if len(recent_data) >= 50 else sma_20
utils/wyckoff_analyzer.py:54:            if sma_20.iloc[-1] > sma_50.iloc[-1] and recent_data['close'].iloc[-1] > sma_20.iloc[-1]:
utils/wyckoff_analyzer.py:56:            elif sma_20.iloc[-1] < sma_50.iloc[-1] and recent_data['close'].iloc[-1] < sma_20.iloc[-1]:
utils/wyckoff_analyzer.py:116:        prev_trend = df['close'].iloc[i-50:i].mean() > df['close'].iloc[i-25:i].mean()
utils/wyckoff_analyzer.py:128:        price_drop = (df['close'].iloc[i] - df['close'].iloc[i-5]) / df['close'].iloc[i-5] < -0.02
utils/wyckoff_analyzer.py:132:            reversal = df['close'].iloc[i+5] > df['close'].iloc[i]
utils/wyckoff_analyzer.py:195:                    if df['close'].iloc[i+5] > range_low:
utils/wyckoff_analyzer.py:210:                    if df['close'].iloc[i+5] < range_high:
utils/wyckoff_analyzer.py:228:            if df['close'].iloc[i] > df['close'].iloc[i-1]:
utils/wyckoff_analyzer.py:229:                price_change = (df['close'].iloc[i] - df['close'].iloc[i-5]) / df['close'].iloc[i-5]
utils/wyckoff_analyzer.py:237:                        'price': df['close'].iloc[i],
utils/wyckoff_analyzer.py:242:            elif df['close'].iloc[i] < df['close'].iloc[i-1]:
utils/wyckoff_analyzer.py:243:                price_change = (df['close'].iloc[i] - df['close'].iloc[i-5]) / df['close'].iloc[i-5]
utils/wyckoff_analyzer.py:251:                        'price': df['close'].iloc[i],
utils/wyckoff_analyzer.py:267:            avg_price = window['close'].mean()
utils/wyckoff_analyzer.py:311:            price_change = abs(df['close'].iloc[i] - df['open'].iloc[i]) / df['open'].iloc[i]
utils/wyckoff_analyzer.py:338:                    'price_direction': 'up' if df['close'].iloc[i] > df['open'].iloc[i] else 'down'
utils/wyckoff_analyzer.py:357:                if df['close'].iloc[breakout_idx + 10] > range_info['high'] * 1.02:
PULSE_INTEGRATION_PLAN.md:366:        'close': 1.0865,
dashboard/_mix/strategy_editor.py:499:        if st.button("Close", key="close_backups"):
dashboard/_mix/4_〽️ Comprehensive Market Analysis.py_:298:        required_cols = ['open', 'high', 'low', 'close']
dashboard/_mix/4_〽️ Comprehensive Market Analysis.py_:346:    if df.empty or not all(col in df.columns for col in ['open', 'high', 'low', 'close']):
dashboard/_mix/4_〽️ Comprehensive Market Analysis.py_:351:        df['sma_20'] = df['close'].rolling(20).mean()
dashboard/_mix/4_〽️ Comprehensive Market Analysis.py_:352:        df['sma_50'] = df['close'].rolling(50).mean()
dashboard/_mix/4_〽️ Comprehensive Market Analysis.py_:353:        df['ema_12'] = df['close'].ewm(span=12).mean()
dashboard/_mix/4_〽️ Comprehensive Market Analysis.py_:354:        df['ema_26'] = df['close'].ewm(span=26).mean()
dashboard/_mix/4_〽️ Comprehensive Market Analysis.py_:357:        delta = df['close'].diff()
dashboard/_mix/4_〽️ Comprehensive Market Analysis.py_:369:        df['bb_middle'] = df['close'].rolling(20).mean()
dashboard/_mix/4_〽️ Comprehensive Market Analysis.py_:370:        bb_std = df['close'].rolling(20).std()
dashboard/_mix/4_〽️ Comprehensive Market Analysis.py_:376:        high_close = np.abs(df['high'] - df['close'].shift())
dashboard/_mix/4_〽️ Comprehensive Market Analysis.py_:377:        low_close = np.abs(df['low'] - df['close'].shift())
dashboard/_mix/4_〽️ Comprehensive Market Analysis.py_:378:        ranges = pd.concat([high_low, high_close, low_close], axis=1)
dashboard/_mix/4_〽️ Comprehensive Market Analysis.py_:404:        df['breakout_up'] = (df['close'] > df['resistance'].shift(1)) & (df['close'].shift(1) <= df['resistance'].shift(2))
dashboard/_mix/4_〽️ Comprehensive Market Analysis.py_:405:        df['breakout_down'] = (df['close'] < df['support'].shift(1)) & (df['close'].shift(1) >= df['support'].shift(2))
dashboard/_mix/4_〽️ Comprehensive Market Analysis.py_:446:            close=df['close'],
dashboard/_mix/4_〽️ Comprehensive Market Analysis.py_:515:                    y=golden_cross_points['close'],
dashboard/_mix/4_〽️ Comprehensive Market Analysis.py_:530:                    y=death_cross_points['close'],
dashboard/_mix/4_〽️ Comprehensive Market Analysis.py_:584:        colors = ['red' if close < open_price else 'green'
dashboard/_mix/4_〽️ Comprehensive Market Analysis.py_:585:                 for close, open_price in zip(df['close'], df['open'])]
dashboard/_mix/4_〽️ Comprehensive Market Analysis.py_:776:            price_change = ((df['close'].iloc[-1] - df['close'].iloc[0]) / df['close'].iloc[0]) * 100
dashboard/_mix/4_〽️ Comprehensive Market Analysis.py_:817:            price_changes = df['close'].diff().dropna()
dashboard/_mix/4_〽️ Comprehensive Market Analysis.py_:842:            returns = df['close'].pct_change().dropna()
dashboard/_mix/4_〽️ Comprehensive Market Analysis.py_:873:                    'Price': df.loc[idx, 'close'],
dashboard/_mix/4_〽️ Comprehensive Market Analysis.py_:883:                    'Price': df.loc[idx, 'close'],
docs/SoD_Equity_Snapshot.md:11:  - `GET /api/v1/account/risk` → keys: `sod_equity`, `prev_close_equity`
docs/SoD_Equity_Snapshot.md:36:   - `GET /api/v1/account/risk` → includes `sod_equity`, `prev_close_equity`
dashboard/_mix/⏱️ Multi-Timeframe Indicators.py:226:        rename_map = {'o': 'open', 'h': 'high', 'l': 'low', 'c': 'close', 'v': 'volume'}
dashboard/_mix/⏱️ Multi-Timeframe Indicators.py:303:            df.rename(columns={'o': 'open', 'h': 'high', 'l': 'low', 'c': 'close', 'v': 'volume'}, inplace=True)
dashboard/_mix/⏱️ Multi-Timeframe Indicators.py:306:            if 'rsi_14' not in df.columns and 'close' in df.columns and len(df) >= 15:
dashboard/_mix/⏱️ Multi-Timeframe Indicators.py:307:                delta = df['close'].diff()
dashboard/_mix/⏱️ Multi-Timeframe Indicators.py:314:            if 'atr_14' not in df.columns and all(c in df.columns for c in ['high', 'low', 'close']) and len(df) >= 14:
dashboard/_mix/⏱️ Multi-Timeframe Indicators.py:316:                high_close = abs(df['high'] - df['close'].shift())
dashboard/_mix/⏱️ Multi-Timeframe Indicators.py:317:                low_close = abs(df['low'] - df['close'].shift())
dashboard/_mix/⏱️ Multi-Timeframe Indicators.py:318:                tr = pd.concat([high_low, high_close, low_close], axis=1).max(axis=1)
services/kafka_tick_to_bar.py:67:            c.close()
dashboard/pages/components/profit_horizon_panel.py:14:        st.info("No closed trades yet.")
knowledge/Strategy inducement_sweep_poi.txt:124:Order Block (OB): Defined as the last down-close candle before a significant impulsive up-move (bullish OB), or the last up-close candle before a significant impulsive down-move (bearish OB). An OB is considered valid, particularly if it led directly to a Break of Structure (BoS). The theory is that the impulsive move away from the OB signifies large orders overwhelming counter-flow, potentially leaving unfilled institutional orders at the OB level that smart money may wish to mitigate upon price return.
knowledge/Strategy inducement_sweep_poi.txt:131:A potential complexity arises from the existence of multiple POI types, which may occur in close proximity within a potential reaction zone. For instance, an area might contain a Wick, an FVG, and the remnants of an Order Block. The strategy necessitates clear rules or contextual understanding to prioritize these overlapping zones, possibly relying on factors like confluence with other signals or requiring lower-timeframe confirmation to pinpoint the most probable reaction level. The following table provides a comparative overview:
knowledge/Strategy inducement_sweep_poi.txt:170:Once these two points—a confirmed Strong High and a confirmed Strong Low—are identified, they establish the upper and lower boundaries of the current valid trading range. This range remains operative as long as neither boundary is violated by a body close of a candle on the analysis timeframe. While price may temporarily wick beyond (sweep) the Strong High or Strong Low, a candle closing beyond these levels typically invalidates the current range and signals a potential shift in the overarching market structure, necessitating a reassessment to identify the new operative range. The robustness and objectivity of the Strong/Weak High/Low definitions are therefore critical, as any ambiguity in identifying these points directly impacts the validity of the entire range analysis that follows.
knowledge/Strategy inducement_sweep_poi.txt:181:The dynamic interplay between IRL and ERL provides a narrative for how price is expected to navigate within the range. Price movement is rarely linear from one boundary to the other. Instead, it is theorized to flow between targeting IRL and eventually aiming for ERL. For example, after price mitigates a valid POI in the Discount zone (in an expected uptrend), it might first be drawn towards nearby IRL targets, such as a weak intra-range high or an FVG situated closer to the Equilibrium level. Sweeping this IRL might then provide the 'fuel' for the next leg up, potentially involving another minor pullback before the larger move towards the ultimate ERL target (the Strong High of the range) commences. Understanding this dynamic is crucial for setting realistic intermediate profit targets (at IRL levels) and managing trades effectively as price progresses towards the final objective (ERL). It helps explain complex corrective structures and periods of ranging within the larger structural context.
knowledge/Strategy inducement_sweep_poi.txt:216:The integration of these time-based concepts acts as a powerful filter. The core execution sequence is the necessary micro-pattern, the MTA framework provides the essential macro-context (directional bias, valid zones), and the Time & Price elements offer a temporal filter, highlighting specific windows (Kill Zones) and patterns (Judas Swing, AMD cycle) where high-probability setups are more likely to occur. Optimal trade setups ideally exhibit confluence across all three dimensions: the right pattern, at the right place, at the right time. The reliance on Kill Zones and session-specific patterns like the Judas Swing implies a belief that market behavior is not uniform but exhibits predictable, cyclical tendencies linked to institutional activity around major market opens and closes. The AMD cycle further provides a narrative structure that connects these session dynamics, viewing Asian ranging as Accumulation, the London sweep as Manipulation, and the subsequent trend as Distribution.
knowledge/Strategy inducement_sweep_poi.txt:264:FVG Respect/Rejection: Price creates a small LTF FVG in the intended direction after tapping the POI, then pulls back slightly and respects this FVG (fails to close within it) before continuing.
knowledge/Strategy inducement_sweep_poi.txt:272:Rationale: The logic is based on the strategy's market structure definition. If price achieves a body close beyond this protecting Strong High/Low, the underlying structural premise for the trade's direction is considered invalidated.
knowledge/Strategy inducement_sweep_poi.txt:311:Execution: The entry can be planned directly within the price range of the wick itself. Common tactics include placing a limit order at the 50% level of the wick's length or aiming for a level closer to the wick's extreme (furthest point reached by price). The stop loss is typically placed very tightly, just beyond the absolute end of the wick.
knowledge/Strategy inducement_sweep_poi.txt:334:Potential complexities include the ambiguity arising from multiple POI types in close proximity, the subjective element in identifying confirmation signals or assessing setup confidence, and the inherent challenges of trading counter-trend hedging setups. The successful implementation of this strategy likely requires significant screen time, rigorous adherence to the defined rules, strong pattern recognition skills, and unwavering discipline in risk management. Its effectiveness ultimately depends on the validity of its core assumptions about market dynamics and the consistent application of its structured analytical process.
tests/test_analyzers.py:12:        {"open": 1, "high": 1, "low": 0.5, "close": 0.8},
tests/test_analyzers.py:13:        {"open": 0.8, "high": 5, "low": 0.5, "close": 4},
tests/test_analyzers.py:14:        {"open": 4, "high": 10, "low": 3, "close": 8},
tests/test_analyzers.py:15:        {"open": 8, "high": 5, "low": 3, "close": 4},
tests/test_analyzers.py:16:        {"open": 4, "high": 1, "low": 0.5, "close": 0.8},
tests/test_analyzers.py:22:        {"open": 1.00, "high": 2.0, "low": 0.5, "close": 1.5},
tests/test_analyzers.py:23:        {"open": 1.60, "high": 2.5, "low": 1.2, "close": 2.2},
tests/test_analyzers.py:24:        {"open": 2.30, "high": 2.4, "low": 1.0, "close": 1.1},
tests/test_analyzers.py:25:        {"open": 1.20, "high": 1.3, "low": 0.8, "close": 0.9},
tests/test_analyzers.py:26:        {"open": 0.95, "high": 1.1, "low": 0.7, "close": 1.0},
tests/test_analyzers.py:27:        {"open": 1.05, "high": 1.6, "low": 0.9, "close": 1.5},
tests/test_analyzers.py:28:        {"open": 1.55, "high": 1.7, "low": 1.2, "close": 1.3},
dashboard/_mix/live_trading_dashboard_2.py:78:            key = f"mt5:{symbol}:latest"
dashboard/_mix/live_trading_dashboard_2.py:92:            key = f"mt5:{symbol}:history"
dashboard/_mix/live_trading_dashboard_2.py:104:            keys = self.redis_client.keys("mt5:*:latest")
dashboard/_mix/live_trading_dashboard_2.py:368:                st.metric("Price", f"{df['close'].iloc[-1]:.5f}")
dashboard/_mix/live_trading_dashboard_2.py:370:                price_change = ((df['close'].iloc[-1] / df['close'].iloc[0]) - 1) * 100 if len(df) > 1 else 0
dashboard/_mix/live_trading_dashboard_2.py:470:        """Create enhanced live tick chart similar to dashboard_mt5.py but with more features"""
services/yf_client.py:35:    c = q.get("close") or []
services/yf_client.py:48:            "close": float(c[i]),
dashboard/_mix/wyckof.py:62:            y=df['close'],
dashboard/_mix/wyckof.py:440:                current_price = df['close'].iloc[-1]
dashboard/_mix/wyckof.py:441:                price_change = ((df['close'].iloc[-1] - df['close'].iloc[0]) / df['close'].iloc[0]) * 100
tests/test_wyckoff_adaptive.py:17:            "close": 1.0,
services/ingest/ingest_service.py:41:    from adapters.mt5_client import MT5AsyncClient  # local import to avoid hard dep
services/ingest/ingest_service.py:44:    mt5 = MT5AsyncClient(auto_reconnect=True)  # implement reconnect with backoff
services/ingest/ingest_service.py:49:    async for tick in mt5.stream_ticks():  # yields dict: {symbol, bid, ask, ts, volume}
tests/test_mt5_proxy_views.py:41:    monkeypatch.setenv("MT5_API_URL", "http://mt5.test")
tests/test_mt5_proxy_views.py:54:    assert calls["url"] == "http://mt5.test/positions_get"
tests/test_mt5_proxy_views.py:59:    monkeypatch.setenv("MT5_API_URL", "http://mt5.test")
tests/test_mt5_proxy_views.py:72:    assert calls["url"] == "http://mt5.test/account_info"
tests/test_wyckoff_edges.py:17:        "close": price, "volume": float(vol)
tests/test_wyckoff_edges.py:20:        df.loc[df.index[10:15], 'close'] = np.nan
tests/test_wyckoff_edges.py:47:    df.loc[spike_time, 'high'] = df.loc[spike_time, 'close'] * 1.03
tests/test_wyckoff_edges.py:48:    df.loc[spike_time, 'close'] = df.loc[spike_time, 'close'] * 1.02
docs/gpt_llm/README.md:76:- Prompt: "Show my last {limit} closed trades"
docs/gpt_llm/README.md:77:- Flow tries DB first (`trades_recent`), then falls back to live MT5 (`trades_history_mt5`) when DB is empty.
services/bars_reconcile.py:57:            c.close()
docs/gpt_llm/whisperer_zanflow_pack/constitutional/ZANZIBAR_AGENT_INSTRUCTIONS.md:179:  - Price context (last close, high, low)
docs/VERBS_CATALOG.md:13:- Positions: position_open, position_close, position_modify, position_hedge
docs/VERBS_CATALOG.md:35:position_close
docs/VERBS_CATALOG.md:43:  - Defaults to full close when neither fraction nor volume is provided.
docs/VERBS_CATALOG.md:46:{ "type": "position_close", "payload": { "ticket": 302402468, "fraction": 0.5 } }
docs/VERBS_CATALOG.md:171:- Send `X-Idempotency-Key` header on mutating actions (open/close/modify/hedge, journal_append) to dedupe retries.
tests/test_history_mt5_proxies.py:41:    monkeypatch.setenv("MT5_API_URL", "http://mt5.test")
tests/test_history_mt5_proxies.py:54:    assert calls["url"] == "http://mt5.test/history_deals_get"
tests/test_history_mt5_proxies.py:60:    monkeypatch.setenv("MT5_API_URL", "http://mt5.test")
tests/test_history_mt5_proxies.py:73:    assert calls["url"] == "http://mt5.test/history_orders_get"
tests/test_positions_modify.py:16:import bridge.mt5 as mt5_bridge
tests/test_positions_modify.py:43:    monkeypatch.setattr(mt5_bridge, "requests", fake_requests)
docs/POSITIONS_AND_ORDERS.md:5:- Friendly aliases (Django): `/api/v1/positions/{open,close,modify,hedge}`
docs/POSITIONS_AND_ORDERS.md:6:- Core orders proxy: `/api/v1/orders/{market,modify,close}` (truth; talks to MT5 bridge)
docs/POSITIONS_AND_ORDERS.md:7:- MT5 bridge (Flask): `/send_market_order`, `/partial_close_v2`, `/scale_position`, `/hedge`
docs/POSITIONS_AND_ORDERS.md:13:- Close full/partial: POST `/api/v1/positions/close`
docs/POSITIONS_AND_ORDERS.md:23:- `position_open`, `position_close`, `position_modify`, `position_hedge`
docs/POSITIONS_AND_ORDERS.md:30:Partial close behavior
docs/POSITIONS_AND_ORDERS.md:32:- Bridge endpoint `/partial_close_v2` can compute volume from fraction and ticket.
docs/POSITIONS_AND_ORDERS.md:43:  curl -sX POST "$DJANGO/api/v1/positions/close" \
tests/test_real_ingestion.py:12:def test_mt5_to_kernel_precision() -> None:
tests/test_real_ingestion.py:16:        kernel.connect_mt5()
tests/test_pulse_integration.py:22:        'close': 1.0865,
fix_all_issues.sh:63:for service in django celery celery-beat redis mt5; do
dashboard/_mix/🧠 SMC.py:288:                sma20 = df['close'].rolling(20).mean()
dashboard/_mix/🧠 SMC.py:289:                sma50 = df['close'].rolling(50).mean()
dashboard/_mix/🧠 SMC.py:302:                price_bins = pd.cut(df['close'], bins=10)
dashboard/_mix/🧠 SMC.py:336:                close=df['close'],
dashboard/_mix/🧠 SMC.py:344:            colors = [self.config.colors['bullish'] if row['close'] >= row['open'] else self.config.colors['bearish'] 
dashboard/_mix/🧠 SMC.py:703:        current_price = df['close'].iloc[-1]
dashboard/_mix/🧠 SMC.py:704:        prev_close = df['close'].iloc[-2] if len(df) > 1 else current_price
dashboard/_mix/🧠 SMC.py:705:        change = current_price - prev_close
dashboard/_mix/🧠 SMC.py:706:        change_pct = (change / prev_close * 100) if prev_close != 0 else 0
dashboard/_mix/🧠 SMC.py:889:                    "latest_price": float(df['close'].iloc[-1]),
dashboard/_mix/🧠 SMC.py:929:                returns = df['close'].pct_change().dropna()
dashboard/_mix/🧠 SMC.py:946:                              if s['type'] == 'buy' and df['close'].iloc[-1] > s.get('price', 0))
_new/pulse_ui_enhanced.py:7:from mt5_bridge import MT5Bridge
tests/test_bars_enriched_endpoint.py:44:        "close": range(1, 61),
dashboard/_mix/wyckof copy.py:85:        close=df['close'],
dashboard/_mix/zanalytics_market_monitor.py:80:            current_price = df['close'].iloc[-1]
dashboard/_mix/zanalytics_market_monitor.py:163:            returns = df['close'].pct_change()
dashboard/_mix/zanalytics_market_monitor.py:201:            delta = df['close'].diff()
dashboard/_mix/zanalytics_market_monitor.py:242:            exp1 = df['close'].ewm(span=12, adjust=False).mean()
dashboard/_mix/zanalytics_market_monitor.py:243:            exp2 = df['close'].ewm(span=26, adjust=False).mean()
dashboard/_mix/zanalytics_market_monitor.py:516:            'close': np.random.randn(len(dates)).cumsum() + 50000,
dashboard/_mix/multi_asset_tick_dashboard.py:81:        keys = r.keys("mt5:*:latest")
dashboard/_mix/multi_asset_tick_dashboard.py:93:            latest = r.get(f"mt5:{symbol}:latest")
dashboard/_mix/multi_asset_tick_dashboard.py:103:            ticks = r.lrange(f"mt5:{symbol}:ticks", 0, count-1)
dashboard/_mix/6_ 🚀 Ultimate Analysis.py:91:            key = f"mt5:{symbol}:ticks"
dashboard/_mix/6_ 🚀 Ultimate Analysis.py:689:            st.metric("Current Price", f"{df['close'].iloc[-1]:.5f}")
dashboard/_mix/6_ 🚀 Ultimate Analysis.py:692:            price_change = df['close'].iloc[-1] - df['close'].iloc[0]
dashboard/_mix/6_ 🚀 Ultimate Analysis.py:700:            volatility = df['close'].pct_change().std()
dashboard/_mix/6_ 🚀 Ultimate Analysis.py:711:            close=df['close'],
tests/test_backtesting.py:6:    data = pd.DataFrame({'close': [i for i in range(60)]})
tests/test_wyckoff_extras.py:14:    return pd.DataFrame({"open": p, "high": p * 1.002, "low": p * 0.998, "close": p, "volume": v}, index=idx)
tests/test_wyckoff_extras.py:19:    df.loc[df.index[100], "close"] = df["close"].iloc[99] * 1.01
tests/test_ml_models.py:16:    df = pd.DataFrame({'close': [1,2,3,4,5,6,7,8,9,10]})
_new/risk_enforcer.py:139:        # Warning if close to limit
dashboard/pages/19_advanced_risk_manager.py:38:    import MetaTrader5 as mt5
dashboard/pages/19_advanced_risk_manager.py:42:    mt5 = None
dashboard/pages/19_advanced_risk_manager.py:544:    mt5_base = getattr(pulse_manager, "mt5_url", None)
dashboard/pages/19_advanced_risk_manager.py:545:    mt5_ok = False
dashboard/pages/19_advanced_risk_manager.py:546:    mt5_detail = ""
dashboard/pages/19_advanced_risk_manager.py:547:    if mt5_base:
dashboard/pages/19_advanced_risk_manager.py:549:            url = f"{str(mt5_base).rstrip('/')}/account_info"
dashboard/pages/19_advanced_risk_manager.py:556:                mt5_ok = isinstance(data, dict) and bool(data)
dashboard/pages/19_advanced_risk_manager.py:559:                mt5_detail = f"{login} {server}" if login != "—" else "OK"
dashboard/pages/19_advanced_risk_manager.py:561:                mt5_detail = f"HTTP {r.status_code}"
dashboard/pages/19_advanced_risk_manager.py:563:            mt5_detail = f"error: {e}"
dashboard/pages/19_advanced_risk_manager.py:565:        mt5_detail = "no URL"
dashboard/pages/19_advanced_risk_manager.py:579:            "UP" if mt5_ok else "DOWN",
dashboard/pages/19_advanced_risk_manager.py:580:            mt5_detail,
dashboard/pages/19_advanced_risk_manager.py:593:        self.mt5_login = os.getenv('MT5_LOGIN')
dashboard/pages/19_advanced_risk_manager.py:594:        self.mt5_password = os.getenv('MT5_PASSWORD')
dashboard/pages/19_advanced_risk_manager.py:595:        self.mt5_server = os.getenv('MT5_SERVER')
dashboard/pages/19_advanced_risk_manager.py:599:        self.mt5_available = MT5_AVAILABLE
dashboard/pages/19_advanced_risk_manager.py:604:        self._mt5_candidates = [
dashboard/pages/19_advanced_risk_manager.py:609:            "http://mt5:5001",
dashboard/pages/19_advanced_risk_manager.py:613:        self.mt5_url = next((u for u in self._mt5_candidates if u), None)
dashboard/pages/19_advanced_risk_manager.py:633:        if not self.mt5_available:
dashboard/pages/19_advanced_risk_manager.py:635:        if not all([self.mt5_login, self.mt5_password, self.mt5_server]):
dashboard/pages/19_advanced_risk_manager.py:639:            if not mt5.initialize():
dashboard/pages/19_advanced_risk_manager.py:642:            authorized = mt5.login(
dashboard/pages/19_advanced_risk_manager.py:643:                login=int(self.mt5_login),
dashboard/pages/19_advanced_risk_manager.py:644:                password=self.mt5_password,
dashboard/pages/19_advanced_risk_manager.py:645:                server=self.mt5_server
dashboard/pages/19_advanced_risk_manager.py:715:        for base in [u for u in self._mt5_candidates if u]:
dashboard/pages/19_advanced_risk_manager.py:729:                        self.mt5_url = base  # lock onto the working base
dashboard/pages/19_advanced_risk_manager.py:739:        if self.mt5_available and all([self.mt5_login, self.mt5_password, self.mt5_server]):
dashboard/pages/19_advanced_risk_manager.py:742:                    if mt5.initialize() and mt5.login(login=int(self.mt5_login), password=self.mt5_password, server=self.mt5_server):
dashboard/pages/19_advanced_risk_manager.py:745:                    ai = mt5.account_info()
dashboard/pages/19_advanced_risk_manager.py:779:            if self.mt5_url:
dashboard/pages/19_advanced_risk_manager.py:780:                r = requests.get(f"{str(self.mt5_url).rstrip('/')}/positions_get", timeout=0.9)
dashboard/pages/19_advanced_risk_manager.py:816:            if self.mt5_available:
dashboard/pages/19_advanced_risk_manager.py:817:                if not self.connected and self.mt5_login and self.mt5_password and self.mt5_server:
dashboard/pages/19_advanced_risk_manager.py:818:                    if mt5.initialize() and mt5.login(login=int(self.mt5_login), password=self.mt5_password, server=self.mt5_server):
dashboard/pages/19_advanced_risk_manager.py:821:                    positions = mt5.positions_get()
dashboard/pages/19_advanced_risk_manager.py:916:                r = requests.get(f"{self.mt5_url}/{ep}", timeout=0.9)
dashboard/pages/19_advanced_risk_manager.py:924:                tcols = [c for c in ["time", "time_msc", "time_done", "time_close"] if c in df.columns]
dashboard/pages/19_advanced_risk_manager.py:1609:            st.info("No trades today — trajectory will appear once trades close.")
dashboard/pages/19_advanced_risk_manager.py:1890:            consumer.close()
dashboard/pages/19_advanced_risk_manager.py:1908:                for col in ["time", "time_msc", "time_done", "time_close", "timestamp"]:
dashboard/pages/19_advanced_risk_manager.py:1911:                            if col in ("time", "time_done", "time_close", "timestamp"):
dashboard/pages/19_advanced_risk_manager.py:2011:        st.info("No trades today — trajectory will appear once trades close.")
dashboard/pages/19_advanced_risk_manager.py:2180:        open=df['Open'], high=df['High'], low=df['Low'], close=df['Close'],
dashboard/pages/19_advanced_risk_manager.py:2258:                            pulse_manager._mt5_candidates = [url_input.strip()] + [u for u in pulse_manager._mt5_candidates if u and u != url_input.strip()]
dashboard/pages/19_advanced_risk_manager.py:2259:                            pulse_manager.mt5_url = url_input.strip()
dashboard/pages/19_advanced_risk_manager.py:2265:                    test_url = (url_input or pulse_manager.mt5_url or "").rstrip('/')
dashboard/pages/19_advanced_risk_manager.py:2400:            st.caption(f"MT5 bridge URL: {getattr(pulse_manager, 'mt5_url', '—')}")
dashboard/pages/19_advanced_risk_manager.py:2602:        bridge_url_display = getattr(pulse_manager, 'mt5_url', '') or os.getenv('MT5_URL') or os.getenv('MT5_API_URL') or '—'
dashboard/pages/19_advanced_risk_manager.py:2604:            if getattr(pulse_manager, 'mt5_url', None):
dashboard/pages/19_advanced_risk_manager.py:2605:                r = requests.get(f"{pulse_manager.mt5_url.rstrip('/')}/health", timeout=1.0)
dashboard/pages/19_advanced_risk_manager.py:2613:        st.caption("SL → BE, trailing lock (25/50/75%), and partial closes will be enabled here.")
dashboard/pages/19_advanced_risk_manager.py:2675:        traw = last_trade.get("time") or last_trade.get("time_close") or last_trade.get("time_done") or last_trade.get("timestamp")
monitoring/configs/prometheus/alerting-rules.yml:155:      summary: "Number of conntrack are getting close to the limit."
_new/mt5_bridge_production.py:6:import MetaTrader5 as mt5
_new/mt5_bridge_production.py:38:            if not mt5.initialize():
_new/mt5_bridge_production.py:44:                if not mt5.login(self.account, password=self.password, server=self.server):
_new/mt5_bridge_production.py:46:                    mt5.shutdown()
_new/mt5_bridge_production.py:61:            mt5.shutdown()
_new/mt5_bridge_production.py:77:        deals = mt5.history_deals_get(from_date, datetime.now())
_new/mt5_bridge_production.py:351:            if entry.get('type') == 'mt5_trade' and 'ticket' in entry.get('data', {})
_new/mt5_bridge_production.py:366:                "type": "mt5_trade",
docs/gpt_llm/market_data_vector_native_bundle/SCHEMA.md:19:  - `change_percent` (number): % change from previous close
_new/mt5_bridge.py:6:import MetaTrader5 as mt5
_new/mt5_bridge.py:29:        if not mt5.initialize():
_new/mt5_bridge.py:34:            authorized = mt5.login(self.account, password=self.password, server=self.server)
_new/mt5_bridge.py:37:                mt5.shutdown()
_new/mt5_bridge.py:55:        deals = mt5.history_deals_get(from_date, datetime.now())
_new/mt5_bridge.py:220:                "type": "mt5_trade",
_new/mt5_bridge.py:295:            mt5.shutdown()
dashboard/_mix/zanflow_parquet_dashboard.py:169:        if 'close' not in df.columns and 'bid' in df.columns:
dashboard/_mix/zanflow_parquet_dashboard.py:170:            df['close'] = (df['bid'] + df['ask']) / 2
dashboard/_mix/zanflow_parquet_dashboard.py:172:        if 'close' in df.columns:
dashboard/_mix/zanflow_parquet_dashboard.py:174:                'current_price': df['close'].iloc[-1],
dashboard/_mix/zanflow_parquet_dashboard.py:175:                'high': df['close'].max(),
dashboard/_mix/zanflow_parquet_dashboard.py:176:                'low': df['close'].min(),
dashboard/_mix/zanflow_parquet_dashboard.py:177:                'volatility': df['close'].std(),
dashboard/_mix/zanflow_parquet_dashboard.py:178:                'trend': 'UP' if df['close'].iloc[-1] > df['close'].iloc[0] else 'DOWN'
dashboard/_mix/zanflow_parquet_dashboard.py:333:                            if 'close' in df.columns or 'bid' in df.columns:
dashboard/_mix/zanflow_parquet_dashboard.py:336:                                if 'close' in df.columns:
dashboard/_mix/zanflow_parquet_dashboard.py:337:                                    y_data = df['close']
dashboard/_mix/zanflow_parquet_dashboard.py:406:                                    if 'close' in tf_df.columns or 'bid' in tf_df.columns:
dashboard/_mix/zanflow_parquet_dashboard.py:409:                                        if 'close' in tf_df.columns:
dashboard/_mix/zanflow_parquet_dashboard.py:410:                                            price_col = 'close'
dashboard/_mix/dashboard_standalone.py:213:                        elif 'close' in df.columns:
dashboard/_mix/dashboard_standalone.py:214:                            current_price = df['close'].iloc[-1] if len(df) > 0 else 0
dashboard/_mix/dashboard_standalone.py:230:                    if all(col in df.columns for col in ['open', 'high', 'low', 'close']):
dashboard/_mix/dashboard_standalone.py:238:                            close=df['close'],
components/wyckoff_agents.py:24:        c = df["close"].values
dashboard/_mix/7_ 🥶⃤👁️⃤ Technical Indicators.py:225:    price = latest.get('close', 0)
dashboard/_mix/7_ 🥶⃤👁️⃤ Technical Indicators.py:296:            close=df['close'],
dashboard/_mix/7_ 🥶⃤👁️⃤ Technical Indicators.py:363:        colors = ['#FFD700' if close >= open_price else '#FF4444'
dashboard/_mix/7_ 🥶⃤👁️⃤ Technical Indicators.py:364:                 for close, open_price in zip(df['close'], df['open'])]
dashboard/_mix/7_ 🥶⃤👁️⃤ Technical Indicators.py:664:    current_price = latest['close']
dashboard/_mix/7_ 🥶⃤👁️⃤ Technical Indicators.py:665:    price_change = current_price - current_df.iloc[-2]['close'] if len(current_df) > 1 else 0
dashboard/_mix/7_ 🥶⃤👁️⃤ Technical Indicators.py:666:    price_change_pct = (price_change / current_df.iloc[-2]['close'] * 100) if len(current_df) > 1 else 0
dashboard/_mix/7_ 🥶⃤👁️⃤ Technical Indicators.py:771:                            <div>Price: ${df.iloc[-1]['close']:.2f}</div>
docs/gpt_llm/market_data_vector_native_bundle/market_data_vector_native.py:42:        df = pd.DataFrame({'timestamp': dates, 'close': prices}).set_index('timestamp')
docs/gpt_llm/market_data_vector_native_bundle/market_data_vector_native.py:43:        df['returns'] = df['close'].pct_change()
docs/gpt_llm/market_data_vector_native_bundle/market_data_vector_native.py:47:        delta = df['close'].diff()
docs/gpt_llm/market_data_vector_native_bundle/market_data_vector_native.py:54:        ema_12 = df['close'].ewm(span=12, adjust=False).mean()
docs/gpt_llm/market_data_vector_native_bundle/market_data_vector_native.py:55:        ema_26 = df['close'].ewm(span=26, adjust=False).mean()
docs/gpt_llm/market_data_vector_native_bundle/market_data_vector_native.py:69:            price = latest['close']
docs/gpt_llm/market_data_vector_native_bundle/market_data_vector_native.py:70:            change_pct = (price - df.iloc[-2]['close']) / df.iloc[-2]['close'] * 100
docs/gpt_llm/market_data_vector_native_bundle/market_data_vector_native.py:86:            price_data[self.asset_names[asset]] = df['close']
docs/gpt_llm/market_data_vector_native_bundle/market_data_vector_native.py:109:        plt.close()
_new/pulse_kernel.py:223:            decision['reasons'].append('Medium confluence - monitor closely')
risk_enforcer.py:307:        # Warning if close to limit
components/confluence_engine.py:4:REQUIRED = ["high", "low", "close", "volume"]
components/confluence_engine.py:12:        pv = (df["high"] + df["low"] + df["close"]) / 3
dashboard/Dockerfile:66:    MT5_API_BASE=http://mt5:5001 \
dashboard/_mix/9_ 🔎 Tick manipulation insights.py:583:            elif 'close' in df.columns:
dashboard/_mix/9_ 🔎 Tick manipulation insights.py:584:                fig.add_trace(go.Scatter(x=df.index, y=df['close'], name='Close'))
dashboard/_mix/9_ 🔎 Tick manipulation insights.py:755:                if all(col in df.columns for col in ['open', 'high', 'low', 'close']):
dashboard/_mix/9_ 🔎 Tick manipulation insights.py:805:                if 'close' in df.columns:
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:412:            current_price = df['close'].iloc[-1]
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:423:            sma_20 = df['close'].rolling(20).mean().iloc[-1]
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:424:            sma_50 = df['close'].rolling(50).mean().iloc[-1] if len(df) >= 50 else sma_20
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:449:                current_bar['close'] > recent_low and
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:457:                    'rejection_strength': (current_bar['close'] - current_bar['low']) / (current_bar['high'] - current_bar['low']),
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:463:                  current_bar['close'] < recent_high and
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:471:                    'rejection_strength': (current_bar['high'] - current_bar['close']) / (current_bar['high'] - current_bar['low']),
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:489:                current_close = df['close'].iloc[i]
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:492:                if (current_close > swing_high and
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:493:                    df['close'].iloc[i-1] <= swing_high):
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:499:                        'displacement': current_close - swing_high,
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:500:                        'strength': 'high' if abs(current_close - swing_high) > df['close'].std() else 'medium'
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:504:                elif (current_close < swing_low and
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:505:                      df['close'].iloc[i-1] >= swing_low):
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:511:                        'displacement': swing_low - current_close,
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:512:                        'strength': 'high' if abs(swing_low - current_close) > df['close'].std() else 'medium'
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:526:                if gap_size > 0.001 * df['close'].iloc[i]:  # Minimum gap threshold
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:539:                if gap_size > 0.001 * df['close'].iloc[i]:
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:552:            if (df['close'].iloc[i] < df['open'].iloc[i] and  # Down candle
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:553:                df['close'].iloc[i+1] > df['open'].iloc[i+1] and  # Next candle up
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:554:                df['close'].iloc[i+1] > df['high'].iloc[i]):  # Strong move up
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:565:            elif (df['close'].iloc[i] > df['open'].iloc[i] and  # Up candle
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:566:                  df['close'].iloc[i+1] < df['open'].iloc[i+1] and  # Next candle down
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:567:                  df['close'].iloc[i+1] < df['low'].iloc[i]):  # Strong move down
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:612:            latest_price = df['close'].iloc[-1]
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:684:        df['price_volatility'] = df['close'].rolling(20).std()
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:692:            trend_strength = abs(window['close'].iloc[-1] - window['close'].iloc[0]) / price_range if price_range > 0 else 0
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:704:                    'price_level': window['close'].mean(),
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:710:                  window['close'].iloc[-1] > window['close'].iloc[0] * 1.02 and
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:717:                    'price_level': window['close'].mean(),
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:736:                df['close'].iloc[i] > df['low'].iloc[i]):
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:749:                  abs(df['low'].iloc[i] - df['low'].iloc[i-5:i].min()) < df['close'].std() * 0.5 and
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:795:            latest_price = df['close'].iloc[-1]
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:866:            ranges['current_price'] = df['close'].iloc[-1]
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:891:                current_bar['close'] < asian_high and
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:900:                    'rejection_strength': (asian_high - current_bar['close']) / (current_bar['high'] - current_bar['low']),
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:906:                  current_bar['close'] > asian_low and
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:915:                    'rejection_strength': (current_bar['close'] - asian_low) / (current_bar['high'] - current_bar['low']),
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:930:                current_close = df['close'].iloc[j]
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:934:                    if current_close < sweep['level'] * 0.995:  # 0.5% below swept level
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:939:                            'reversal_strength': (sweep['level'] - current_close) / sweep['level'],
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:946:                    if current_close > sweep['level'] * 1.005:  # 0.5% above swept level
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:951:                            'reversal_strength': (current_close - sweep['level']) / sweep['level'],
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:987:            latest_price = df['close'].iloc[-1]
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:1060:            'current_price': df['close'].iloc[-1],
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:1061:            'volatility': df['close'].rolling(20).std().iloc[-1],
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:1069:            sma_20 = df['close'].rolling(20).mean().iloc[-1]
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:1070:            sma_50 = df['close'].rolling(50).mean().iloc[-1]
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:1146:            close=df['close'],
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:1158:        sma_20 = df['close'].rolling(20).mean()
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:1169:        sma_50 = df['close'].rolling(50).mean()
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:1209:        colors = ['#2c5530' if close >= open_price else '#8B0000'
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:1210:                 for close, open_price in zip(df['close'], df['open'])]
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:1521:                    required_cols = ['open', 'high', 'low', 'close']
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:1613:    current_price = latest['close']
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:1616:        price_change = current_price - current_df.iloc[-2]['close']
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:1617:        price_change_pct = (price_change / current_df.iloc[-2]['close']) * 100
dashboard/_mix/ZANFLOW v12 Strategy Dashboard copy.py:1827:                                <div>Price: ${df_tf.iloc[-1]['close']:.2f}</div>
dashboard/_mix/3_ 🎓 Wyckoff.py:231:        df['price_volatility'] = df['close'].rolling(20).std()
dashboard/_mix/3_ 🎓 Wyckoff.py:233:        df['price_change'] = df['close'].pct_change()
dashboard/_mix/3_ 🎓 Wyckoff.py:250:                    'price_level': window['close'].mean(),
dashboard/_mix/3_ 🎓 Wyckoff.py:255:            elif (window['close'].iloc[-1] > window['close'].iloc[0] * 1.02 and
dashboard/_mix/3_ 🎓 Wyckoff.py:262:                    'strength': (window['close'].iloc[-1] - window['close'].iloc[0]) / window['close'].iloc[0],
dashboard/_mix/3_ 🎓 Wyckoff.py:263:                    'price_level': window['close'].mean(),
dashboard/_mix/3_ 🎓 Wyckoff.py:277:                    'price_level': window['close'].mean(),
dashboard/_mix/3_ 🎓 Wyckoff.py:289:        df['close_position'] = (df['close'] - df['low']) / df['price_range']
dashboard/_mix/3_ 🎓 Wyckoff.py:294:                df.iloc[i]['close'] < df.iloc[i-1]['close'] and
dashboard/_mix/3_ 🎓 Wyckoff.py:295:                df.iloc[i]['close_position'] < 0.3):
dashboard/_mix/3_ 🎓 Wyckoff.py:300:                    'price': df.iloc[i]['close'],
dashboard/_mix/3_ 🎓 Wyckoff.py:308:                  df.iloc[i]['close'] > df.iloc[i-1]['close'] and
dashboard/_mix/3_ 🎓 Wyckoff.py:309:                  df.iloc[i]['close_position'] > 0.7):
dashboard/_mix/3_ 🎓 Wyckoff.py:314:                    'price': df.iloc[i]['close'],
dashboard/_mix/3_ 🎓 Wyckoff.py:322:                  df.iloc[i]['close'] > df.iloc[i-5:i]['close'].max() and
dashboard/_mix/3_ 🎓 Wyckoff.py:328:                    'price': df.iloc[i]['close'],
dashboard/_mix/3_ 🎓 Wyckoff.py:357:        # high volume, high close = strength
dashboard/_mix/3_ 🎓 Wyckoff.py:358:        high_vol_high_close = (df['volume_norm'] > 1.0) & ((df['close'] - df['low']) / df['spread'] > 0.7)
dashboard/_mix/3_ 🎓 Wyckoff.py:359:        conditions.append(('Strength', high_vol_high_close))
dashboard/_mix/3_ 🎓 Wyckoff.py:378:        df['price_move'] = abs(df['close'] - df['open']) / df['open']
dashboard/_mix/3_ 🎓 Wyckoff.py:491:        df['price_efficiency'] = abs(df['close'] - df['open']) / (df['high'] - df['low'])
dashboard/_mix/3_ 🎓 Wyckoff.py:499:                abs(df.iloc[i]['close'] - df.iloc[i]['open']) / df.iloc[i]['open'] < 0.01):
dashboard/_mix/3_ 🎓 Wyckoff.py:504:                df.iloc[i]['close'] < df.iloc[i]['high'] * 0.95 and
dashboard/_mix/3_ 🎓 Wyckoff.py:523:        price_trend = recent_data['close'].iloc[-1] / recent_data['close'].iloc[0]
dashboard/_mix/3_ 🎓 Wyckoff.py:568:            close=df['close'],
dashboard/_mix/3_ 🎓 Wyckoff.py:654:    volume_colors = ['red' if close < open_price else 'green'
dashboard/_mix/3_ 🎓 Wyckoff.py:655:                    for close, open_price in zip(df['close'], df['open'])]
dashboard/_mix/3_ 🎓 Wyckoff.py:696:                signal_prices = [df['close'].iloc[i] for i in indices if i < len(df)]
dashboard/_mix/3_ 🎓 Wyckoff.py:1041:                current_price = df['close'].iloc[-1]
dashboard/_mix/3_ 🎓 Wyckoff.py:1042:                price_change = ((df['close'].iloc[-1] - df['close'].iloc[0]) / df['close'].iloc[0]) * 100
components/smc_analyser.py:87:            if df['close'].iloc[i] < df['open'].iloc[i]:  # Down candle
components/smc_analyser.py:90:                if (future_high - df['close'].iloc[i]) / df['close'].iloc[i] > min_move:
components/smc_analyser.py:97:                        'strength': (future_high - df['close'].iloc[i]) / df['close'].iloc[i]
components/smc_analyser.py:101:            elif df['close'].iloc[i] > df['open'].iloc[i]:  # Up candle
components/smc_analyser.py:104:                if (df['close'].iloc[i] - future_low) / df['close'].iloc[i] > min_move:
components/smc_analyser.py:111:                        'strength': (df['close'].iloc[i] - future_low) / df['close'].iloc[i]
components/smc_analyser.py:123:            if gap_size > 0 and gap_size / df['close'].iloc[i] > min_gap_size:
components/smc_analyser.py:136:            if gap_size > 0 and gap_size / df['close'].iloc[i] > min_gap_size:
components/smc_analyser.py:227:                            reversal = after_max['close'].iloc[-1] < zone['level']
components/smc_analyser.py:247:                            reversal = after_min['close'].iloc[-1] > zone['level']
components/smc_analyser.py:273:                if df['close'].iloc[i] > df['open'].iloc[i]:
components/smc_analyser.py:285:                    'close': df['close'].iloc[i]
components/smc_analyser.py:367:        avg_price = recent_data['close'].mean()
components/smc_analyser.py:368:        price_position = (recent_data['close'].iloc[-1] - recent_data['low'].min()) / price_range
components/smc_analyser.py:376:        sma_20 = recent_data['close'].rolling(20).mean()
components/smc_analyser.py:377:        sma_50 = recent_data['close'].rolling(50).mean() if len(recent_data) >= 50 else sma_20
components/smc_analyser.py:387:            if sma_20.iloc[-1] > sma_50.iloc[-1] and recent_data['close'].iloc[-1] > sma_20.iloc[-1]:
components/smc_analyser.py:389:            elif sma_20.iloc[-1] < sma_50.iloc[-1] and recent_data['close'].iloc[-1] < sma_20.iloc[-1]:
components/smc_analyser.py:449:        prev_trend = df['close'].iloc[i-50:i].mean() > df['close'].iloc[i-25:i].mean()
components/smc_analyser.py:461:        price_drop = (df['close'].iloc[i] - df['close'].iloc[i-5]) / df['close'].iloc[i-5] < -0.02
components/smc_analyser.py:465:            reversal = df['close'].iloc[i+5] > df['close'].iloc[i]
components/smc_analyser.py:528:                    if df['close'].iloc[i+5] > range_low:
components/smc_analyser.py:543:                    if df['close'].iloc[i+5] < range_high:
components/smc_analyser.py:561:            if df['close'].iloc[i] > df['close'].iloc[i-1]:
components/smc_analyser.py:562:                price_change = (df['close'].iloc[i] - df['close'].iloc[i-5]) / df['close'].iloc[i-5]
components/smc_analyser.py:570:                        'price': df['close'].iloc[i],
components/smc_analyser.py:575:            elif df['close'].iloc[i] < df['close'].iloc[i-1]:
components/smc_analyser.py:576:                price_change = (df['close'].iloc[i] - df['close'].iloc[i-5]) / df['close'].iloc[i-5]
components/smc_analyser.py:584:                        'price': df['close'].iloc[i],
components/smc_analyser.py:600:            avg_price = window['close'].mean()
components/smc_analyser.py:644:            price_change = abs(df['close'].iloc[i] - df['open'].iloc[i]) / df['open'].iloc[i]
components/smc_analyser.py:671:                    'price_direction': 'up' if df['close'].iloc[i] > df['open'].iloc[i] else 'down'
components/smc_analyser.py:690:                if df['close'].iloc[breakout_idx + 10] > range_info['high'] * 1.02:
components/smc_analyser.py:867:        current_price = df['close'].iloc[-1]
dashboard/_mix/ultimate_analysis_enhanced.py:115:            close=df['close'],
dashboard/_mix/ultimate_analysis_enhanced.py:134:            y=[df['close'].iloc[-1], mid_price],
dashboard/_mix/ultimate_analysis_enhanced.py:216:        colors = ['green' if close >= open_val else 'red'
dashboard/_mix/ultimate_analysis_enhanced.py:217:                 for close, open_val in zip(df['close'], df['open'])]
dashboard/_mix/5_  🧠 SMC & WYCKOFF.py:166:        ohlc_cols = ['open', 'high', 'low', 'close']
dashboard/_mix/5_  🧠 SMC & WYCKOFF.py:171:            df['close'] = base_price
dashboard/_mix/5_  🧠 SMC & WYCKOFF.py:172:            df['high'] = pd.concat([df['open'], df['close']], axis=1).max(axis=1)
dashboard/_mix/5_  🧠 SMC & WYCKOFF.py:173:            df['low'] = pd.concat([df['open'], df['close']], axis=1).min(axis=1)
dashboard/_mix/5_  🧠 SMC & WYCKOFF.py:383:            close=df['close'],
dashboard/_mix/5_  🧠 SMC & WYCKOFF.py:602:            for price_col in ['open', 'high', 'low', 'close']:
dashboard/_mix/5_  🧠 SMC & WYCKOFF.py:635:            ohlc_cols = ['open', 'high', 'low', 'close']
dashboard/_mix/5_  🧠 SMC & WYCKOFF.py:644:                    if 'close' not in df.columns:
dashboard/_mix/5_  🧠 SMC & WYCKOFF.py:645:                        df['close'] = base_price
dashboard/_mix/5_  🧠 SMC & WYCKOFF.py:647:                        df['high'] = pd.concat([df['open'], df['close']], axis=1).max(axis=1)
dashboard/_mix/5_  🧠 SMC & WYCKOFF.py:649:                        df['low'] = pd.concat([df['open'], df['close']], axis=1).min(axis=1)
dashboard/_mix/5_  🧠 SMC & WYCKOFF.py:660:                recent = df[['open', 'high', 'low', 'close']].tail(10)
dashboard/_mix/5_  🧠 SMC & WYCKOFF.py:668:            for price_col in ['open', 'high', 'low', 'close']:
dashboard/_mix/5_  🧠 SMC & WYCKOFF.py:672:            df = df.dropna(subset=['open', 'high', 'low', 'close'])
dashboard/_mix/5_  🧠 SMC & WYCKOFF.py:676:                st.dataframe(df[['timestamp', 'open', 'high', 'low', 'close']].tail(30))
dashboard/_mix/5_  🧠 SMC & WYCKOFF.py:743:            current_price = tf_data['close'].iloc[-1]
dashboard/_mix/5_  🧠 SMC & WYCKOFF.py:744:            price_change = ((current_price - tf_data['close'].iloc[-2]) / tf_data['close'].iloc[-2]) * 100
dashboard/_mix/5_  🧠 SMC & WYCKOFF.py:764:            st.metric("Volatility", f"{tf_data['close'].pct_change().std() * 100:.2f}%")
dashboard/_mix/5_  🧠 SMC & WYCKOFF.py:858:- **Current Price**: ${tf_data['close'].iloc[-1]:.5f}
dashboard/_mix/5_  🧠 SMC & WYCKOFF.py:859:- **24h Change**: {((tf_data['close'].iloc[-1] - tf_data['close'].iloc[-24]) / tf_data['close'].iloc[-24] * 100):.2f}%
components/volume_profile_analyzer.py:147:        current_price = df['close'].iloc[-1]
dashboard/_mix/dashboard_integration.py:52:            history = self.redis.lrange(f"mt5:{symbol}:history", 0, limit-1)
dashboard/_mix/dashboard_integration.py:60:        pubsub.subscribe(f"mt5:{symbol}")
dashboard/_mix/dashboard_integration.py:89:                close=[c['close'] for c in candles],
dashboard/_mix/19_advanced_risk_manager.py:20:    import MetaTrader5 as mt5
dashboard/_mix/19_advanced_risk_manager.py:24:    mt5 = None
dashboard/_mix/19_advanced_risk_manager.py:111:        self.mt5_login = os.getenv('MT5_LOGIN')
dashboard/_mix/19_advanced_risk_manager.py:112:        self.mt5_password = os.getenv('MT5_PASSWORD')
dashboard/_mix/19_advanced_risk_manager.py:113:        self.mt5_server = os.getenv('MT5_SERVER')
dashboard/_mix/19_advanced_risk_manager.py:117:        self.mt5_available = MT5_AVAILABLE
dashboard/_mix/19_advanced_risk_manager.py:120:        self.mt5_url = os.getenv('MT5_URL') or os.getenv('MT5_API_URL')
dashboard/_mix/19_advanced_risk_manager.py:138:        if not self.mt5_available:
dashboard/_mix/19_advanced_risk_manager.py:142:        if not all([self.mt5_login, self.mt5_password, self.mt5_server]):
dashboard/_mix/19_advanced_risk_manager.py:147:            if not mt5.initialize():
dashboard/_mix/19_advanced_risk_manager.py:150:            authorized = mt5.login(
dashboard/_mix/19_advanced_risk_manager.py:151:                login=int(self.mt5_login),
dashboard/_mix/19_advanced_risk_manager.py:152:                password=self.mt5_password,
dashboard/_mix/19_advanced_risk_manager.py:153:                server=self.mt5_server
dashboard/_mix/19_advanced_risk_manager.py:185:            account_info = mt5.account_info()
dashboard/_mix/19_advanced_risk_manager.py:210:        if self.mt5_url:
dashboard/_mix/19_advanced_risk_manager.py:212:                r = requests.get(f"{self.mt5_url.rstrip('/')}/positions_get", timeout=2.0)
dashboard/_mix/19_advanced_risk_manager.py:232:            positions = mt5.positions_get()
backend/django/pulse_api/views.py:63:                "mt5": "checking"
dashboard/_mix/8_ 💸 Quad Destroyer.py:398:            atr14 = talib.ATR(df['high'].values, df['low'].values, df['close'].values, timeperiod=atr_period)
dashboard/_mix/8_ 💸 Quad Destroyer.py:448:                    displacement = abs(df_ny['close'].iloc[j] - df_ny['close'].iloc[j-1])
dashboard/_mix/8_ 💸 Quad Destroyer.py:454:                        entry_price = df_ny['close'].iloc[j]
dashboard/_mix/8_ 💸 Quad Destroyer.py:566:                    if df['close'].iloc[j] < asian_high:  # Price back below swept level
dashboard/_mix/8_ 💸 Quad Destroyer.py:576:                    if df['close'].iloc[j] > asian_low:  # Price back above swept level
dashboard/_mix/8_ 💸 Quad Destroyer.py:623:                if gap_size > 0.001 * df['close'].iloc[i]:  # Minimum gap threshold
dashboard/_mix/8_ 💸 Quad Destroyer.py:636:                if gap_size > 0.001 * df['close'].iloc[i]:  # Minimum gap threshold
dashboard/_mix/8_ 💸 Quad Destroyer.py:655:            if (df['close'].iloc[i] < df['open'].iloc[i] and  # Down candle
dashboard/_mix/8_ 💸 Quad Destroyer.py:656:                df['close'].iloc[i+1] > df['open'].iloc[i+1] and  # Next candle up
dashboard/_mix/8_ 💸 Quad Destroyer.py:657:                df['close'].iloc[i+1] > df['high'].iloc[i]):  # Strong move up
dashboard/_mix/8_ 💸 Quad Destroyer.py:668:            elif (df['close'].iloc[i] > df['open'].iloc[i] and  # Up candle
dashboard/_mix/8_ 💸 Quad Destroyer.py:669:                  df['close'].iloc[i+1] < df['open'].iloc[i+1] and  # Next candle down
dashboard/_mix/8_ 💸 Quad Destroyer.py:670:                  df['close'].iloc[i+1] < df['low'].iloc[i]):  # Strong move down
dashboard/_mix/8_ 💸 Quad Destroyer.py:692:            if df['close'].iloc[i] > recent_high:  # Bullish BOS
dashboard/_mix/8_ 💸 Quad Destroyer.py:694:            elif df['close'].iloc[i] < recent_low:  # Bearish BOS
dashboard/_mix/8_ 💸 Quad Destroyer.py:704:                if (df['close'].iloc[i] < older_low and
dashboard/_mix/8_ 💸 Quad Destroyer.py:705:                    df['close'].iloc[i-1] > older_low):  # Bearish CHoCH
dashboard/_mix/8_ 💸 Quad Destroyer.py:707:                elif (df['close'].iloc[i] > older_high and
dashboard/_mix/8_ 💸 Quad Destroyer.py:708:                      df['close'].iloc[i-1] < older_high):  # Bullish CHoCH
dashboard/_mix/8_ 💸 Quad Destroyer.py:728:                        'price': df['close'].iloc[i],
dashboard/_mix/8_ 💸 Quad Destroyer.py:755:        df['price_volatility'] = df['close'].rolling(20).std()
dashboard/_mix/8_ 💸 Quad Destroyer.py:756:        df['price_trend'] = df['close'].rolling(50).mean()
dashboard/_mix/8_ 💸 Quad Destroyer.py:774:            trend_strength = abs(window['close'].iloc[-1] - window['close'].iloc[0]) / price_range
dashboard/_mix/8_ 💸 Quad Destroyer.py:789:                  window['close'].iloc[-1] < window['high'].max() * 0.95):
dashboard/_mix/8_ 💸 Quad Destroyer.py:796:                  window['close'].iloc[-1] > window['close'].iloc[0] * 1.02 and
dashboard/_mix/8_ 💸 Quad Destroyer.py:804:                  window['close'].iloc[-1] < window['close'].iloc[0] * 0.98 and
dashboard/_mix/8_ 💸 Quad Destroyer.py:820:                df['close'].iloc[i] < df['close'].iloc[i-1] and
dashboard/_mix/8_ 💸 Quad Destroyer.py:821:                (df['close'].iloc[i] - df['low'].iloc[i]) / (df['high'].iloc[i] - df['low'].iloc[i]) < 0.3):
dashboard/_mix/8_ 💸 Quad Destroyer.py:825:            # Buying Climax (BC): High volume, strong up move with weak close
dashboard/_mix/8_ 💸 Quad Destroyer.py:827:                  df['close'].iloc[i] > df['close'].iloc[i-1] and
dashboard/_mix/8_ 💸 Quad Destroyer.py:828:                  (df['close'].iloc[i] - df['low'].iloc[i]) / (df['high'].iloc[i] - df['low'].iloc[i]) > 0.7):
dashboard/_mix/8_ 💸 Quad Destroyer.py:835:                  df['close'].iloc[i] > df['low'].iloc[i]):
dashboard/_mix/8_ 💸 Quad Destroyer.py:871:            close=df['close'],
dashboard/_mix/8_ 💸 Quad Destroyer.py:916:                        y=[df.loc[idx, 'close']],
dashboard/_mix/8_ 💸 Quad Destroyer.py:958:                    y=fvg_bull['close'],
dashboard/_mix/8_ 💸 Quad Destroyer.py:974:                    y=fvg_bear['close'],
dashboard/_mix/8_ 💸 Quad Destroyer.py:992:            elif df.loc[idx, 'close'] >= df.loc[idx, 'open']:
dashboard/_mix/8_ 💸 Quad Destroyer.py:1293:            required_cols = ['open', 'high', 'low', 'close']
dashboard/_mix/8_ 💸 Quad Destroyer.py:1304:                    'last_price': df['close'].iloc[-1],
dashboard/_mix/8_ 💸 Quad Destroyer.py:1305:                    'daily_change': ((df['close'].iloc[-1] - df['close'].iloc[0]) / df['close'].iloc[0]) * 100
dashboard/_mix/8_ 💸 Quad Destroyer.py:1517:    current_price = latest['close']
dashboard/_mix/8_ 💸 Quad Destroyer.py:1520:        price_change = current_price - current_df.iloc[-2]['close']
dashboard/_mix/8_ 💸 Quad Destroyer.py:1521:        price_change_pct = (price_change / current_df.iloc[-2]['close']) * 100
dashboard/_mix/8_ 💸 Quad Destroyer.py:1714:                            <div>Price: ${price_fmt(df_tf.iloc[-1]['close'], selected_symbol)}</div>
components/wyckoff_adaptive.py:55:    ret = out["close"].pct_change().fillna(0.0)
components/wyckoff_adaptive.py:60:    ma = out["close"].rolling(win).mean()
components/wyckoff_adaptive.py:61:    sd = out["close"].rolling(win).std()
components/wyckoff_adaptive.py:64:    pctB = (out["close"] - lower) / ((upper - lower) + 1e-12)
components/wyckoff_adaptive.py:100:    ret_fwd = _nz(feat["close"].pct_change().rolling(3).sum().shift(-3).values)
dashboard/_mix/zanflow_integrated_system.py:475:                                "price": df.iloc[-1].get('close', 2350),
components/chart_builder.py:75:                    close=df['close'],
components/chart_builder.py:90:                    close=ha_df['ha_close'],
components/chart_builder.py:101:                    y=df['close'],
components/chart_builder.py:115:            colors = [CANDLE_UP_COLOR if close >= open else CANDLE_DOWN_COLOR
components/chart_builder.py:116:                     for close, open in zip(df['close'], df['open'])]
components/chart_builder.py:156:        ha_df['ha_close'] = (df['open'] + df['high'] + df['low'] + df['close']) / 4
components/chart_builder.py:158:        ha_df['ha_open'] = (df['open'].shift(1) + df['close'].shift(1)) / 2
components/chart_builder.py:159:        ha_df['ha_open'].iloc[0] = (df['open'].iloc[0] + df['close'].iloc[0]) / 2
components/chart_builder.py:161:        ha_df['ha_high'] = ha_df[['high', 'ha_open', 'ha_close']].max(axis=1)
components/chart_builder.py:162:        ha_df['ha_low'] = ha_df[['low', 'ha_open', 'ha_close']].min(axis=1)
components/chart_builder.py:182:                std = df['close'].std()
components/chart_builder.py:328:                        close=df['close'],
components/chart_builder.py:340:                    sma = df['close'].rolling(window=sma_period).mean()
components/chart_builder.py:374:                close=df['close'],
dashboard/_mix/tick_manipulation_dashboard.py:150:                elif 'close' in df.columns:
dashboard/_mix/tick_manipulation_dashboard.py:151:                    fig.add_trace(go.Scatter(x=df.index, y=df['close'], 
dashboard/_mix/tick_manipulation_dashboard.py:218:                                if all(col in df.columns for col in ['open', 'high', 'low', 'close']):
components/technical_analysis.py:23:        if df.empty or df['close'].nunique() <= 1:
components/technical_analysis.py:30:        results['sma_20'] = ta.trend.sma_indicator(df['close'], window=20)
components/technical_analysis.py:31:        results['sma_50'] = ta.trend.sma_indicator(df['close'], window=50)
components/technical_analysis.py:32:        results['sma_200'] = ta.trend.sma_indicator(df['close'], window=200)
components/technical_analysis.py:33:        results['ema_20'] = ta.trend.ema_indicator(df['close'], window=20)
components/technical_analysis.py:34:        results['ema_50'] = ta.trend.ema_indicator(df['close'], window=50)
components/technical_analysis.py:37:        macd = ta.trend.MACD(df['close'])
components/technical_analysis.py:43:        results['rsi'] = ta.momentum.RSIIndicator(df['close']).rsi()
components/technical_analysis.py:46:        bb = ta.volatility.BollingerBands(df['close'])
components/technical_analysis.py:53:        results['atr'] = ta.volatility.AverageTrueRange(df['high'], df['low'], df['close']).average_true_range()
components/technical_analysis.py:57:        results['mfi'] = ta.volume.MFIIndicator(df['high'], df['low'], df['close'], df['volume']).money_flow_index()
components/technical_analysis.py:89:            'resistance': [l for l in levels if l > df['close'].iloc[-1]],
components/technical_analysis.py:90:            'support': [l for l in levels if l < df['close'].iloc[-1]]
components/technical_analysis.py:117:        close = df['close'].iloc[-1]
components/technical_analysis.py:120:        pp = (high + low + close) / 3
components/technical_analysis.py:145:        close_prices = df['close'].values
components/technical_analysis.py:148:        body_size = abs(close_prices - open_prices)
components/technical_analysis.py:154:        lower_shadow = np.minimum(open_prices, close_prices) - low_prices
components/technical_analysis.py:155:        upper_shadow = high_prices - np.maximum(open_prices, close_prices)
components/technical_analysis.py:160:                (close_prices[1:] > open_prices[1:]) &
components/technical_analysis.py:161:                (close_prices[:-1] < open_prices[:-1]) &
components/technical_analysis.py:162:                (open_prices[1:] < close_prices[:-1]) &
components/technical_analysis.py:163:                (close_prices[1:] > open_prices[:-1])
components/technical_analysis.py:193:            sma_20 = ta.trend.sma_indicator(df['close'], window=20)
components/technical_analysis.py:194:            sma_50 = ta.trend.sma_indicator(df['close'], window=50)
components/technical_analysis.py:197:                current_price = df['close'].iloc[-1]
components/technical_analysis.py:211:            rsi = ta.momentum.RSIIndicator(df['close']).rsi()
backend/django/pulse_api/situation_builder.py:7:MT5_URL = os.getenv("MT5_URL", "http://mt5:5001")
components/wyckoff_analyzer.py:34:        avg_price = recent_data['close'].mean()
components/wyckoff_analyzer.py:35:        price_position = (recent_data['close'].iloc[-1] - recent_data['low'].min()) / price_range
components/wyckoff_analyzer.py:43:        sma_20 = recent_data['close'].rolling(20).mean()
components/wyckoff_analyzer.py:44:        sma_50 = recent_data['close'].rolling(50).mean() if len(recent_data) >= 50 else sma_20
components/wyckoff_analyzer.py:54:            if sma_20.iloc[-1] > sma_50.iloc[-1] and recent_data['close'].iloc[-1] > sma_20.iloc[-1]:
components/wyckoff_analyzer.py:56:            elif sma_20.iloc[-1] < sma_50.iloc[-1] and recent_data['close'].iloc[-1] < sma_20.iloc[-1]:
components/wyckoff_analyzer.py:116:        prev_trend = df['close'].iloc[i-50:i].mean() > df['close'].iloc[i-25:i].mean()
components/wyckoff_analyzer.py:128:        price_drop = (df['close'].iloc[i] - df['close'].iloc[i-5]) / df['close'].iloc[i-5] < -0.02
components/wyckoff_analyzer.py:132:            reversal = df['close'].iloc[i+5] > df['close'].iloc[i]
components/wyckoff_analyzer.py:195:                    if df['close'].iloc[i+5] > range_low:
components/wyckoff_analyzer.py:210:                    if df['close'].iloc[i+5] < range_high:
components/wyckoff_analyzer.py:228:            if df['close'].iloc[i] > df['close'].iloc[i-1]:
components/wyckoff_analyzer.py:229:                price_change = (df['close'].iloc[i] - df['close'].iloc[i-5]) / df['close'].iloc[i-5]
components/wyckoff_analyzer.py:237:                        'price': df['close'].iloc[i],
components/wyckoff_analyzer.py:242:            elif df['close'].iloc[i] < df['close'].iloc[i-1]:
components/wyckoff_analyzer.py:243:                price_change = (df['close'].iloc[i] - df['close'].iloc[i-5]) / df['close'].iloc[i-5]
components/wyckoff_analyzer.py:251:                        'price': df['close'].iloc[i],
components/wyckoff_analyzer.py:267:            avg_price = window['close'].mean()
components/wyckoff_analyzer.py:311:            price_change = abs(df['close'].iloc[i] - df['open'].iloc[i]) / df['open'].iloc[i]
components/wyckoff_analyzer.py:338:                    'price_direction': 'up' if df['close'].iloc[i] > df['open'].iloc[i] else 'down'
components/wyckoff_analyzer.py:357:                if df['close'].iloc[breakout_idx + 10] > range_info['high'] * 1.02:
confluence_scorer.py:221:            'close': data.get('close', 0),
components/timeframe_converter.py:54:            'close': 'last',
components/timeframe_converter.py:110:                    'close': df['close'].iloc[last_idx],
dashboard/configs/wyckoff_live_config.yaml:5:  mt5_url: "http://mt5:8000"  # MT5 service from docker-compose
backend/django/pulse_api/tests.py:17:            {"open": 1.0, "high": 1.5, "low": 0.5, "close": 1.2},
backend/django/pulse_api/tests.py:18:            {"open": 1.2, "high": 1.7, "low": 0.8, "close": 1.4},
backend/django/pulse_api/tests.py:19:            {"open": 1.4, "high": 1.6, "low": 1.1, "close": 1.3},
backend/mt5/docker-compose.yml:58:  mt5:
backend/mt5/docker-compose.yml:61:    container_name: mt5
backend/mt5/docker-compose.yml:75:      # Router for vnc.mt5.${domain} (Port 3000)
backend/mt5/docker-compose.yml:76:      traefik.http.routers.vnc-mt5-http.rule: Host(`${VNC_DOMAIN}`)
backend/mt5/docker-compose.yml:77:      traefik.http.routers.vnc-mt5-http.entrypoints: http
backend/mt5/docker-compose.yml:78:      traefik.http.routers.vnc-mt5-http.middlewares: https-redirect
backend/mt5/docker-compose.yml:80:      traefik.http.routers.vnc-mt5-https.rule: Host(`${VNC_DOMAIN}`)
backend/mt5/docker-compose.yml:81:      traefik.http.routers.vnc-mt5-https.entrypoints: https
backend/mt5/docker-compose.yml:82:      traefik.http.routers.vnc-mt5-https.tls: true
backend/mt5/docker-compose.yml:83:      traefik.http.routers.vnc-mt5-https.tls.certresolver: le
backend/mt5/docker-compose.yml:84:      traefik.http.routers.vnc-mt5-https.service: vnc-mt5-service
backend/mt5/docker-compose.yml:86:      traefik.http.services.vnc-mt5-service.loadbalancer.server.port: 3000
backend/mt5/docker-compose.yml:88:      # Router for api.mt5.${domain} (Port 5001)
backend/mt5/docker-compose.yml:89:      traefik.http.routers.api-mt5-http.rule: Host(`${API_DOMAIN}`)
backend/mt5/docker-compose.yml:90:      traefik.http.routers.api-mt5-http.entrypoints: http
backend/mt5/docker-compose.yml:91:      traefik.http.routers.api-mt5-http.middlewares: https-redirect
backend/mt5/docker-compose.yml:93:      traefik.http.routers.api-mt5-https.rule: Host(`${API_DOMAIN}`)
backend/mt5/docker-compose.yml:94:      traefik.http.routers.api-mt5-https.entrypoints: https
backend/mt5/docker-compose.yml:95:      traefik.http.routers.api-mt5-https.tls: true
backend/mt5/docker-compose.yml:96:      traefik.http.routers.api-mt5-https.tls.certresolver: le
backend/mt5/docker-compose.yml:97:      traefik.http.routers.api-mt5-https.service: api-mt5-service
backend/mt5/docker-compose.yml:99:      traefik.http.services.api-mt5-service.loadbalancer.server.port: 5001
backend/mt5/Dockerfile:53:RUN touch /var/log/mt5_setup.log && \
backend/mt5/Dockerfile:54:    chown abc:abc /var/log/mt5_setup.log && \
backend/mt5/Dockerfile:55:    chmod 644 /var/log/mt5_setup.log
dashboard/components/ui_tri_vitals.py:17:def fig_equity_donut(*, equity_usd: float, sod_equity_usd: float, prev_close_usd: float | None,
dashboard/components/ui_tri_vitals.py:21:    Shows previous session close as context in hover text.
dashboard/components/ui_tri_vitals.py:50:    if isinstance(prev_close_usd, (int, float)) and prev_close_usd:
dashboard/components/ui_tri_vitals.py:51:        fig.update_layout(annotations=[dict(text=f"Prev close ${prev_close_usd:,.0f}",
dashboard/components/ui_tri_vitals.py:124:                      prev_close_equity_usd: float | None,
dashboard/components/ui_tri_vitals.py:129:                          prev_close_usd=prev_close_equity_usd,
dashboard/components/ui_concentric.py:87:    # Outer ghost track (e.g., yesterday close) as a thin overlay arc
backend/mt5_api/app.py:10:    return os.getenv("MT5_API_URL") or os.getenv("MT5_API_BASE") or "http://mt5:5001"
backend/mt5_api/app.py:19:        "server": "mt5",
backend/django/app/nexus/views.py:114:    ordering_fields = ['entry_time', 'close_time', 'pnl', 'symbol']
backend/django/app/nexus/views.py:119:        return Trade.objects.prefetch_related('close_prices_mutations').all()
backend/django/app/nexus/views.py:160:            mutations = trade.close_prices_mutations.all()
backend/django/app/nexus/views.py:276:        closed_today = trades_today.exclude(close_time__isnull=True)
backend/django/app/nexus/views.py:277:        pnl_today = sum([t.pnl or 0 for t in closed_today])
backend/django/app/nexus/views.py:287:        mt5_base = (
backend/django/app/nexus/views.py:290:            or "http://mt5:5001"
backend/django/app/nexus/views.py:308:            r = requests.get(f"{str(mt5_base).rstrip('/')}/account_info", timeout=2.5)
backend/django/app/nexus/views.py:317:            r = requests.get(f"{str(mt5_base).rstrip('/')}/positions_get", timeout=2.5)
backend/django/app/nexus/views.py:579:        mt5_base = (
backend/django/app/nexus/views.py:582:            or "http://mt5:5001"
backend/django/app/nexus/views.py:585:            r = requests.get(f"{str(mt5_base).rstrip('/')}/positions_get", timeout=3.0)
backend/django/app/nexus/views.py:690:        mt5_base = os.getenv("MT5_URL") or os.getenv("MT5_API_URL") or "http://mt5:5001"
backend/django/app/nexus/views.py:692:            r = requests.post(f"{mt5_base.rstrip('/')}/partial_close", json={'ticket': ticket, 'symbol': symbol, 'fraction': fraction}, timeout=6.0)
backend/django/app/nexus/views.py:695:            return Response({'error': 'partial_close_failed', 'detail': getattr(r, 'text', '')}, status=status.HTTP_400_BAD_REQUEST)
backend/django/app/nexus/views.py:748:        mt5_base = (
backend/django/app/nexus/views.py:751:            or "http://mt5:5001"
backend/django/app/nexus/views.py:755:            r = requests.get(f"{str(mt5_base).rstrip('/')}/account_info", timeout=1.5)
backend/django/app/nexus/views.py:795:                "prev_close": equity_prev or None,
backend/django/app/nexus/views.py:814:        closed_today = Trade.objects.filter(close_time__gte=sod, close_time__isnull=False)
backend/django/app/nexus/views.py:815:        pnl_today = sum([t.pnl or 0 for t in closed_today])
backend/django/app/nexus/views.py:861:    """Intraday equity series derived from closed trades today.
backend/django/app/nexus/views.py:871:        qs = Trade.objects.filter(close_time__gte=start_utc, close_time__lt=end_utc, close_time__isnull=False).order_by('close_time')
backend/django/app/nexus/views.py:878:                    'ts': t.close_time.isoformat() if t.close_time else None,
backend/django/app/nexus/views.py:943:            realized = float(sum([(t.pnl or 0.0) for t in Trade.objects.filter(close_time__gte=sod)]))
backend/django/app/nexus/views.py:960:            closed = Trade.objects.exclude(close_time__isnull=True).order_by('-close_time')[:50]
backend/django/app/nexus/views.py:963:            for t in closed:
backend/django/app/nexus/views.py:1009:        qs = Trade.objects.exclude(close_time__isnull=True).order_by('-close_time')[:limit]
backend/django/app/nexus/views.py:1013:                dur = int(((t.close_time - t.entry_time).total_seconds()) // 60) if t.entry_time and t.close_time else None
backend/django/app/nexus/views.py:1050:        if source == 'mt5':
backend/django/app/nexus/views.py:1062:                base = os.getenv("MT5_URL") or os.getenv("MT5_API_URL") or "http://mt5:5001"
backend/django/app/nexus/views.py:1143:                    'ts': (t.close_time or t.entry_time).isoformat() if (t.entry_time or t.close_time) else None,
backend/django/app/nexus/views.py:1147:                    'exit': float(t.close_price) if t.close_price is not None else None,
backend/django/app/nexus/views.py:1149:                    'status': 'closed' if t.close_time else 'open',
backend/django/app/nexus/views.py:1163:                req.GET['source'] = 'mt5'
backend/django/app/nexus/views.py:1184:    Returns [{ id, ts_open, ts_close, symbol, side, entry, exit, pnl, rr, strategy, session }]
backend/django/app/nexus/views.py:1201:                    'ts_close': t.close_time.isoformat() if t.close_time else None,
backend/django/app/nexus/views.py:1205:                    'exit': float(t.close_price) if t.close_price is not None else None,
backend/django/app/nexus/views.py:1220:    type ∈ { market_snapshot, pulse_status, trades_recent, behavior_events, equity_today, session_boot, trades_history_mt5 }
backend/django/app/nexus/views.py:1228:        Supported verbs: session_boot, trades_recent, trades_history_mt5, account_info, account_positions,
backend/django/app/nexus/views.py:1253:            if typ == 'trades_history_mt5':
backend/django/app/nexus/views.py:1256:                req.GET['source'] = 'mt5'
backend/django/app/nexus/views.py:1319:            if not payload and typ in ('position_close', 'position_modify', 'position_open', 'position_hedge'):
backend/django/app/nexus/views.py:1457:            if typ == 'trades_history_mt5':
backend/django/app/nexus/views.py:1458:                # Proxy to TradeHistoryView with source=mt5 and optional filters
backend/django/app/nexus/views.py:1461:                req.GET['source'] = 'mt5'
backend/django/app/nexus/views.py:1532:            if typ == 'position_close':
backend/django/app/nexus/views.py:1535:                    from .orders_service import close_position_partial_or_full, get_position
backend/django/app/nexus/views.py:1544:                    # If pos is empty, proceed with best-effort close via proxy which can resolve volume itself.
backend/django/app/nexus/views.py:1547:                ok, data = close_position_partial_or_full(
backend/django/app/nexus/views.py:1807:                        "closed_winner_early": -5,
backend/django/app/nexus/views.py:1842:                .filter(pre_trade_confidence__isnull=False, trade__close_time__isnull=False)
backend/django/app/nexus/views.py:1856:        # Efficiency: average captured vs peak favorable excursion (last N closed)
backend/django/app/nexus/views.py:1859:            closed = Trade.objects.exclude(close_time__isnull=True).order_by('-close_time')[:N2]
backend/django/app/nexus/views.py:1861:            for t in closed:
backend/django/app/nexus/views.py:1873:            closed_today = Trade.objects.filter(close_time__gte=sod, close_time__isnull=False)
backend/django/app/nexus/views.py:1874:            pnl_today = float(sum([t.pnl or 0 for t in closed_today]))
backend/django/app/nexus/views.py:1876:            mt5_base = (
backend/django/app/nexus/views.py:1879:                or "http://mt5:5001"
backend/django/app/nexus/views.py:1883:                r = requests.get(f"{str(mt5_base).rstrip('/')}/account_info", timeout=1.5)
backend/django/app/nexus/views.py:1929:                    vals = [float(b.close or 0) for b in reversed(list(qs))]
backend/django/app/nexus/views.py:2034:                    closes = (
backend/django/app/nexus/views.py:2039:                        .get('close', [])
backend/django/app/nexus/views.py:2041:                    series = [float(x) for x in closes if x is not None]
backend/django/app/nexus/views.py:2091:def _mt5_bases():
backend/django/app/nexus/views.py:2100:        bases.append("http://mt5:5001")
backend/django/app/nexus/views.py:2112:        for base in _mt5_bases():
backend/django/app/nexus/views.py:2149:        for base in _mt5_bases():
backend/django/app/nexus/views.py:2257:            base = os.getenv("MT5_URL") or os.getenv("MT5_API_URL") or "http://mt5:5001"
backend/django/app/nexus/views.py:2295:        # If SoD still missing, derive from previous session close (SoD_yesterday + PnL_yesterday)
backend/django/app/nexus/views.py:2296:        prev_close_equity = None
backend/django/app/nexus/views.py:2307:                        close_time__gte=y_start_utc,
backend/django/app/nexus/views.py:2308:                        close_time__lt=y_end_utc,
backend/django/app/nexus/views.py:2309:                        close_time__isnull=False
backend/django/app/nexus/views.py:2313:                    prev_close_equity = sod_y + pnl_y
backend/django/app/nexus/views.py:2314:                    sod_equity = prev_close_equity
backend/django/app/nexus/views.py:2329:        # Previous close equity (prefer computed from previous session; else stored snapshot)
backend/django/app/nexus/views.py:2330:        if prev_close_equity is None and r is not None:
backend/django/app/nexus/views.py:2334:                    # If stored yesterday SoD; add pnl_y to estimate close
backend/django/app/nexus/views.py:2338:                            close_time__gte=y_start_utc,
backend/django/app/nexus/views.py:2339:                            close_time__lt=y_end_utc,
backend/django/app/nexus/views.py:2340:                            close_time__isnull=False
backend/django/app/nexus/views.py:2343:                    prev_close_equity = float(rawp) + pnl_y
backend/django/app/nexus/views.py:2345:                prev_close_equity = None
backend/django/app/nexus/views.py:2368:                base = os.getenv("MT5_URL") or os.getenv("MT5_API_URL") or "http://mt5:5001"
backend/django/app/nexus/views.py:2387:            'prev_close_equity': prev_close_equity,
backend/django/app/nexus/views.py:2437:                base = os.getenv("MT5_URL") or os.getenv("MT5_API_URL") or "http://mt5:5001"
backend/django/app/nexus/views.py:2542:    """Close full or partial position via MT5 bridge partial_close endpoint."""
backend/django/app/nexus/views.py:2554:            base = os.getenv("MT5_URL") or os.getenv("MT5_API_URL") or "http://mt5:5001"
backend/django/app/nexus/views.py:2557:            # Helper to fetch position details (for full close or fallbacks)
backend/django/app/nexus/views.py:2574:            # Prefer explicit volume if provided; else fraction; if neither provided, attempt full close by resolving volume from bridge
backend/django/app/nexus/views.py:2587:                # Full close intent: resolve current volume from bridge
backend/django/app/nexus/views.py:2594:                        payload['fraction'] = 0.99  # close nearly full if exact volume unavailable
backend/django/app/nexus/views.py:2602:                r = requests.post(f"{base}/partial_close_v2", json=payload, timeout=6.0)
backend/django/app/nexus/views.py:2619:            # 1) Legacy partial_close if available (requires symbol + fraction)
backend/django/app/nexus/views.py:2637:                    rl = requests.post(f"{base}/partial_close", json={'ticket': int(ticket), 'symbol': symbol, 'fraction': float(frac)}, timeout=6.0)
backend/django/app/nexus/views.py:2644:            # 2) If we can fetch the position, try legacy full-close endpoint which requires full position data
backend/django/app/nexus/views.py:2653:                    rc = requests.post(f"{base}/close_position", json={'position': position_payload}, timeout=6.0)
backend/django/app/nexus/views.py:2660:            # 3) As a last check, if position is no longer present, treat as already closed
backend/django/app/nexus/views.py:2664:                    return Response({'ok': True, 'note': 'position_not_found_after_retry_maybe_closed'})
backend/django/app/nexus/views.py:2916:            # Load recent closed trades
backend/django/app/nexus/views.py:2917:            qs = Trade.objects.filter(close_time__gte=since).order_by('entry_time')
backend/django/app/nexus/views.py:2926:                    gap_min = (cur.entry_time - prev.close_time).total_seconds() / 60.0 if (cur.entry_time and prev.close_time) else 999
backend/django/app/nexus/views.py:3100:        base = os.getenv("MT5_URL") or os.getenv("MT5_API_URL") or "http://mt5:5001"
backend/django/app/nexus/views.py:3127:                actions.append({'label': 'Partial 25%', 'action': 'partial_close_25', 'params': {'ticket': ticket, 'symbol': sym, 'fraction': 0.25}})
backend/django/app/nexus/views.py:3128:                actions.append({'label': 'Partial 50%', 'action': 'partial_close_50', 'params': {'ticket': ticket, 'symbol': sym, 'fraction': 0.50}})
backend/django/app/nexus/views.py:3134:                if bars is not None and not bars.empty and {'high','low','close'}.issubset(set(bars.columns)):
backend/django/app/nexus/views.py:3214:            or "http://mt5:5000"
backend/django/app/nexus/views.py:3236:            or "http://mt5:5000"
backend/mt5/scripts/07-start-wine-flask.sh:11:wine python /app/app.py >> /var/log/mt5_setup.log 2>&1 &
backend/mt5/scripts/07-start-wine-flask.sh:27:if [ "${ENABLE_MT5_GATEWAY:-0}" = "1" ] && [ -f "/opt/mt5_gateway/app.py" ]; then
backend/mt5/scripts/07-start-wine-flask.sh:30:    if [ -f "/opt/mt5_gateway/requirements.txt" ]; then
backend/mt5/scripts/07-start-wine-flask.sh:31:        log_message "INFO" "Installing mt5_gateway requirements in Wine Python (non-fatal if already installed)."
backend/mt5/scripts/07-start-wine-flask.sh:32:        $wine_executable python -m pip install --no-cache-dir -r /opt/mt5_gateway/requirements.txt >> /var/log/mt5_setup.log 2>&1 || true
backend/mt5/scripts/07-start-wine-flask.sh:34:    log_message "INFO" "Starting uvicorn for mt5_gateway via Wine Python..."
backend/mt5/scripts/07-start-wine-flask.sh:35:    $wine_executable python -m uvicorn mt5_gateway.app:app --host 0.0.0.0 --port ${GATEWAY_PORT} >> /var/log/mt5_setup.log 2>&1 &
backend/mt5/scripts/07-start-wine-flask.sh:39:        log_message "INFO" "mt5_gateway (FastAPI) started successfully with PID $GATEWAY_PID on port ${GATEWAY_PORT}."
backend/mt5/scripts/07-start-wine-flask.sh:41:        log_message "ERROR" "Failed to start mt5_gateway (FastAPI). Check /var/log/mt5_setup.log"
backend/mt5/scripts/07-start-wine-flask.sh:44:    log_message "INFO" "mt5_gateway not enabled. Set ENABLE_MT5_GATEWAY=1 to start it (default port 5002)."
backend/django/app/nexus/orders_service.py:62:def close_position_partial_or_full(ticket: int, *, fraction: float | None = None, volume: float | None = None,
backend/django/app/nexus/orders_service.py:70:    return _post("/api/v1/orders/close", payload, idempotency_key=idempotency_key)
backend/mt5/scripts/01-start.sh:8:/scripts/04-install-mt5.sh
backend/django/app/components/wyckoff_agents.py:24:        c = df["close"].values
backend/django/app/nexus/models.py:47:    close_time = models.DateTimeField(null=True, blank=True)
backend/django/app/nexus/models.py:48:    close_price = models.FloatField(null=True, blank=True)
backend/django/app/nexus/models.py:66:    trade = models.ForeignKey(Trade, on_delete=models.CASCADE, related_name='close_prices_mutations')
backend/django/app/nexus/models.py:106:    close = models.FloatField()
backend/django/app/nexus/filters.py:9:    close_time_after = filters.DateTimeFilter(field_name='close_time', lookup_expr='gte')
backend/django/app/nexus/filters.py:10:    close_time_before = filters.DateTimeFilter(field_name='close_time', lookup_expr='lte')
backend/django/app/nexus/filters.py:26:    is_open = filters.BooleanFilter(field_name='close_time', lookup_expr='isnull')
backend/django/app/nexus/tasks.py:50:                "close": row["close"],
backend/django/app/nexus/tasks.py:66:        base = os.getenv("MT5_URL") or os.getenv("MT5_API_URL") or "http://mt5:5001"
backend/django/app/nexus/tasks.py:91:    from bridge.mt5 import modify_position
backend/django/app/components/smc_analyser.py:87:            if df['close'].iloc[i] < df['open'].iloc[i]:  # Down candle
backend/django/app/components/smc_analyser.py:90:                if (future_high - df['close'].iloc[i]) / df['close'].iloc[i] > min_move:
backend/django/app/components/smc_analyser.py:97:                        'strength': (future_high - df['close'].iloc[i]) / df['close'].iloc[i]
backend/django/app/components/smc_analyser.py:101:            elif df['close'].iloc[i] > df['open'].iloc[i]:  # Up candle
backend/django/app/components/smc_analyser.py:104:                if (df['close'].iloc[i] - future_low) / df['close'].iloc[i] > min_move:
backend/django/app/components/smc_analyser.py:111:                        'strength': (df['close'].iloc[i] - future_low) / df['close'].iloc[i]
backend/django/app/components/smc_analyser.py:123:            if gap_size > 0 and gap_size / df['close'].iloc[i] > min_gap_size:
backend/django/app/components/smc_analyser.py:136:            if gap_size > 0 and gap_size / df['close'].iloc[i] > min_gap_size:
backend/django/app/components/smc_analyser.py:227:                            reversal = after_max['close'].iloc[-1] < zone['level']
backend/django/app/components/smc_analyser.py:247:                            reversal = after_min['close'].iloc[-1] > zone['level']
backend/django/app/components/smc_analyser.py:273:                if df['close'].iloc[i] > df['open'].iloc[i]:
backend/django/app/components/smc_analyser.py:285:                    'close': df['close'].iloc[i]
backend/django/app/components/smc_analyser.py:367:        avg_price = recent_data['close'].mean()
backend/django/app/components/smc_analyser.py:368:        price_position = (recent_data['close'].iloc[-1] - recent_data['low'].min()) / price_range
backend/django/app/components/smc_analyser.py:376:        sma_20 = recent_data['close'].rolling(20).mean()
backend/django/app/components/smc_analyser.py:377:        sma_50 = recent_data['close'].rolling(50).mean() if len(recent_data) >= 50 else sma_20
backend/django/app/components/smc_analyser.py:387:            if sma_20.iloc[-1] > sma_50.iloc[-1] and recent_data['close'].iloc[-1] > sma_20.iloc[-1]:
backend/django/app/components/smc_analyser.py:389:            elif sma_20.iloc[-1] < sma_50.iloc[-1] and recent_data['close'].iloc[-1] < sma_20.iloc[-1]:
backend/django/app/components/smc_analyser.py:449:        prev_trend = df['close'].iloc[i-50:i].mean() > df['close'].iloc[i-25:i].mean()
backend/django/app/components/smc_analyser.py:461:        price_drop = (df['close'].iloc[i] - df['close'].iloc[i-5]) / df['close'].iloc[i-5] < -0.02
backend/django/app/components/smc_analyser.py:465:            reversal = df['close'].iloc[i+5] > df['close'].iloc[i]
backend/django/app/components/smc_analyser.py:528:                    if df['close'].iloc[i+5] > range_low:
backend/django/app/components/smc_analyser.py:543:                    if df['close'].iloc[i+5] < range_high:
backend/django/app/components/smc_analyser.py:561:            if df['close'].iloc[i] > df['close'].iloc[i-1]:
backend/django/app/components/smc_analyser.py:562:                price_change = (df['close'].iloc[i] - df['close'].iloc[i-5]) / df['close'].iloc[i-5]
backend/django/app/components/smc_analyser.py:570:                        'price': df['close'].iloc[i],
backend/django/app/components/smc_analyser.py:575:            elif df['close'].iloc[i] < df['close'].iloc[i-1]:
backend/django/app/components/smc_analyser.py:576:                price_change = (df['close'].iloc[i] - df['close'].iloc[i-5]) / df['close'].iloc[i-5]
backend/django/app/components/smc_analyser.py:584:                        'price': df['close'].iloc[i],
backend/django/app/components/smc_analyser.py:600:            avg_price = window['close'].mean()
backend/django/app/components/smc_analyser.py:644:            price_change = abs(df['close'].iloc[i] - df['open'].iloc[i]) / df['open'].iloc[i]
backend/django/app/components/smc_analyser.py:671:                    'price_direction': 'up' if df['close'].iloc[i] > df['open'].iloc[i] else 'down'
backend/django/app/components/smc_analyser.py:690:                if df['close'].iloc[breakout_idx + 10] > range_info['high'] * 1.02:
backend/django/app/components/smc_analyser.py:867:        current_price = df['close'].iloc[-1]
backend/django/app/nexus/urls.py:121:    path('positions/partial_close', PositionsPartialCloseView.as_view(), name='positions-partial-close'),
backend/django/app/nexus/urls.py:143:    path('positions/close', PositionsCloseView.as_view(), name='positions-close'),
backend/django/app/nexus/urls.py:154:    path('orders/close', OrderCloseProxyView.as_view(), name='orders-close'),
backend/django/app/settings.py:232:    'run-quant-close-algorithm': {
backend/django/app/settings.py:233:        'task': 'quant.tasks.run_quant_close_algorithm',  # This should match the @shared_task name
backend/django/app/components/volume_profile_analyzer.py:147:        current_price = df['close'].iloc[-1]
backend/mt5/scripts/02-common.sh:4:mt5setup_url="https://download.mql5.com/cdn/web/metaquotes.software.corp/mt5/mt5setup.exe"
backend/mt5/scripts/02-common.sh:5:mt5file="/config/.wine/drive_c/Program Files/MetaTrader 5/terminal64.exe"
backend/mt5/scripts/02-common.sh:9:mt5server_port=18812
backend/mt5/scripts/02-common.sh:15:    echo "$(date '+%Y-%m-%d %H:%M:%S') - [$level] $message" >> /var/log/mt5_setup.log
backend/django/app/components/chart_builder.py:75:                    close=df['close'],
backend/django/app/components/chart_builder.py:90:                    close=ha_df['ha_close'],
backend/django/app/components/chart_builder.py:101:                    y=df['close'],
backend/django/app/components/chart_builder.py:115:            colors = [CANDLE_UP_COLOR if close >= open else CANDLE_DOWN_COLOR
backend/django/app/components/chart_builder.py:116:                     for close, open in zip(df['close'], df['open'])]
backend/django/app/components/chart_builder.py:156:        ha_df['ha_close'] = (df['open'] + df['high'] + df['low'] + df['close']) / 4
backend/django/app/components/chart_builder.py:158:        ha_df['ha_open'] = (df['open'].shift(1) + df['close'].shift(1)) / 2
backend/django/app/components/chart_builder.py:159:        ha_df['ha_open'].iloc[0] = (df['open'].iloc[0] + df['close'].iloc[0]) / 2
backend/django/app/components/chart_builder.py:161:        ha_df['ha_high'] = ha_df[['high', 'ha_open', 'ha_close']].max(axis=1)
backend/django/app/components/chart_builder.py:162:        ha_df['ha_low'] = ha_df[['low', 'ha_open', 'ha_close']].min(axis=1)
backend/django/app/components/chart_builder.py:182:                std = df['close'].std()
backend/django/app/components/chart_builder.py:328:                        close=df['close'],
backend/django/app/components/chart_builder.py:340:                    sma = df['close'].rolling(window=sma_period).mean()
backend/django/app/components/chart_builder.py:374:                close=df['close'],
backend/django/app/nexus/serializers.py:24:    close_prices_mutations = TradeClosePricesMutationSerializer(many=True, read_only=True)
backend/django/app/nexus/playbook_stub_views.py:88:            "equity_close": 100350,
backend/django/app/nexus/management/commands/sync_mt5_trades.py:39:    help = "Sync closed MT5 deals into the Trade model (best-effort aggregation by position)."
backend/django/app/nexus/management/commands/sync_mt5_trades.py:46:        base = os.getenv("MT5_URL") or os.getenv("MT5_API_URL") or "http://mt5:5001"
backend/django/app/nexus/management/commands/sync_mt5_trades.py:99:                ts_close = _parse_ts(deals_sorted[-1].get("time") if deals_sorted else None)
backend/django/app/nexus/management/commands/sync_mt5_trades.py:101:                price_close = None
backend/django/app/nexus/management/commands/sync_mt5_trades.py:133:                            price_close = float(d.get("price") or d.get("price_close") or 0.0)
backend/django/app/nexus/management/commands/sync_mt5_trades.py:135:                            price_close = 0.0
backend/django/app/nexus/management/commands/sync_mt5_trades.py:139:                if price_close is None:
backend/django/app/nexus/management/commands/sync_mt5_trades.py:140:                    price_close = 0.0
backend/django/app/nexus/management/commands/sync_mt5_trades.py:155:                    "entry_time": ts_open or ts_close or datetime.now(timezone.utc),
backend/django/app/nexus/management/commands/sync_mt5_trades.py:165:                    "close_time": ts_close,
backend/django/app/nexus/management/commands/sync_mt5_trades.py:166:                    "close_price": float(price_close or 0.0),
backend/mt5/scripts/04-install-mt5.sh:5:log_message "RUNNING" "04-install-mt5.sh"
backend/mt5/scripts/04-install-mt5.sh:8:if [ -e "$mt5file" ]; then
backend/mt5/scripts/04-install-mt5.sh:9:    log_message "INFO" "File $mt5file already exists."
backend/mt5/scripts/04-install-mt5.sh:11:    log_message "INFO" "File $mt5file is not installed. Installing..."
backend/mt5/scripts/04-install-mt5.sh:16:    wget -O /tmp/mt5setup.exe $mt5setup_url > /dev/null 2>&1
backend/mt5/scripts/04-install-mt5.sh:18:    $wine_executable /tmp/mt5setup.exe /auto
backend/mt5/scripts/04-install-mt5.sh:19:    rm -f /tmp/mt5setup.exe
backend/mt5/scripts/04-install-mt5.sh:23:if [ -e "$mt5file" ]; then
backend/mt5/scripts/04-install-mt5.sh:24:    log_message "INFO" "File $mt5file is installed. Running MT5..."
backend/mt5/scripts/04-install-mt5.sh:25:    $wine_executable "$mt5file" &
backend/mt5/scripts/04-install-mt5.sh:27:    log_message "ERROR" "File $mt5file is not installed. MT5 cannot be run."
backend/django/app/nexus/views_positions.py:9:    close_position_partial_or_full,
backend/django/app/nexus/views_positions.py:14:from bridge.mt5 import modify_position
backend/django/app/nexus/views_positions.py:61:    """POST /api/v1/positions/close
backend/django/app/nexus/views_positions.py:64:    If neither fraction nor volume is provided → full close.
backend/django/app/nexus/views_positions.py:80:        ok, data = close_position_partial_or_full(
backend/django/app/nexus/views_positions.py:122:                tags=["position_close", "partial" if action == "PARTIAL_CLOSE" else "full"],
backend/django/app/components/wyckoff_analyzer.py:34:        avg_price = recent_data['close'].mean()
backend/django/app/components/wyckoff_analyzer.py:35:        price_position = (recent_data['close'].iloc[-1] - recent_data['low'].min()) / price_range
backend/django/app/components/wyckoff_analyzer.py:43:        sma_20 = recent_data['close'].rolling(20).mean()
backend/django/app/components/wyckoff_analyzer.py:44:        sma_50 = recent_data['close'].rolling(50).mean() if len(recent_data) >= 50 else sma_20
backend/django/app/components/wyckoff_analyzer.py:54:            if sma_20.iloc[-1] > sma_50.iloc[-1] and recent_data['close'].iloc[-1] > sma_20.iloc[-1]:
backend/django/app/components/wyckoff_analyzer.py:56:            elif sma_20.iloc[-1] < sma_50.iloc[-1] and recent_data['close'].iloc[-1] < sma_20.iloc[-1]:
backend/django/app/components/wyckoff_analyzer.py:116:        prev_trend = df['close'].iloc[i-50:i].mean() > df['close'].iloc[i-25:i].mean()
backend/django/app/components/wyckoff_analyzer.py:128:        price_drop = (df['close'].iloc[i] - df['close'].iloc[i-5]) / df['close'].iloc[i-5] < -0.02
backend/django/app/components/wyckoff_analyzer.py:132:            reversal = df['close'].iloc[i+5] > df['close'].iloc[i]
backend/django/app/components/wyckoff_analyzer.py:195:                    if df['close'].iloc[i+5] > range_low:
backend/django/app/components/wyckoff_analyzer.py:210:                    if df['close'].iloc[i+5] < range_high:
backend/django/app/components/wyckoff_analyzer.py:228:            if df['close'].iloc[i] > df['close'].iloc[i-1]:
backend/django/app/components/wyckoff_analyzer.py:229:                price_change = (df['close'].iloc[i] - df['close'].iloc[i-5]) / df['close'].iloc[i-5]
backend/django/app/components/wyckoff_analyzer.py:237:                        'price': df['close'].iloc[i],
backend/django/app/components/wyckoff_analyzer.py:242:            elif df['close'].iloc[i] < df['close'].iloc[i-1]:
backend/django/app/components/wyckoff_analyzer.py:243:                price_change = (df['close'].iloc[i] - df['close'].iloc[i-5]) / df['close'].iloc[i-5]
backend/django/app/components/wyckoff_analyzer.py:251:                        'price': df['close'].iloc[i],
backend/django/app/components/wyckoff_analyzer.py:267:            avg_price = window['close'].mean()
backend/django/app/components/wyckoff_analyzer.py:311:            price_change = abs(df['close'].iloc[i] - df['open'].iloc[i]) / df['open'].iloc[i]
backend/django/app/components/wyckoff_analyzer.py:338:                    'price_direction': 'up' if df['close'].iloc[i] > df['open'].iloc[i] else 'down'
backend/django/app/components/wyckoff_analyzer.py:357:                if df['close'].iloc[breakout_idx + 10] > range_info['high'] * 1.02:
backend/django/app/components/technical_analysis.py:23:        if df.empty or df['close'].nunique() <= 1:
backend/django/app/components/technical_analysis.py:30:        results['sma_20'] = ta.trend.sma_indicator(df['close'], window=20)
backend/django/app/components/technical_analysis.py:31:        results['sma_50'] = ta.trend.sma_indicator(df['close'], window=50)
backend/django/app/components/technical_analysis.py:32:        results['sma_200'] = ta.trend.sma_indicator(df['close'], window=200)
backend/django/app/components/technical_analysis.py:33:        results['ema_20'] = ta.trend.ema_indicator(df['close'], window=20)
backend/django/app/components/technical_analysis.py:34:        results['ema_50'] = ta.trend.ema_indicator(df['close'], window=50)
backend/django/app/components/technical_analysis.py:37:        macd = ta.trend.MACD(df['close'])
backend/django/app/components/technical_analysis.py:43:        results['rsi'] = ta.momentum.RSIIndicator(df['close']).rsi()
backend/django/app/components/technical_analysis.py:46:        bb = ta.volatility.BollingerBands(df['close'])
backend/django/app/components/technical_analysis.py:53:        results['atr'] = ta.volatility.AverageTrueRange(df['high'], df['low'], df['close']).average_true_range()
backend/django/app/components/technical_analysis.py:57:        results['mfi'] = ta.volume.MFIIndicator(df['high'], df['low'], df['close'], df['volume']).money_flow_index()
backend/django/app/components/technical_analysis.py:89:            'resistance': [l for l in levels if l > df['close'].iloc[-1]],
backend/django/app/components/technical_analysis.py:90:            'support': [l for l in levels if l < df['close'].iloc[-1]]
backend/django/app/components/technical_analysis.py:117:        close = df['close'].iloc[-1]
backend/django/app/components/technical_analysis.py:120:        pp = (high + low + close) / 3
backend/django/app/components/technical_analysis.py:145:        close_prices = df['close'].values
backend/django/app/components/technical_analysis.py:148:        body_size = abs(close_prices - open_prices)
backend/django/app/components/technical_analysis.py:154:        lower_shadow = np.minimum(open_prices, close_prices) - low_prices
backend/django/app/components/technical_analysis.py:155:        upper_shadow = high_prices - np.maximum(open_prices, close_prices)
backend/django/app/components/technical_analysis.py:160:                (close_prices[1:] > open_prices[1:]) &
backend/django/app/components/technical_analysis.py:161:                (close_prices[:-1] < open_prices[:-1]) &
backend/django/app/components/technical_analysis.py:162:                (open_prices[1:] < close_prices[:-1]) &
backend/django/app/components/technical_analysis.py:163:                (close_prices[1:] > open_prices[:-1])
backend/django/app/components/technical_analysis.py:193:            sma_20 = ta.trend.sma_indicator(df['close'], window=20)
backend/django/app/components/technical_analysis.py:194:            sma_50 = ta.trend.sma_indicator(df['close'], window=50)
backend/django/app/components/technical_analysis.py:197:                current_price = df['close'].iloc[-1]
backend/django/app/components/technical_analysis.py:211:            rsi = ta.momentum.RSIIndicator(df['close']).rsi()
backend/django/app/quant/indicators/mean_reversion.py:9:    - data (pd.DataFrame): DataFrame containing at least a 'close' column with closing prices.
backend/django/app/quant/indicators/mean_reversion.py:17:    # Ensure the DataFrame has a 'close' column
backend/django/app/quant/indicators/mean_reversion.py:18:    if 'close' not in data.columns:
backend/django/app/quant/indicators/mean_reversion.py:19:        raise ValueError("DataFrame must contain a 'close' column.")
backend/django/app/quant/indicators/mean_reversion.py:22:    rolling_mean = data['close'].rolling(window=window).mean()
backend/django/app/quant/indicators/mean_reversion.py:23:    rolling_std = data['close'].rolling(window=window).std()
backend/django/app/quant/indicators/mean_reversion.py:34:        previous_close = data['close'].iloc[idx - 1]
backend/django/app/quant/indicators/mean_reversion.py:35:        current_close = data['close'].iloc[idx]
backend/django/app/quant/indicators/mean_reversion.py:42:        if (previous_close <= previous_upper) and (current_close > current_upper):
backend/django/app/quant/indicators/mean_reversion.py:46:        elif (previous_close >= previous_lower) and (current_close < current_lower):
backend/django/app/utils/constants.py:75:    TRADE_RETCODE_MARKET_CLOSED= "Market is closed",
backend/django/app/utils/constants.py:93:    TRADE_RETCODE_POSITION_CLOSED= "Position with the specified POSITION_IDENTIFIER has already been closed",
backend/django/app/utils/constants.py:94:    TRADE_RETCODE_INVALID_CLOSE_VOLUME= "A close volume exceeds the current position volume",
backend/django/app/utils/constants.py:95:    TRADE_RETCODE_CLOSE_ORDER_EXIST= "A close order already exists for a specified position",
backend/django/app/components/wyckoff_adaptive.py:55:    ret = out["close"].pct_change().fillna(0.0)
backend/django/app/components/wyckoff_adaptive.py:60:    ma = out["close"].rolling(win).mean()
backend/django/app/components/wyckoff_adaptive.py:61:    sd = out["close"].rolling(win).std()
backend/django/app/components/wyckoff_adaptive.py:64:    pctB = (out["close"] - lower) / ((upper - lower) + 1e-12)
backend/django/app/components/wyckoff_adaptive.py:100:    ret_fwd = _nz(feat["close"].pct_change().rolling(3).sum().shift(-3).values)
backend/django/app/components/timeframe_converter.py:54:            'close': 'last',
backend/django/app/components/timeframe_converter.py:110:                    'close': df['close'].iloc[last_idx],
backend/django/app/quant/tasks.py:9:from app.quant.algorithms.close.close import close_algorithm
backend/django/app/quant/tasks.py:33:@shared_task(name='quant.tasks.run_quant_close_algorithm', max_retries=3, soft_time_limit=30)
backend/django/app/quant/tasks.py:34:def run_quant_close_algorithm():
backend/django/app/quant/tasks.py:36:        logger.info("Starting quant close algorithm...")
backend/django/app/quant/tasks.py:37:        close_algorithm()
backend/django/app/quant/tasks.py:41:        logger.error(f"Error in quant close algorithm: {e}")
backend/django/app/utils/arithmetics.py:185:        commission = order_size_usd * commission_rate # Total commission for both open and close
backend/django/app/nexus/pulse/service.py:47:    for c in ['open', 'high', 'low', 'close']:
backend/django/app/nexus/pulse/service.py:65:    return df[['timestamp', 'open', 'high', 'low', 'close', 'volume']].copy()
backend/django/app/nexus/pulse/service.py:71:    Returns dict of pandas DataFrames with columns: timestamp, open, high, low, close, volume.
backend/django/app/nexus/pulse/service.py:91:                df = _p.DataFrame(list(qs.values('time', 'open', 'high', 'low', 'close', 'real_volume', 'tick_volume')))
backend/django/app/nexus/pulse/views.py:244:                df["ret_close_pct"] = _p.to_numeric(df["close"], errors='coerce').pct_change().fillna(0.0)
backend/django/app/nexus/pulse/views.py:249:                df["sma20"] = _p.to_numeric(df['close'], errors='coerce').rolling(20, min_periods=3).mean()
backend/django/app/nexus/pulse/views.py:250:                df["sma50"] = _p.to_numeric(df['close'], errors='coerce').rolling(50, min_periods=3).mean()
backend/django/app/nexus/pulse/views.py:252:                tp = (_p.to_numeric(df['high'], errors='coerce') + _p.to_numeric(df['low'], errors='coerce') + _p.to_numeric(df['close'], errors='coerce')) / 3.0
backend/django/app/nexus/pulse/views.py:287:                    "close": float(row.get('close') or 0),
backend/django/app/nexus/pulse/views.py:289:                    "ret_close_pct": float(row.get('ret_close_pct')) if 'ret_close_pct' in df.columns and _p.notna(row.get('ret_close_pct')) else None,
backend/django/app/nexus/pulse/views.py:349:          trade:history:recent, mt5:history:recent, pulse:trades:recent
backend/django/app/nexus/pulse/views.py:365:                for key in ("trade:history:recent", "mt5:history:recent", "pulse:trades:recent"):
backend/django/app/nexus/pulse/views.py:441:    # Use close_time when present, fallback to entry_time
backend/django/app/nexus/pulse/views.py:521:                if tr.entry_time and tr.close_time:
backend/django/app/nexus/pulse/views.py:522:                    durs.append((tr.close_time - tr.entry_time).total_seconds())
backend/django/app/nexus/pulse/views.py:646:                    "close": float(row.get('Close') or row.get('close') or 0),
backend/django/app/utils/market.py:10:        # Check whether the market is open, if it's a crypto then market doesn't close
backend/django/app/utils/db/close.py:8:def close_trade(ticket, close_time, close_price, pnl, pnl_excluding_commission, closing_reason, closed_deal):
backend/django/app/utils/db/close.py:17:        trade.close_time = close_time
backend/django/app/utils/db/close.py:18:        trade.close_price = close_price
backend/django/app/utils/db/close.py:24:        trade.max_drawdown = closed_deal.get('max_drawdown', trade.max_drawdown)
backend/django/app/utils/db/close.py:25:        trade.max_profit = closed_deal.get('max_profit', trade.max_profit)
backend/django/app/utils/db/close.py:30:        # Send a notification about the closed trade
backend/django/app/utils/db/close.py:32:            "event": "trade_closed",
backend/django/app/utils/db/close.py:35:            "close_time": trade.close_time.isoformat(),
backend/django/app/utils/db/close.py:36:            "close_price": str(trade.close_price),
backend/django/app/quant/algorithms/close/close.py:11:from app.utils.db.close import close_trade
backend/django/app/quant/algorithms/close/close.py:18:def close_algorithm():
backend/django/app/quant/algorithms/close/close.py:20:    Continuously monitors open trades, detects closed trades, and updates their
backend/django/app/quant/algorithms/close/close.py:41:        # Detect closed trades by comparing cached_positions with current positions
backend/django/app/quant/algorithms/close/close.py:45:        # Identify closed tickets
backend/django/app/quant/algorithms/close/close.py:46:        closed_tickets = cached_tickets - current_tickets
backend/django/app/quant/algorithms/close/close.py:48:        for ticket in closed_tickets:
backend/django/app/quant/algorithms/close/close.py:53:                # Retrieve the closed order and deal details
backend/django/app/quant/algorithms/close/close.py:54:                closed_order = get_order_from_ticket(ticket)
backend/django/app/quant/algorithms/close/close.py:55:                closed_deal = get_deal_from_ticket(ticket)
backend/django/app/quant/algorithms/close/close.py:57:                if closed_deal is None:
backend/django/app/quant/algorithms/close/close.py:58:                    error_msg = f"Failed to retrieve deal for closed ticket {ticket}."
backend/django/app/quant/algorithms/close/close.py:67:                close_time = closed_deal.get('time', current_time)
backend/django/app/quant/algorithms/close/close.py:68:                close_price = closed_deal.get('price', position.price_current)
backend/django/app/quant/algorithms/close/close.py:69:                pnl = closed_deal.get('profit', position.profit)
backend/django/app/quant/algorithms/close/close.py:70:                pnl_excluding_commission = pnl - closed_deal.get('commission', 0)
backend/django/app/quant/algorithms/close/close.py:71:                closing_reason = closed_deal.get('reason', 'CLOSED')
backend/django/app/quant/algorithms/close/close.py:74:                closed_trade = close_trade(position.ticket, close_time, close_price, pnl, pnl_excluding_commission, closing_reason, closed_deal)
backend/django/app/quant/algorithms/close/close.py:76:                if closed_trade is not None:
backend/django/app/quant/algorithms/close/close.py:78:                        "event": "trade_closed",
backend/django/app/quant/algorithms/close/close.py:79:                        "trade_id": closed_trade.id,
backend/django/app/quant/algorithms/close/close.py:80:                        "symbol": closed_trade.symbol,
backend/django/app/quant/algorithms/close/close.py:83:                    error_msg = f"Failed to close trade {ticket}."
backend/django/app/quant/algorithms/close/close.py:87:                error_msg = f"Error processing closed ticket {ticket}: {e}\n{traceback.format_exc()}"
backend/django/app/quant/algorithms/close/close.py:95:        error_msg = f"Exception in close_algorithm: {e}\n{traceback.format_exc()}"
backend/mt5/app/routes/history.py:2:import MetaTrader5 as mt5
backend/mt5/app/routes/history.py:34:                    'close_time': {'type': 'string', 'format': 'date-time'},
backend/mt5/app/routes/history.py:36:                    'close_price': {'type': 'number'},
backend/mt5/app/routes/history.py:207:        deals = mt5.history_deals_get(from_timestamp, to_timestamp, position=position)
backend/mt5/app/routes/history.py:267:        orders = mt5.history_orders_get(ticket=ticket)
backend/mt5/app/app.py:5:import MetaTrader5 as mt5
backend/mt5/app/app.py:30:def _ensure_mt5():
backend/mt5/app/app.py:34:        mt5.initialize()
backend/mt5/app/app.py:44:                ai = mt5.account_info()
backend/mt5/app/app.py:55:                    mt5.login(login=int(login_env), password=password_env, server=server_env)
backend/mt5/app/app.py:65:    _ensure_mt5()
backend/mt5/app/app.py:66:    info = mt5.account_info()
backend/mt5/app/app.py:68:        return jsonify({"error": "mt5.account_info() unavailable"}), 503
backend/mt5/app/app.py:73:    _ensure_mt5()
backend/mt5/app/app.py:74:    tick = mt5.symbol_info_tick(symbol)
backend/mt5/app/app.py:81:    _ensure_mt5()
backend/mt5/app/app.py:82:    positions = mt5.positions_get()
backend/mt5/app/app.py:101:            if t in (mt5.ORDER_TYPE_BUY, mt5.ORDER_TYPE_SELL):
backend/mt5/app/app.py:107:                return mt5.ORDER_TYPE_BUY
backend/mt5/app/app.py:109:                return mt5.ORDER_TYPE_SELL
backend/mt5/app/app.py:121:    _ensure_mt5()
backend/mt5/app/app.py:122:    tick = mt5.symbol_info_tick(symbol)
backend/mt5/app/app.py:125:    price = tick.ask if order_type == mt5.ORDER_TYPE_BUY else tick.bid
backend/mt5/app/app.py:127:        'action': mt5.TRADE_ACTION_DEAL,
backend/mt5/app/app.py:133:        'type_time': mt5.ORDER_TIME_GTC,
backend/mt5/app/app.py:134:        'type_filling': mt5.ORDER_FILLING_IOC,
backend/mt5/app/app.py:136:    res = mt5.order_send(req)
backend/mt5/app/app.py:137:    if res and getattr(res, 'retcode', None) == mt5.TRADE_RETCODE_DONE:
backend/mt5/app/app.py:142:    _ensure_mt5()
backend/mt5/app/app.py:143:    for p in (mt5.positions_get() or []):
backend/mt5/app/app.py:164:def compat_partial_close_v2():
backend/mt5/app/app.py:178:        vol_to_close = float(vol_req) if vol_req is not None else float(pos.volume) * float(fraction)
backend/mt5/app/app.py:182:    sinfo = mt5.symbol_info(pos.symbol)
backend/mt5/app/app.py:185:    steps = max(1, int(vol_to_close / vol_step + 1e-9))
backend/mt5/app/app.py:186:    vol_to_close = steps * vol_step
backend/mt5/app/app.py:187:    if vol_to_close < vol_min:
backend/mt5/app/app.py:188:        return jsonify({'error': 'computed close volume below minimum', 'min': vol_min}), 400
backend/mt5/app/app.py:189:    if vol_to_close > float(pos.volume):
backend/mt5/app/app.py:190:        vol_to_close = float(pos.volume)
backend/mt5/app/app.py:191:    opposite = mt5.ORDER_TYPE_SELL if int(pos.type) == mt5.ORDER_TYPE_BUY else mt5.ORDER_TYPE_BUY
backend/mt5/app/app.py:192:    return _send_deal(pos.symbol, float(vol_to_close), opposite)
backend/mt5/app/app.py:194:def compat_partial_close():
backend/mt5/app/app.py:207:    opposite = mt5.ORDER_TYPE_SELL if int(pos.type) == mt5.ORDER_TYPE_BUY else mt5.ORDER_TYPE_BUY
backend/mt5/app/app.py:208:    vol_to_close = float(pos.volume) * fraction
backend/mt5/app/app.py:209:    return _send_deal(symbol or pos.symbol, float(vol_to_close), opposite)
backend/mt5/app/app.py:211:def compat_close_position():
backend/mt5/app/app.py:221:    opposite = mt5.ORDER_TYPE_SELL if ptype == mt5.ORDER_TYPE_BUY else mt5.ORDER_TYPE_BUY
backend/mt5/app/app.py:229:if _route_missing('/partial_close_v2'):
backend/mt5/app/app.py:230:    app.add_url_rule('/partial_close_v2', view_func=compat_partial_close_v2, methods=['POST'])
backend/mt5/app/app.py:231:if _route_missing('/partial_close'):
backend/mt5/app/app.py:232:    app.add_url_rule('/partial_close', view_func=compat_partial_close, methods=['POST'])
backend/mt5/app/app.py:233:if _route_missing('/close_position'):
backend/mt5/app/app.py:234:    app.add_url_rule('/close_position', view_func=compat_close_position, methods=['POST'])
backend/mt5/app/app.py:258:        if not mt5.initialize():
backend/mt5/app/lib.py:1:import MetaTrader5 as mt5
backend/mt5/app/lib.py:20:def close_position(position, deviation=20, magic=0, comment='', type_filling=mt5.ORDER_FILLING_IOC):
backend/mt5/app/lib.py:26:        0: mt5.ORDER_TYPE_BUY,
backend/mt5/app/lib.py:27:        1: mt5.ORDER_TYPE_SELL
backend/mt5/app/lib.py:35:    tick = mt5.symbol_info_tick(position['symbol'])
backend/mt5/app/lib.py:51:        "action": mt5.TRADE_ACTION_DEAL,
backend/mt5/app/lib.py:52:        "position": position['ticket'],  # select the position you want to close
backend/mt5/app/lib.py:60:        "type_time": mt5.ORDER_TIME_GTC,
backend/mt5/app/lib.py:64:    order_result = mt5.order_send(request)
backend/mt5/app/lib.py:66:    if order_result.retcode != mt5.TRADE_RETCODE_DONE:
backend/mt5/app/lib.py:67:        logger.error(f"Failed to close position {position['ticket']}: {order_result.comment}")
backend/mt5/app/lib.py:70:    logger.info(f"Position {position['ticket']} closed successfully.")
backend/mt5/app/lib.py:74:def close_all_positions(order_type='all', magic=None, type_filling=mt5.ORDER_FILLING_IOC):
backend/mt5/app/lib.py:76:        'BUY': mt5.ORDER_TYPE_BUY,
backend/mt5/app/lib.py:77:        'SELL': mt5.ORDER_TYPE_SELL
backend/mt5/app/lib.py:80:    if mt5.positions_total() > 0:
backend/mt5/app/lib.py:81:        positions = mt5.positions_get()
backend/mt5/app/lib.py:106:            order_result = close_position(position, type_filling=type_filling)
backend/mt5/app/lib.py:110:                logger.error(f"Failed to close position {position['ticket']}.")
backend/mt5/app/lib.py:114:        logger.error("No open positions to close.")
backend/mt5/app/lib.py:119:    if not mt5.initialize():
backend/mt5/app/lib.py:123:    total_positions = mt5.positions_total()
backend/mt5/app/lib.py:129:        positions = mt5.positions_get()
backend/mt5/app/lib.py:154:        to_date = datetime.now(mt5.TIMEZONE)
backend/mt5/app/lib.py:162:    deals = mt5.history_deals_get(from_timestamp, to_timestamp, position=ticket)
backend/mt5/app/lib.py:182:            'open_time': datetime.fromtimestamp(deals_df['time'].min(), tz=mt5.TIMEZONE),
backend/mt5/app/lib.py:183:            'close_time': datetime.fromtimestamp(deals_df['time'].max(), tz=mt5.TIMEZONE),
backend/mt5/app/lib.py:185:            'close_price': deals_df['price'].iloc[-1],
backend/mt5/app/lib.py:202:    order = mt5.history_orders_get(ticket=ticket)
backend/django/app/nexus/pulse/gates.py:50:        if float(last['close']) > hi:
backend/django/app/nexus/pulse/gates.py:52:        elif float(last['close']) < lo:
backend/django/app/nexus/pulse/gates.py:65:      then closes back inside the range within 3 bars.
backend/django/app/nexus/pulse/gates.py:124:                        # snap-back within next 3 bars: close back inside the Asia range
backend/django/app/nexus/pulse/gates.py:126:                        sb = nxt[nxt['close'] <= asia_high]
backend/django/app/nexus/pulse/gates.py:140:                        sb = nxt[nxt['close'] >= asia_low]
backend/django/app/nexus/pulse/gates.py:179:                    sb = nxt[nxt['close'] <= max(h for _, h in hi_piv)]
backend/django/app/nexus/pulse/gates.py:186:                    sb = nxt[nxt['close'] >= min(l for _, l in lo_piv)]
backend/django/app/nexus/pulse/gates.py:256:    # Last close / volume
backend/django/app/nexus/pulse/gates.py:257:    close_now = float(m1.iloc[-1]["close"])
backend/django/app/nexus/pulse/gates.py:264:    # Bullish CHoCH: prior downtrend (lower highs & lows) AND close > last pivot high with impulse volume
backend/django/app/nexus/pulse/gates.py:266:        close_now > last_hi
backend/django/app/nexus/pulse/gates.py:279:    # Bearish CHoCH: prior uptrend AND close < last pivot low with impulse volume
backend/django/app/nexus/pulse/gates.py:281:        close_now < last_lo
backend/django/app/nexus/pulse/gates.py:298:            if next_highs and close_now > max(next_highs):
backend/django/app/nexus/pulse/gates.py:302:            if next_lows and close_now < min(next_lows):
backend/django/app/nexus/pulse/journal/kafka_journal.py:15:    """Feature-flagged Kafka journal sink (fail-closed, no-throw).
backend/django/app/utils/api/ticket.py:78:            'close_time': datetime.fromtimestamp(deals_df['time'].max(), tz=TIMEZONE),
backend/django/app/utils/api/ticket.py:80:            'close_price': deals_df['price'].iloc[-1],
backend/django/app/quant/algorithms/mean_reversion/trailing.py:49:    Continuously monitors open trades, detects closed trades, manages trailing stops,
backend/django/app/quant/algorithms/mean_reversion/trailing.py:176:                            logger.info({'message': 'successfully modified sl from mt5 api', 'modify_request': modify_request, 'sl_info': sl_info})
backend/django/app/quant/algorithms/mean_reversion/trailing.py:185:                            logger.info({'message': 'failed to modify sl from mt5 api', 'sl_info': sl_info})
backend/mt5/app/routes/data.py:2:import MetaTrader5 as mt5
backend/mt5/app/routes/data.py:75:                        'close': {'type': 'number'},
backend/mt5/app/routes/data.py:108:        mt5_timeframe = get_timeframe(timeframe)
backend/mt5/app/routes/data.py:110:        rates = mt5.copy_rates_from_pos(symbol, mt5_timeframe, 0, num_bars)
backend/mt5/app/routes/data.py:173:                        'close': {'type': 'number'},
backend/mt5/app/routes/data.py:207:        mt5_timeframe = get_timeframe(timeframe)
backend/mt5/app/routes/data.py:214:        rates = mt5.copy_rates_range(symbol, mt5_timeframe, start_date, end_date)
backend/mt5/app/routes/data.py:239:    ticks = mt5.copy_ticks_from(
backend/mt5/app/routes/data.py:243:        mt5.COPY_TICKS_ALL,
backend/mt5/app/routes/data.py:272:        mt5_timeframe = get_timeframe(interval)
backend/mt5/app/routes/data.py:276:    rates = mt5.copy_rates_from_pos(symbol, mt5_timeframe, 0, limit)
backend/mt5/app/routes/error.py:3:import MetaTrader5 as mt5
backend/mt5/app/routes/error.py:35:        error = mt5.last_error()
backend/mt5/app/routes/error.py:66:        error_code, error_str = mt5.last_error()
backend/mt5/app/constants.py:2:import MetaTrader5 as mt5
backend/mt5/app/constants.py:5:    M1 = mt5.TIMEFRAME_M1       # 1-minute
backend/mt5/app/constants.py:6:    M5 = mt5.TIMEFRAME_M5       # 5-minute
backend/mt5/app/constants.py:7:    M15 = mt5.TIMEFRAME_M15     # 15-minute
backend/mt5/app/constants.py:8:    M30 = mt5.TIMEFRAME_M30     # 30-minute
backend/mt5/app/constants.py:9:    H1 = mt5.TIMEFRAME_H1       # 1-hour
backend/mt5/app/constants.py:10:    H4 = mt5.TIMEFRAME_H4       # 4-hour
backend/mt5/app/constants.py:11:    D1 = mt5.TIMEFRAME_D1       # daily
backend/mt5/app/constants.py:12:    W1 = mt5.TIMEFRAME_W1       # weekly
backend/mt5/app/constants.py:13:    MN1 = mt5.TIMEFRAME_MN1     # monthly
backend/mt5/app/constants.py:16:    mt5.TRADE_RETCODE_REQUOTE: "Requote",
backend/mt5/app/constants.py:17:    mt5.TRADE_RETCODE_REJECT: "Request rejected",
backend/mt5/app/constants.py:18:    mt5.TRADE_RETCODE_CANCEL: "Request canceled by trader",
backend/mt5/app/constants.py:19:    mt5.TRADE_RETCODE_PLACED: "Order placed",
backend/mt5/app/constants.py:20:    mt5.TRADE_RETCODE_DONE: "Request completed",
backend/mt5/app/constants.py:21:    mt5.TRADE_RETCODE_DONE_PARTIAL: "Only part of the request was completed",
backend/mt5/app/constants.py:22:    mt5.TRADE_RETCODE_ERROR: "Request processing error",
backend/mt5/app/constants.py:23:    mt5.TRADE_RETCODE_TIMEOUT: "Request canceled by timeout",
backend/mt5/app/constants.py:24:    mt5.TRADE_RETCODE_INVALID: "Invalid request",
backend/mt5/app/constants.py:25:    mt5.TRADE_RETCODE_INVALID_VOLUME: "Invalid volume in the request",
backend/mt5/app/constants.py:26:    mt5.TRADE_RETCODE_INVALID_PRICE: "Invalid price in the request",
backend/mt5/app/constants.py:27:    mt5.TRADE_RETCODE_INVALID_STOPS: "Invalid stops in the request",
backend/mt5/app/constants.py:28:    mt5.TRADE_RETCODE_TRADE_DISABLED: "Trade is disabled",
backend/mt5/app/constants.py:29:    mt5.TRADE_RETCODE_MARKET_CLOSED: "Market is closed",
backend/mt5/app/constants.py:30:    mt5.TRADE_RETCODE_NO_MONEY: "There is not enough money to complete the request",
backend/mt5/app/constants.py:31:    mt5.TRADE_RETCODE_PRICE_CHANGED: "Prices changed",
backend/mt5/app/constants.py:32:    mt5.TRADE_RETCODE_PRICE_OFF: "There are no quotes to process the request",
backend/mt5/app/constants.py:33:    mt5.TRADE_RETCODE_INVALID_EXPIRATION: "Invalid order expiration date in the request",
backend/mt5/app/constants.py:34:    mt5.TRADE_RETCODE_ORDER_CHANGED: "Order state changed",
backend/mt5/app/constants.py:35:    mt5.TRADE_RETCODE_TOO_MANY_REQUESTS: "Too frequent requests",
backend/mt5/app/constants.py:36:    mt5.TRADE_RETCODE_NO_CHANGES: "No changes in request",
backend/mt5/app/constants.py:37:    mt5.TRADE_RETCODE_SERVER_DISABLES_AT: "Autotrading disabled by server",
backend/mt5/app/constants.py:38:    mt5.TRADE_RETCODE_CLIENT_DISABLES_AT: "Autotrading disabled by client terminal",
backend/mt5/app/constants.py:39:    mt5.TRADE_RETCODE_LOCKED: "Request locked for processing",
backend/mt5/app/constants.py:40:    mt5.TRADE_RETCODE_FROZEN: "Order or position frozen",
backend/mt5/app/constants.py:41:    mt5.TRADE_RETCODE_INVALID_FILL: "Invalid order filling type",
backend/mt5/app/constants.py:42:    mt5.TRADE_RETCODE_CONNECTION: "No connection with the trade server",
backend/mt5/app/constants.py:43:    mt5.TRADE_RETCODE_ONLY_REAL: "Operation is allowed only for live accounts",
backend/mt5/app/constants.py:44:    mt5.TRADE_RETCODE_LIMIT_ORDERS: "The number of pending orders has reached the limit",
backend/mt5/app/constants.py:45:    mt5.TRADE_RETCODE_LIMIT_VOLUME: "The volume of orders and positions for the symbol has reached the limit",
backend/mt5/app/constants.py:46:    mt5.TRADE_RETCODE_INVALID_ORDER: "Incorrect or prohibited order type",
backend/mt5/app/constants.py:47:    mt5.TRADE_RETCODE_POSITION_CLOSED: "Position with the specified POSITION_IDENTIFIER has already been closed",
backend/mt5/app/constants.py:48:    mt5.TRADE_RETCODE_INVALID_CLOSE_VOLUME: "A close volume exceeds the current position volume",
backend/mt5/app/constants.py:49:    mt5.TRADE_RETCODE_CLOSE_ORDER_EXIST: "A close order already exists for a specified position",
backend/mt5/app/constants.py:50:    mt5.TRADE_RETCODE_LIMIT_POSITIONS: "The number of open positions simultaneously present on an account can be limited by the server settings",
backend/mt5/app/constants.py:51:    mt5.TRADE_RETCODE_REJECT_CANCEL: "The pending order activation request is rejected, the order is canceled",
backend/mt5/app/constants.py:52:    mt5.TRADE_RETCODE_LONG_ONLY: "The request is rejected, because the 'Only long positions are allowed' rule is set for the symbol",
backend/mt5/app/constants.py:53:    mt5.TRADE_RETCODE_SHORT_ONLY: "The request is rejected, because the 'Only short positions are allowed' rule is set for the symbol",
backend/mt5/app/constants.py:54:    mt5.TRADE_RETCODE_CLOSE_ONLY: "The request is rejected, because the 'Only position closing is allowed' rule is set for the symbol",
backend/mt5/app/constants.py:55:    mt5.TRADE_RETCODE_FIFO_CLOSE: "The request is rejected, because 'Position closing is allowed only by FIFO rule' flag is set for the trading account",
backend/mt5/app/routes/order.py:2:import MetaTrader5 as mt5
backend/mt5/app/routes/order.py:10:    Returns mt5.ORDER_TYPE_BUY or mt5.ORDER_TYPE_SELL, or None if invalid.
backend/mt5/app/routes/order.py:14:            if t in (mt5.ORDER_TYPE_BUY, mt5.ORDER_TYPE_SELL):
backend/mt5/app/routes/order.py:20:                return mt5.ORDER_TYPE_BUY
backend/mt5/app/routes/order.py:22:                return mt5.ORDER_TYPE_SELL
backend/mt5/app/routes/order.py:36:                'ORDER_FILLING_IOC': mt5.ORDER_FILLING_IOC,
backend/mt5/app/routes/order.py:37:                'ORDER_FILLING_FOK': mt5.ORDER_FILLING_FOK,
backend/mt5/app/routes/order.py:38:                'ORDER_FILLING_RETURN': mt5.ORDER_FILLING_RETURN,
backend/mt5/app/routes/order.py:40:            return mapping.get(s, mt5.ORDER_FILLING_IOC)
backend/mt5/app/routes/order.py:43:    return mt5.ORDER_FILLING_IOC
backend/mt5/app/routes/order.py:122:        type_filling = _normalize_filling(data.get('type_filling', mt5.ORDER_FILLING_IOC))
backend/mt5/app/routes/order.py:126:            "action": mt5.TRADE_ACTION_DEAL,
backend/mt5/app/routes/order.py:133:            "type_time": mt5.ORDER_TIME_GTC,
backend/mt5/app/routes/order.py:138:        tick = mt5.symbol_info_tick(data['symbol'])
backend/mt5/app/routes/order.py:143:        if order_type == mt5.ORDER_TYPE_BUY:
backend/mt5/app/routes/order.py:145:        elif order_type == mt5.ORDER_TYPE_SELL:
backend/mt5/app/routes/order.py:157:        result = mt5.order_send(request_data)
backend/mt5/app/routes/order.py:158:        if result.retcode != mt5.TRADE_RETCODE_DONE:
backend/mt5/app/routes/order.py:159:            error_code, error_str = mt5.last_error()
backend/mt5/app/routes/order.py:163:                "mt5_error": error_str,
backend/mt5/app/routes/order.py:211:    Modify SL/TP of an open position via TRADE_ACTION_SLTP.
backend/mt5/app/routes/order.py:223:            'action': mt5.TRADE_ACTION_SLTP,
backend/mt5/app/routes/order.py:227:            'type_time': mt5.ORDER_TIME_GTC,
backend/mt5/app/routes/order.py:228:            'type_filling': mt5.ORDER_FILLING_IOC,
backend/mt5/app/routes/order.py:235:        result = mt5.order_send(req)
backend/mt5/app/routes/order.py:236:        if result and result.retcode == mt5.TRADE_RETCODE_DONE:
backend/mt5/app/routes/order.py:239:        err = mt5.last_error()
backend/mt5/app/routes/order.py:244:            "mt5_error": err
backend/mt5/app/routes/order.py:251:@order_bp.route('/partial_close', methods=['POST'])
backend/mt5/app/routes/order.py:267:def partial_close_endpoint():
backend/mt5/app/routes/order.py:277:        positions = mt5.positions_get()
backend/mt5/app/routes/order.py:285:        vol_to_close = round(float(pos.volume) * fraction, 2)
backend/mt5/app/routes/order.py:286:        if vol_to_close <= 0:
backend/mt5/app/routes/order.py:287:            return jsonify({'error': 'computed close volume <= 0'}), 400
backend/mt5/app/routes/order.py:288:        tick = mt5.symbol_info_tick(symbol)
backend/mt5/app/routes/order.py:291:        opposite = mt5.ORDER_TYPE_SELL if int(pos.type) == mt5.ORDER_TYPE_BUY else mt5.ORDER_TYPE_BUY
backend/mt5/app/routes/order.py:292:        price = tick.bid if opposite == mt5.ORDER_TYPE_SELL else tick.ask
backend/mt5/app/routes/order.py:294:            'action': mt5.TRADE_ACTION_DEAL,
backend/mt5/app/routes/order.py:297:            'volume': vol_to_close,
backend/mt5/app/routes/order.py:301:            'type_time': mt5.ORDER_TIME_GTC,
backend/mt5/app/routes/order.py:302:            'type_filling': mt5.ORDER_FILLING_IOC,
backend/mt5/app/routes/order.py:304:        result = mt5.order_send(req)
backend/mt5/app/routes/order.py:305:        if result and result.retcode == mt5.TRADE_RETCODE_DONE:
backend/mt5/app/routes/order.py:307:        err = mt5.last_error()
backend/mt5/app/routes/order.py:308:        return jsonify({'error': 'partial_close_failed', 'retcode': getattr(result, 'retcode', None), 'mt5_error': err}), 400
backend/mt5/app/routes/order.py:310:        logger.error(f"Error in partial_close: {e}", exc_info=True)
backend/mt5/app/routes/order.py:314:@order_bp.route('/partial_close_v2', methods=['POST'])
backend/mt5/app/routes/order.py:315:def partial_close_v2_endpoint():
backend/mt5/app/routes/order.py:316:    """Enhanced partial close: accept either fraction (0..1) or explicit volume.
backend/mt5/app/routes/order.py:329:        positions = mt5.positions_get() or []
backend/mt5/app/routes/order.py:337:        # Determine volume to close
backend/mt5/app/routes/order.py:339:            vol_to_close = float(volume_req)
backend/mt5/app/routes/order.py:346:            vol_to_close = float(pos.volume) * f
backend/mt5/app/routes/order.py:348:        sinfo = mt5.symbol_info(symbol)
backend/mt5/app/routes/order.py:352:        steps = max(1, int(vol_to_close / vol_step + 1e-9))
backend/mt5/app/routes/order.py:353:        vol_to_close = round(steps * vol_step, 2)
backend/mt5/app/routes/order.py:354:        if vol_to_close < vol_min:
backend/mt5/app/routes/order.py:355:            return jsonify({'error': 'computed close volume below minimum', 'min': vol_min}), 400
backend/mt5/app/routes/order.py:356:        if vol_to_close > float(pos.volume):
backend/mt5/app/routes/order.py:357:            vol_to_close = float(pos.volume)
backend/mt5/app/routes/order.py:358:        # Build close request
backend/mt5/app/routes/order.py:359:        tick = mt5.symbol_info_tick(symbol)
backend/mt5/app/routes/order.py:362:        opposite = mt5.ORDER_TYPE_SELL if int(pos.type) == mt5.ORDER_TYPE_BUY else mt5.ORDER_TYPE_BUY
backend/mt5/app/routes/order.py:363:        price = tick.bid if opposite == mt5.ORDER_TYPE_SELL else tick.ask
backend/mt5/app/routes/order.py:365:            'action': mt5.TRADE_ACTION_DEAL,
backend/mt5/app/routes/order.py:368:            'volume': float(vol_to_close),
backend/mt5/app/routes/order.py:372:            'type_time': mt5.ORDER_TIME_GTC,
backend/mt5/app/routes/order.py:373:            'type_filling': mt5.ORDER_FILLING_IOC,
backend/mt5/app/routes/order.py:375:        result = mt5.order_send(req)
backend/mt5/app/routes/order.py:376:        if result and result.retcode == mt5.TRADE_RETCODE_DONE:
backend/mt5/app/routes/order.py:378:        err = mt5.last_error()
backend/mt5/app/routes/order.py:379:        return jsonify({'error': 'partial_close_failed', 'retcode': getattr(result, 'retcode', None), 'mt5_error': err}), 400
backend/mt5/app/routes/order.py:381:        logger.error(f"Error in partial_close_v2: {e}", exc_info=True)
backend/mt5/app/routes/order.py:398:        positions = mt5.positions_get() or []
backend/mt5/app/routes/order.py:405:        order_type = mt5.ORDER_TYPE_BUY if int(pos.type) == mt5.ORDER_TYPE_BUY else mt5.ORDER_TYPE_SELL
backend/mt5/app/routes/order.py:406:        tick = mt5.symbol_info_tick(pos.symbol)
backend/mt5/app/routes/order.py:409:        price = tick.ask if order_type == mt5.ORDER_TYPE_BUY else tick.bid
backend/mt5/app/routes/order.py:411:            'action': mt5.TRADE_ACTION_DEAL,
backend/mt5/app/routes/order.py:417:            'type_time': mt5.ORDER_TIME_GTC,
backend/mt5/app/routes/order.py:418:            'type_filling': mt5.ORDER_FILLING_IOC,
backend/mt5/app/routes/order.py:420:        result = mt5.order_send(req)
backend/mt5/app/routes/order.py:421:        if result and result.retcode == mt5.TRADE_RETCODE_DONE:
backend/mt5/app/routes/order.py:423:        err = mt5.last_error()
backend/mt5/app/routes/order.py:424:        return jsonify({'error': 'scale_failed', 'retcode': getattr(result, 'retcode', None), 'mt5_error': err}), 400
backend/mt5/app/routes/order.py:447:            positions = mt5.positions_get() or []
backend/mt5/app/routes/order.py:455:            side = mt5.ORDER_TYPE_SELL if int(pos.type) == mt5.ORDER_TYPE_BUY else mt5.ORDER_TYPE_BUY
backend/mt5/app/routes/order.py:463:        tick = mt5.symbol_info_tick(symbol)
backend/mt5/app/routes/order.py:466:        price = tick.bid if side == mt5.ORDER_TYPE_SELL else tick.ask
backend/mt5/app/routes/order.py:468:            'action': mt5.TRADE_ACTION_DEAL,
backend/mt5/app/routes/order.py:474:            'type_time': mt5.ORDER_TIME_GTC,
backend/mt5/app/routes/order.py:475:            'type_filling': mt5.ORDER_FILLING_IOC,
backend/mt5/app/routes/order.py:477:        result = mt5.order_send(req)
backend/mt5/app/routes/order.py:478:        if result and result.retcode == mt5.TRADE_RETCODE_DONE:
backend/mt5/app/routes/order.py:480:        err = mt5.last_error()
backend/mt5/app/routes/order.py:481:        return jsonify({'error': 'hedge_failed', 'retcode': getattr(result, 'retcode', None), 'mt5_error': err}), 400
backend/django/app/nexus/pulse/journal/__init__.py:4:(e.g., scores and decisions). All implementations must be fail-closed and must
backend/mt5/app/routes/position.py:2:import MetaTrader5 as mt5
backend/mt5/app/routes/position.py:4:from lib import close_position, close_all_positions, get_positions
backend/mt5/app/routes/position.py:10:@position_bp.route('/close_position', methods=['POST'])
backend/mt5/app/routes/position.py:38:            'description': 'Position closed successfully.',
backend/mt5/app/routes/position.py:58:            'description': 'Bad request or failed to close position.'
backend/mt5/app/routes/position.py:65:def close_position_endpoint():
backend/mt5/app/routes/position.py:76:        result = close_position(data['position'])
backend/mt5/app/routes/position.py:78:            return jsonify({"error": "Failed to close position"}), 400
backend/mt5/app/routes/position.py:80:        return jsonify({"message": "Position closed successfully", "result": result._asdict()})
backend/mt5/app/routes/position.py:83:        logger.error(f"Error in close_position: {str(e)}")
backend/mt5/app/routes/position.py:86:@position_bp.route('/close_all_positions', methods=['POST'])
backend/mt5/app/routes/position.py:128:            'description': 'Bad request or no positions were closed.'
backend/mt5/app/routes/position.py:135:def close_all_positions_endpoint():
backend/mt5/app/routes/position.py:146:        results = close_all_positions(order_type, magic)
backend/mt5/app/routes/position.py:148:            return jsonify({"message": "No positions were closed"}), 200
backend/mt5/app/routes/position.py:156:        logger.error(f"Error in close_all_positions: {str(e)}")
backend/mt5/app/routes/position.py:223:            "action": mt5.TRADE_ACTION_SLTP,
backend/mt5/app/routes/position.py:229:        result = mt5.order_send(request_data)
backend/mt5/app/routes/position.py:230:        if result.retcode != mt5.TRADE_RETCODE_DONE:
backend/mt5/app/routes/position.py:341:        total = mt5.positions_total()
backend/mt5/app/routes/symbol.py:2:import MetaTrader5 as mt5
backend/mt5/app/routes/symbol.py:46:    tick = mt5.symbol_info_tick(symbol)
backend/mt5/app/routes/symbol.py:96:    symbol_info = mt5.symbol_info(symbol)
backend/mt5/app/routes/health.py:2:import MetaTrader5 as mt5
backend/mt5/app/routes/health.py:17:                    'mt5_connected': {'type': 'boolean'},
backend/mt5/app/routes/health.py:18:                    'mt5_initialized': {'type': 'boolean'}
backend/mt5/app/routes/health.py:33:    initialized = mt5.initialize() if mt5 is not None else False
backend/mt5/app/routes/health.py:36:        "mt5_connected": mt5 is not None,
backend/mt5/app/routes/health.py:37:        "mt5_initialized": initialized
backend/mt5/app/tests/test_routes.py:25:@pytest.mark.mt5
backend/mt5/app/tests/test_routes.py:35:    monkeypatch.setattr(data.mt5, 'copy_ticks_from', fake_copy_ticks_from)
backend/mt5/app/tests/test_routes.py:43:@pytest.mark.mt5
backend/mt5/app/tests/test_routes.py:46:        {'time': 1000, 'open': 1.0, 'high': 1.2, 'low': 0.9, 'close': 1.1, 'tick_volume': 10, 'spread': 2, 'real_volume': 15},
backend/mt5/app/tests/test_routes.py:47:        {'time': 1001, 'open': 1.1, 'high': 1.3, 'low': 1.0, 'close': 1.2, 'tick_volume': 12, 'spread': 2, 'real_volume': 16},
backend/mt5/app/tests/test_routes.py:53:    monkeypatch.setattr(data.mt5, 'copy_rates_from_pos', fake_copy_rates_from_pos)
